"""
KIE (Knowledge Is Everything) Telegram Bot
Enhanced version with KIE AI model selection and generation
"""

from __future__ import annotations

import logging
import asyncio
import sys
import os
from pathlib import Path
from typing import Optional, Dict, Any, List

# Enable logging FIRST (before any other imports that might log)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

logger = logging.getLogger(__name__)

# ==================== SELF-CHECK: ENV SUMMARY AND VALIDATION ====================
def log_env_summary():
    """–õ–æ–≥–∏—Ä—É–µ—Ç summary ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –±–µ–∑ —Å–µ–∫—Ä–µ—Ç–æ–≤"""
    env_vars = {
        "PORT": os.getenv("PORT", "not set"),
        "RENDER": os.getenv("RENDER", "not set"),
        "ENV": os.getenv("ENV", "not set"),
        "BOT_MODE": os.getenv("BOT_MODE", "not set"),
        "STORAGE_MODE": os.getenv("STORAGE_MODE", "not set"),
        "DATABASE_URL": "[SET]" if os.getenv("DATABASE_URL") else "[NOT SET]",
        "TELEGRAM_BOT_TOKEN": "[SET]" if os.getenv("TELEGRAM_BOT_TOKEN") else "[NOT SET]",
        "KIE_API_KEY": "[SET]" if os.getenv("KIE_API_KEY") else "[NOT SET]",
        "KIE_API_URL": os.getenv("KIE_API_URL", "not set"),
        "TEST_MODE": os.getenv("TEST_MODE", "not set"),
        "DRY_RUN": os.getenv("DRY_RUN", "not set"),
        "ALLOW_REAL_GENERATION": os.getenv("ALLOW_REAL_GENERATION", "not set"),
        "KIE_STUB": os.getenv("KIE_STUB", "not set"),
    }
    
    logger.info("=" * 60)
    logger.info("ENVIRONMENT VARIABLES SUMMARY")
    logger.info("=" * 60)
    for key, value in sorted(env_vars.items()):
        logger.info(f"{key}={value}")
    logger.info("=" * 60)


def validate_required_env():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
    errors = []
    warnings = []
    
    # TELEGRAM_BOT_TOKEN - –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –≤—Å–µ–≥–¥–∞
    if not os.getenv("TELEGRAM_BOT_TOKEN"):
        errors.append("TELEGRAM_BOT_TOKEN is required but not set")
    
    # KIE_API_KEY - –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –µ—Å–ª–∏ real generation
    allow_real = os.getenv("ALLOW_REAL_GENERATION", "1") != "0"
    test_mode = os.getenv("TEST_MODE", "0") == "1"
    kie_stub = os.getenv("KIE_STUB", "0") == "1"
    
    if allow_real and not test_mode and not kie_stub:
        if not os.getenv("KIE_API_KEY"):
            errors.append("KIE_API_KEY is required for real generation (set ALLOW_REAL_GENERATION=0 or TEST_MODE=1 to disable)")
    
    # DATABASE_URL - –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω, –Ω–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º –µ—Å–ª–∏ –Ω–µ—Ç
    if not os.getenv("DATABASE_URL"):
        warnings.append("DATABASE_URL not set - will use JSON storage fallback")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ (warning, –Ω–µ error - –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º)
    models_yaml = Path(__file__).parent / "models" / "kie_models.yaml"
    if not models_yaml.exists():
        warnings.append(f"models/kie_models.yaml not found at {models_yaml} - model registry may not work")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º PyYAML (warning, –Ω–µ error - –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ä–µ–∂–∏–º–∞—Ö)
    try:
        import yaml
    except ImportError:
        warnings.append("PyYAML not installed - model registry from YAML will not work (install with: pip install PyYAML)")
    
    # –í—ã–≤–æ–¥–∏–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
    if warnings:
        logger.warning("=" * 60)
        logger.warning("ENVIRONMENT WARNINGS")
        logger.warning("=" * 60)
        for warning in warnings:
            logger.warning(f"‚ö†Ô∏è  {warning}")
        logger.warning("=" * 60)
    
    # –í—ã–≤–æ–¥–∏–º –æ—à–∏–±–∫–∏ –∏ –≤—ã—Ö–æ–¥–∏–º
    if errors:
        logger.error("=" * 60)
        logger.error("ENVIRONMENT VALIDATION FAILED")
        logger.error("=" * 60)
        for error in errors:
            logger.error(f"‚ùå {error}")
        logger.error("=" * 60)
        logger.error("Please fix the errors above and restart the bot")
        sys.exit(1)
    
    logger.info("‚úÖ Environment validation passed")


# –í—ã–ø–æ–ª–Ω—è–µ–º self-check –ü–ï–†–ï–î –∏–º–ø–æ—Ä—Ç–æ–º –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π
# –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —è–≤–Ω–æ –∑–∞–ø—Ä–æ—à–µ–Ω–æ —á–µ—Ä–µ–∑ RUN_ENV_CHECK=1 –∏ –Ω–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ —á–µ—Ä–µ–∑ SKIP_CONFIG_INIT=1
# –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ç–µ—Å—Ç–∞–º –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–æ–¥—É–ª—å –±–µ–∑ side effects
if os.getenv("RUN_ENV_CHECK", "0") == "1" and os.getenv("SKIP_CONFIG_INIT", "0") != "1":
    log_env_summary()
    validate_required_env()
elif os.getenv("SKIP_CONFIG_INIT", "0") != "1" and os.getenv("TEST_MODE", "0") != "1":
    # –í production —Ä–µ–∂–∏–º–µ –ª–æ–≥–∏—Ä—É–µ–º summary –±–µ–∑ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ (—á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ ENV)
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –±—É–¥–µ—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –≤ main() / create_bot_application()
    log_env_summary()

# ==================== IMPORTS AFTER SELF-CHECK ====================
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    ConversationHandler, CallbackQueryHandler
)
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

# –£–±—Ä–∞–Ω–æ: from dotenv import load_dotenv
# –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard)

# ==================== GLOBAL POLLING START CONTROL ====================
# –ñ—ë—Å—Ç–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—É—Å–∫–æ–≤ polling (409 Conflict)
_POLLING_STARTED = False
_POLLING_LOCK = asyncio.Lock()
from knowledge_storage import KnowledgeStorage
from translations import t, TRANSLATIONS
from kie_client import get_client
from kie_gateway import get_kie_gateway
from config_runtime import is_dry_run, allow_real_generation, is_test_mode, get_config_summary
from helpers import (
    build_main_menu_keyboard, get_balance_info, format_balance_message,
    get_balance_keyboard, set_constants
)
# –ò—Å–ø–æ–ª—å–∑—É–µ–º registry –∫–∞–∫ –µ–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –º–æ–¥–µ–ª–µ–π
from app.models.registry import get_models_sync
from kie_models import (
    get_generation_types, get_models_by_generation_type, get_generation_type_info
)

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–µ—Å—Ç—Ä–æ–º –º–æ–¥–µ–ª–µ–π
def get_model_by_id_from_registry(model_id: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ –ø–æ ID"""
    models = get_models_sync()
    for model in models:
        if model.get('id') == model_id:
            return model
    return None

def get_models_by_category_from_registry(category: str) -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –º–æ–¥–µ–ª–∏ –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
    models = get_models_sync()
    return [m for m in models if m.get('category') == category]

def get_categories_from_registry() -> List[str]:
    """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞"""
    models = get_models_sync()
    categories = set()
    for model in models:
        cat = model.get('category')
        if cat:
            categories.add(cat)
    return sorted(list(categories))
import json
import aiohttp
import aiofiles
import io
from io import BytesIO
import re
import platform
import random
import traceback
import time
from asyncio import Lock
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer

# Ensure Python can find modules in the same directory (for Render compatibility)
sys.path.insert(0, str(Path(__file__).parent))

# –£–±—Ä–∞–Ω–æ: load_dotenv()
# –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard)
# –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

# Try to import PIL/Pillow
try:
    from PIL import Image
    PIL_AVAILABLE = True
    logger.info("‚úÖ PIL/Pillow loaded successfully")
except ImportError:
    PIL_AVAILABLE = False
    logger.info("‚ÑπÔ∏è PIL/Pillow not available. Image analysis will be limited. Install with: pip install Pillow")

# Try to import pytesseract and configure Tesseract path
try:
    import pytesseract
    OCR_AVAILABLE = True
    tesseract_found = False
    
    # Try to set Tesseract path
    # On Windows, check common installation paths
    # On Linux (Render/Timeweb), Tesseract should be in PATH
    if platform.system() == 'Windows':
        # Common Tesseract installation paths on Windows
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Users\{}\AppData\Local\Programs\Tesseract-OCR\tesseract.exe'.format(os.getenv('USERNAME', '')),
        ]
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                logger.info(f"Tesseract found at: {path}")
                break
    else:
        # On Linux, Tesseract should be in PATH (installed via apt-get in Dockerfile)
        # Try to verify it's available by checking if command exists
        import shutil
        if shutil.which('tesseract'):
            logger.info("‚úÖ Tesseract found in PATH (Linux)")
            tesseract_found = True
        else:
            logger.info("‚ÑπÔ∏è Tesseract not found in PATH. OCR will be disabled. Install with: apt-get install tesseract-ocr")
            tesseract_found = False
    
    if not tesseract_found:
        logger.info("[INFO] Tesseract not found. OCR analysis will be disabled. Install tesseract-ocr package if needed.")
        OCR_AVAILABLE = False
    else:
        # Don't test Tesseract at import time - it can hang or timeout
        # Test will happen when OCR is actually needed
        logger.info("‚úÖ Tesseract OCR path configured. Will be tested when needed.")
except ImportError:
    OCR_AVAILABLE = False
    tesseract_found = False
    logger.info("‚ÑπÔ∏è pytesseract not available. OCR analysis will be disabled. Install with: pip install pytesseract")

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ app.config (—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑ ENV)
try:
    from app.config import BOT_TOKEN, DATABASE_URL as CONFIG_DATABASE_URL, BOT_MODE, WEBHOOK_URL
    from app.utils.mask import mask as mask_secret
    from app.singleton_lock import get_singleton_lock
    from app.bot_mode import get_bot_mode, ensure_polling_mode, ensure_webhook_mode, handle_conflict_gracefully
except ImportError:
    # Fallback –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (–µ—Å–ª–∏ app.config –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω)
    import warnings
    warnings.warn("app.config not found, using os.getenv directly. This is deprecated.")
    BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    CONFIG_DATABASE_URL = os.getenv('DATABASE_URL')
    BOT_MODE = os.getenv('BOT_MODE', 'polling')
    WEBHOOK_URL = os.getenv('WEBHOOK_URL')
    
    # Fallback –¥–ª—è mask_secret
    def mask_secret(value: Optional[str], show_first: int = 4, show_last: int = 4) -> str:
        """
        Fallback –º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.
        –í –ø—Ä–æ–¥–∞–∫—à–Ω –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ app.utils.mask.mask()
        """
        if not value:
            return ""
        if len(value) <= show_first + show_last:
            return "****"
        return value[:show_first] + "****" + value[-show_last:]
    
    # Fallback –¥–ª—è bot_mode —Ñ—É–Ω–∫—Ü–∏–π
    def get_bot_mode() -> str:
        """Fallback –¥–ª—è get_bot_mode"""
        mode = os.getenv("BOT_MODE", "").lower().strip()
        if not mode:
            if os.getenv("PORT") and os.getenv("WEBHOOK_URL"):
                mode = "webhook"
            else:
                mode = "polling"
        if mode not in ["polling", "webhook"]:
            mode = "polling"
        return mode
    
    async def ensure_polling_mode(bot):
        """Fallback –¥–ª—è ensure_polling_mode"""
        try:
            webhook_info = await bot.get_webhook_info()
            if webhook_info.url:
                await bot.delete_webhook(drop_pending_updates=True)
            return True
        except Exception:
            return False
    
    async def ensure_webhook_mode(bot, webhook_url: str):
        """Fallback –¥–ª—è ensure_webhook_mode"""
        if not webhook_url:
            return False
        try:
            await bot.set_webhook(url=webhook_url, drop_pending_updates=True)
            return True
        except Exception:
            return False
    
    def handle_conflict_gracefully(error, mode: str):
        """Fallback –¥–ª—è handle_conflict_gracefully"""
        import sys
        logging.getLogger(__name__).error(f"Conflict detected in {mode} mode: {error}")
        sys.exit(0)
    
    # Fallback –¥–ª—è singleton_lock
    class DummyLock:
        def acquire(self, timeout=None):
            return True
        def release(self):
            pass
    
    def get_singleton_lock(key: str):
        """Fallback –¥–ª—è get_singleton_lock"""
        return DummyLock()

# Admin user ID (can be set via environment variable)
try:
    admin_id_str = os.getenv('ADMIN_ID', '6913446846')
    if admin_id_str and admin_id_str != 'your_admin_id_here':
        ADMIN_ID = int(admin_id_str)
    else:
        ADMIN_ID = 6913446846  # Default fallback
except (ValueError, TypeError):
    ADMIN_ID = 6913446846  # Default fallback if invalid

# Price conversion constants
# Based on: 18 credits = $0.09 = 6.95 ‚ÇΩ
# NOTE: –¢–µ–ø–µ—Ä—å —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å config.settings –¥–ª—è —ç—Ç–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
CREDIT_TO_USD = 0.005  # 1 credit = $0.005 ($0.09 / 18)
USD_TO_RUB_DEFAULT = 6.95 / 0.09  # 1 USD = 77.2222... RUB (calculated from 6.95 ‚ÇΩ / $0.09) - default value

def get_usd_to_rub_rate() -> float:
    """
    Get USD to RUB exchange rate from file, or return default if not set.
    DEPRECATED: Use app.services.payments_service.get_usd_to_rub_rate() instead
    """
    # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏–∑ app/services/payments_service (–ë–ï–ó circular import)
    try:
        from app.services.payments_service import get_usd_to_rub_rate as _get_rate
        return _get_rate()
    except ImportError:
        # Fallback –Ω–∞ —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É
        try:
            rate_data = load_json_file(CURRENCY_RATE_FILE, {})
            rate = rate_data.get('usd_to_rub', USD_TO_RUB_DEFAULT)
            if isinstance(rate, (int, float)) and rate > 0:
                return float(rate)
            else:
                logger.warning(f"Invalid currency rate in file: {rate}, using default: {USD_TO_RUB_DEFAULT}")
                return USD_TO_RUB_DEFAULT
        except Exception as e:
            logger.error(f"Error loading currency rate: {e}, using default: {USD_TO_RUB_DEFAULT}")
            return USD_TO_RUB_DEFAULT

def set_usd_to_rub_rate(rate: float) -> bool:
    """Set USD to RUB exchange rate and save to file."""
    try:
        if not isinstance(rate, (int, float)) or rate <= 0:
            logger.error(f"Invalid currency rate: {rate}")
            return False
        
        rate_data = {'usd_to_rub': float(rate)}
        save_json_file(CURRENCY_RATE_FILE, rate_data)
        logger.info(f"Currency rate updated: 1 USD = {rate} RUB")
        return True
    except Exception as e:
        logger.error(f"Error saving currency rate: {e}")
        return False

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
try:
    from bot_kie_services import pricing_service, storage_service, model_validator
    from bot_kie_utils import is_admin as is_admin_new
    NEW_SERVICES_AVAILABLE = True
    logger.info("‚úÖ –ù–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
except ImportError as e:
    NEW_SERVICES_AVAILABLE = False
    # –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –º–æ–¥—É–ª—å bot_kie_services –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
    logger.debug(f"‚ÑπÔ∏è –ù–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (—ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ): {e}")

# –ò–º–ø–æ—Ä—Ç –º–æ–¥—É–ª—è –ë–î –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ –∏ –∏—Å—Ç–æ—Ä–∏–∏
# Storage is now handled by app.storage.factory - no need for DATABASE_AVAILABLE flag
# Old database.py functions are deprecated in favor of storage layer
try:
    from database import (
        log_kie_operation,  # Still used for logging
        create_operation,  # Still used for operation logging
        get_user_operations,  # Still used for operations history
    )
    logger.info("[OK] Database module loaded (legacy functions for logging)")
except ImportError:
    logger.info("‚ÑπÔ∏è Database module not available (logging functions will be skipped)")
    log_kie_operation = None
    create_operation = None
    get_user_operations = None
except Exception as e:
    logger.warning(f"‚ö†Ô∏è Error loading database module: {e}")
    log_kie_operation = None
    create_operation = None
    get_user_operations = None

# Initialize knowledge storage and KIE client (will be initialized in main() to avoid blocking import)
storage = None
kie = None

# PostgreSQL advisory lock connection (global –¥–ª—è keep-alive –∑–∞–¥–∞—á–∏)
# lock_conn –∏ lock_key_int —É–¥–∞–ª–µ–Ω—ã - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è app.locking.single_instance

# Store user sessions
user_sessions = {}

# Store active generations - allows multiple concurrent generations per user
# Structure: active_generations[(user_id, task_id)] = {session_data}
active_generations = {}
active_generations_lock = asyncio.Lock()

# Store saved generation data for "generate again" feature
saved_generations = {}

# Maximum concurrent generations per user (to prevent abuse)
MAX_CONCURRENT_GENERATIONS_PER_USER = 5


def get_admin_limits() -> dict:
    """Get admin limits data."""
    return load_json_file(ADMIN_LIMITS_FILE, {})


def save_admin_limits(data: dict):
    """Save admin limits data."""
    save_json_file(ADMIN_LIMITS_FILE, data)


def is_admin(user_id: int) -> bool:
    """Check if user is admin (main admin or limited admin)."""
    if user_id == ADMIN_ID:
        return True
    admin_limits = get_admin_limits()
    return str(user_id) in admin_limits


def get_admin_spent(user_id: int) -> float:
    """Get amount spent by admin (for limited admins)."""
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('spent', 0.0)


def get_admin_limit(user_id: int) -> float:
    """Get spending limit for admin (100 rubles for limited admins, unlimited for main admin)."""
    if user_id == ADMIN_ID:
        return float('inf')  # Main admin has unlimited
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('limit', 100.0)  # Default 100 rubles


def add_admin_spent(user_id: int, amount: float):
    """Add to admin's spent amount."""
    if user_id == ADMIN_ID:
        return  # Main admin doesn't have limits
    admin_limits = get_admin_limits()
    if str(user_id) not in admin_limits:
        return
    admin_limits[str(user_id)]['spent'] = admin_limits[str(user_id)].get('spent', 0.0) + amount
    save_admin_limits(admin_limits)


def get_admin_remaining(user_id: int) -> float:
    """Get remaining limit for admin."""
    limit = get_admin_limit(user_id)
    if limit == float('inf'):
        return float('inf')
    spent = get_admin_spent(user_id)
    return max(0.0, limit - spent)


def get_is_admin(user_id: int) -> bool:
    """
    Determine if user is admin, taking into account admin user mode.
    
    If admin is in user mode (admin_user_mode = True), returns False.
    Otherwise, returns True for admin, False for regular users.
    """
    if is_admin(user_id):
        # Check if admin is in user mode (viewing as regular user)
        if user_id in user_sessions and user_sessions[user_id].get('admin_user_mode', False):
            return False  # Show as regular user
        else:
            return True
    else:
        return False


def is_user_mode(user_id: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∞–¥–º–∏–Ω –≤ —Ä–µ–∂–∏–º–µ –æ–±—ã—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    
    Returns:
        True –µ—Å–ª–∏ –∞–¥–º–∏–Ω –≤ —Ä–µ–∂–∏–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, False –∏–Ω–∞—á–µ
    """
    if not is_admin(user_id):
        return False  # –ù–µ –∞–¥–º–∏–Ω –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ —Ä–µ–∂–∏–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    return user_id in user_sessions and user_sessions[user_id].get('admin_user_mode', False)


def create_user_context_for_pricing(user_id: int, has_free_generations: bool = False) -> 'UserContext':
    """
    –°–æ–∑–¥–∞–µ—Ç UserContext –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ü–µ–Ω.
    
    –í–°–ï –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–º–∏–Ω–∞ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é.
    –ó–∞–ø—Ä–µ—â–µ–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å is_admin –∫–∞–∫ bool –Ω–∞–ø—Ä—è–º—É—é.
    
    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        has_free_generations: –ï—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    
    Returns:
        UserContext —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ is_admin –∏ is_user_mode
    """
    from services.user_context_factory import create_user_context
    
    return create_user_context(
        user_id=user_id,
        is_admin_func=is_admin,
        is_user_mode_func=is_user_mode,
        has_free_generations=has_free_generations
    )


# COMPATIBILITY WRAPPER: calculate_price_rub –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç services.pricing_service.get_price() –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º
def calculate_price_rub(model_id: str, params: dict = None, is_admin: bool = False, user_id: int = None) -> float:
    """
    Thin-wrapper –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç services.pricing_service.get_price() –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º.
    
    Args:
        model_id: ID –º–æ–¥–µ–ª–∏
        params: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        is_admin: –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–æ–º
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    
    Returns:
        –¶–µ–Ω–∞ –≤ —Ä—É–±–ª—è—Ö
    """
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π pricing_service –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞
        from app.services.pricing_service import price_for_model_rub, get_model_price_info
        from app.config import get_settings
        
        settings = get_settings()
        mode_index = 0  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–≤—ã–π —Ä–µ–∂–∏–º
        
        # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞
        price_rub = price_for_model_rub(model_id, mode_index, settings)
        
        if price_rub is None:
            logger.warning(f"Price not found for model {model_id}, using fallback")
            return 1.0
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–µ
        price_info = get_model_price_info(model_id, mode_index, settings)
        if price_info:
            logger.info(
                f"PRICE_RUB={price_rub} OFFICIAL_USD={price_info['official_usd']:.4f} "
                f"MULT={price_info['price_multiplier']} RATE={price_info['usd_to_rub']} "
                f"MODEL={model_id}"
            )
        
        return float(price_rub)
    except ImportError as e:
        logger.warning(f"app.services.pricing_service not available: {e}, using fallback pricing")
        return 1.0
    except Exception as e:
        logger.error(f"Error in calculate_price_rub: {e}", exc_info=True)
        # Fallback: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—É
        return 1.0

# Conversation states for model selection and parameter input
SELECTING_MODEL, INPUTTING_PARAMS, CONFIRMING_GENERATION = range(3)

# Payment states
SELECTING_AMOUNT, WAITING_PAYMENT_SCREENSHOT = range(3, 5)

# Admin test OCR state
ADMIN_TEST_OCR = 5

# Broadcast states
WAITING_BROADCAST_MESSAGE = 6
WAITING_CURRENCY_RATE = 7

# Store user sessions - now supports multiple concurrent generations per user
# Structure: user_sessions[user_id] = {session_data} for input/parameter collection
# Once task is created, it moves to active_generations
# NOTE: user_sessions already declared above (line 224), this is a duplicate - removed

# Store active generations - allows multiple concurrent generations per user
# Structure: active_generations[(user_id, task_id)] = {session_data}
# NOTE: active_generations already declared above (line 358), this is a duplicate - removed


def format_price_rub(price: float, is_admin: bool = False) -> str:
    """Format price in rubles with appropriate text (rounded to 2 decimal places)."""
    # Always round to 2 decimal places
    price_rounded = round(price, 2)
    price_str = f"{price_rounded:.2f}"
    if is_admin:
        return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (—Ü–µ–Ω–∞: {price_str} ‚ÇΩ)"
    else:
        return f"üí∞ <b>{price_str} ‚ÇΩ</b>"


def get_model_price_text(model_id: str, params: dict = None, is_admin: bool = False, user_id: int = None) -> str:
    """Get formatted price text for a model."""
    price = calculate_price_rub(model_id, params, is_admin, user_id)
    return format_price_rub(price, is_admin)

# Broadcast states
WAITING_BROADCAST_MESSAGE = 6
WAITING_CURRENCY_RATE = 7

# Helper functions for balance management

# Data directory - use environment variable or default to ./data
# This allows mounting a volume for persistent storage
DATA_DIR = os.getenv('DATA_DIR', './data')
if not os.path.exists(DATA_DIR):
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        logger.info(f"‚úÖ Created data directory: {DATA_DIR}")
    except Exception as e:
        logger.error(f"‚ùå Failed to create data directory {DATA_DIR}: {e}")
        # Fallback to current directory if data dir creation fails
        DATA_DIR = '.'
        logger.warning(f"‚ö†Ô∏è Using current directory for data storage")


def get_data_file_path(filename: str) -> str:
    """Get full path to data file, ensuring directory exists."""
    data_dir = Path(__file__).parent / "data"
    data_dir.mkdir(exist_ok=True)
    return str(data_dir / filename)


# NOTE: active_generations already declared above (line 358), this is a duplicate - removed

# File operation locks to prevent race conditions (using threading.Lock for sync operations)
_file_locks = {
    'balances': threading.Lock(),
    'generations_history': threading.Lock(),
    'referrals': threading.Lock(),
    'promocodes': threading.Lock(),
    'free_generations': threading.Lock(),
    'languages': threading.Lock(),
    'gifts': threading.Lock(),
    'payments': threading.Lock(),
    'broadcasts': threading.Lock(),
    'admin_limits': threading.Lock(),
    'blocked_users': threading.Lock()
}

# In-memory cache for frequently accessed data (optimized for 1000+ users)
_data_cache = {
    'balances': {},
    'free_generations': {},
    'languages': {},
    'gifts': {},
    'cache_timestamps': {}
}

# Cache TTL in seconds (5 minutes)
CACHE_TTL = 300
_last_save_time = {}

# Data directory - use environment variable or default to ./data
# This allows mounting a volume for persistent storage
DATA_DIR = os.getenv('DATA_DIR', './data')
if not os.path.exists(DATA_DIR):
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        logger.info(f"‚úÖ Created data directory: {DATA_DIR}")
    except Exception as e:
        logger.error(f"‚ùå Failed to create data directory {DATA_DIR}: {e}")
        # Fallback to current directory if data dir creation fails
        DATA_DIR = '.'
        logger.warning(f"‚ö†Ô∏è Using current directory for data storage")

def get_data_file_path(filename: str) -> str:
    """Get full path to data file, ensuring directory exists."""
    if DATA_DIR == '.':
        return filename
    return os.path.join(DATA_DIR, filename)

# Payment data files - all stored in DATA_DIR for persistence
BALANCES_FILE = get_data_file_path("user_balances.json")
USER_LANGUAGES_FILE = get_data_file_path("user_languages.json")
GIFT_CLAIMED_FILE = get_data_file_path("gift_claimed.json")
ADMIN_LIMITS_FILE = get_data_file_path("admin_limits.json")  # File to store admins with spending limits
PAYMENTS_FILE = get_data_file_path("payments.json")
BLOCKED_USERS_FILE = get_data_file_path("blocked_users.json")
FREE_GENERATIONS_FILE = get_data_file_path("daily_free_generations.json")  # File to store daily free generations
PROMOCODES_FILE = get_data_file_path("promocodes.json")  # File to store promo codes
CURRENCY_RATE_FILE = get_data_file_path("currency_rate.json")  # File to store USD to RUB exchange rate
REFERRALS_FILE = get_data_file_path("referrals.json")  # File to store referral data
BROADCASTS_FILE = get_data_file_path("broadcasts.json")  # File to store broadcast statistics
GENERATIONS_HISTORY_FILE = get_data_file_path("generations_history.json")  # File to store user generation history

# Free generation settings
FREE_MODEL_ID = "z-image"  # Model that is free for users

def is_video_model(model_id: str) -> bool:
    """Check if model is a video generation model"""
    video_keywords = ['video', 'animate', 'avatar', 'speech-to-video']
    return any(keyword in model_id.lower() for keyword in video_keywords)

def is_audio_model(model_id: str) -> bool:
    """Check if model is an audio processing model"""
    audio_keywords = ['speech-to-text', 'audio', 'transcribe']
    return any(keyword in model_id.lower() for keyword in audio_keywords)
FREE_GENERATIONS_PER_DAY = 5  # Number of free generations per day per user
REFERRAL_BONUS_GENERATIONS = 5  # Bonus generations for inviting a user

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ helpers
set_constants(FREE_GENERATIONS_PER_DAY, REFERRAL_BONUS_GENERATIONS, ADMIN_ID)


# ==================== Payment System Functions ====================

def get_cache_key(filename: str) -> str:
    """Get cache key for filename."""
    cache_map = {
        BALANCES_FILE: 'balances',
        FREE_GENERATIONS_FILE: 'free_generations',
        USER_LANGUAGES_FILE: 'languages',
        GIFT_CLAIMED_FILE: 'gifts',
        REFERRALS_FILE: 'referrals',
        PROMOCODES_FILE: 'promocodes',
        GENERATIONS_HISTORY_FILE: 'generations_history',
        PAYMENTS_FILE: 'payments',
        BROADCASTS_FILE: 'broadcasts',
        ADMIN_LIMITS_FILE: 'admin_limits',
        BLOCKED_USERS_FILE: 'blocked_users'
    }
    return cache_map.get(filename, filename)

def load_json_file(filename: str, default: dict = None) -> dict:
    """Load JSON file with caching and locking for performance (optimized for 1000+ users).
    Automatically creates file if it doesn't exist (for critical files)."""
    if default is None:
        default = {}
    
    cache_key = get_cache_key(filename)
    current_time = time.time()
    
    # Check cache first (thread-safe read)
    if cache_key in _data_cache['cache_timestamps']:
        cache_time = _data_cache['cache_timestamps'][cache_key]
        if current_time - cache_time < CACHE_TTL and cache_key in _data_cache:
            if cache_key != filename:  # Only for mapped cache keys
                cached_data = _data_cache.get(cache_key)
                if cached_data is not None:
                    return cached_data.copy()
    
    # Get lock for this file type
    lock_key = cache_key if cache_key in _file_locks else 'balances'  # Default to balances lock
    lock = _file_locks.get(lock_key, _file_locks['balances'])
    
    # Load from file with lock to prevent race conditions
    with lock:
        try:
            if os.path.exists(filename):
                with open(filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    # Update cache (thread-safe)
                    if cache_key != filename:
                        _data_cache[cache_key] = data.copy()
                        _data_cache['cache_timestamps'][cache_key] = current_time
                    return data
            else:
                # For critical files, create empty file if it doesn't exist
                critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE]
                if filename in critical_files:
                    try:
                        # Ensure directory exists
                        dir_path = os.path.dirname(filename)
                        if dir_path and not os.path.exists(dir_path):
                            os.makedirs(dir_path, exist_ok=True)
                        
                        # Create empty file
                        with open(filename, 'w', encoding='utf-8') as f:
                            json.dump(default, f, ensure_ascii=False, indent=2)
                        logger.info(f"‚úÖ Auto-created missing critical file: {filename}")
                        return default
                    except Exception as e:
                        logger.error(f"Error auto-creating critical file {filename}: {e}")
                        return default
                return default
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå JSON decode error in {filename}: {e}. File may be corrupted. Returning default.")
            # Try to backup corrupted file
            try:
                backup_name = filename + '.corrupted.' + str(int(time.time()))
                if os.path.exists(filename):
                    os.rename(filename, backup_name)
                    logger.warning(f"Backed up corrupted file to {backup_name}")
            except:
                pass
            return default
        except Exception as e:
            logger.error(f"Error loading {filename}: {e}", exc_info=True)
            return default


def save_json_file(filename: str, data: dict, use_cache: bool = True):
    """Save data to JSON file with batched writes (optimized for 1000+ users).
    Guarantees data persistence for critical files."""
    try:
        cache_key = get_cache_key(filename)
        current_time = time.time()
        
        # Update cache immediately
        if use_cache and cache_key != filename:
            _data_cache[cache_key] = data.copy()
            _data_cache['cache_timestamps'][cache_key] = current_time
        
        # Batch writes: only save if enough time passed (reduce I/O)
        # For critical files (balances, generations history, payments, gift claims), save immediately always
        critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE, GIFT_CLAIMED_FILE]
        is_critical = filename in critical_files
        
        if not is_critical and filename in _last_save_time:
            time_since_last_save = current_time - _last_save_time[filename]
            # For non-critical files, batch every 2 seconds max
            if time_since_last_save < 2.0:
                return  # Skip write, will be saved later or by batch save
        
        # Ensure directory exists (for subdirectories like knowledge_store)
        dir_path = os.path.dirname(filename)
        if dir_path and not os.path.exists(dir_path):
            try:
                os.makedirs(dir_path, exist_ok=True)
            except Exception as e:
                logger.error(f"Error creating directory {dir_path}: {e}")
        
        # Perform actual write with atomic operation (write to temp file, then rename)
        temp_filename = filename + '.tmp'
        try:
            # Write to temporary file first
            with open(temp_filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                f.flush()  # Force write to disk immediately
                if hasattr(os, 'fsync'):
                    os.fsync(f.fileno())  # Force sync to disk (Unix/Linux)
            
            # Atomic rename (works on Unix/Linux/Windows)
            if os.path.exists(filename):
                os.replace(temp_filename, filename)
            else:
                os.rename(temp_filename, filename)
            
            # Verify file was written correctly
            if os.path.exists(filename):
                file_size = os.path.getsize(filename)
                if file_size == 0:
                    logger.error(f"‚ùå CRITICAL: {filename} was written but is empty!")
                else:
                    logger.debug(f"‚úÖ Saved {filename} ({file_size} bytes)")
            else:
                logger.error(f"‚ùå CRITICAL: {filename} does not exist after save!")
            
        except Exception as e:
            # Clean up temp file on error
            if os.path.exists(temp_filename):
                try:
                    os.remove(temp_filename)
                except:
                    pass
            raise e
        
        _last_save_time[filename] = current_time
    except Exception as e:
        logger.error(f"‚ùå CRITICAL ERROR saving {filename}: {e}", exc_info=True)
        # For critical files, try one more time
        if filename in critical_files:
            try:
                logger.warning(f"Retrying save for critical file {filename}...")
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                    f.flush()
                    if hasattr(os, 'fsync'):
                        os.fsync(f.fileno())
                logger.info(f"‚úÖ Retry successful for {filename}")
            except Exception as retry_error:
                logger.error(f"‚ùå Retry failed for {filename}: {retry_error}", exc_info=True)


async def get_http_client() -> aiohttp.ClientSession:
    """Get or create global HTTP client with connection pooling."""
    global _http_client
    if _http_client is None or _http_client.closed:
        connector = aiohttp.TCPConnector(
            limit=100,  # Max connections
            limit_per_host=30,  # Max connections per host
            ttl_dns_cache=300,  # DNS cache TTL
            use_dns_cache=True,
        )
        timeout = aiohttp.ClientTimeout(total=60, connect=10)
        _http_client = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': 'TelegramBot/1.0'}
        )
    return _http_client


async def cleanup_http_client():
    """Close HTTP client on shutdown."""
    global _http_client
    if _http_client and not _http_client.closed:
        await _http_client.close()
        _http_client = None


def cleanup_old_sessions(max_age_seconds: int = 3600):
    """Clean up old user sessions to prevent memory leaks (optimized for 1000+ users)."""
    current_time = time.time()
    keys_to_remove = []
    
    for user_id, session in user_sessions.items():
        session_time = session.get('last_activity', current_time)
        if current_time - session_time > max_age_seconds:
            keys_to_remove.append(user_id)
    
    for key in keys_to_remove:
        del user_sessions[key]
    
    if keys_to_remove:
        logger.info(f"Cleaned up {len(keys_to_remove)} old user sessions")


def update_session_activity(user_id: int):
    """Update last activity time for user session."""
    if user_id in user_sessions:
        user_sessions[user_id]['last_activity'] = time.time()


def get_user_balance(user_id: int) -> float:
    """Get user balance in rubles (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import get_user_balance as get_balance_async
    try:
        # Try to get current event loop
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # If loop is running, we can't use run_until_complete
            # Fall back to thread pool
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, get_balance_async(user_id))
                return future.result(timeout=5.0)
        else:
            return loop.run_until_complete(get_balance_async(user_id))
    except RuntimeError:
        # No event loop, create new one
        return asyncio.run(get_balance_async(user_id))
    except Exception as e:
        logger.error(f"‚ùå Error getting user balance: {e}", exc_info=True)
        return 0.0


def set_user_balance(user_id: int, amount: float):
    """Set user balance in rubles (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import set_user_balance as set_balance_async
    logger.info(f"üí∞üí∞üí∞ SET_BALANCE: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, set_balance_async(user_id, amount))
                future.result(timeout=5.0)
        else:
            loop.run_until_complete(set_balance_async(user_id, amount))
    except RuntimeError:
        asyncio.run(set_balance_async(user_id, amount))
    except Exception as e:
        logger.error(f"‚ùå Error setting user balance: {e}", exc_info=True)


def add_user_balance(user_id: int, amount: float) -> float:
    """Add amount to user balance, return new balance (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import add_user_balance as add_balance_async
    logger.info(f"üí∞üí∞üí∞ ADD_BALANCE: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, add_balance_async(user_id, amount))
                return future.result(timeout=5.0)
        else:
            return loop.run_until_complete(add_balance_async(user_id, amount))
    except RuntimeError:
        return asyncio.run(add_balance_async(user_id, amount))
    except Exception as e:
        logger.error(f"‚ùå Error adding user balance: {e}", exc_info=True)
        return get_user_balance(user_id)  # Return current balance on error


def subtract_user_balance(user_id: int, amount: float) -> bool:
    """Subtract amount from user balance. Returns True if successful, False if insufficient funds (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import subtract_user_balance as subtract_balance_async
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, subtract_balance_async(user_id, amount))
                return future.result(timeout=5.0)
        else:
            return loop.run_until_complete(subtract_balance_async(user_id, amount))
    except RuntimeError:
        return asyncio.run(subtract_balance_async(user_id, amount))
    except Exception as e:
        logger.error(f"‚ùå Error subtracting user balance: {e}", exc_info=True)
        return False


# ==================== Async wrappers for database operations ====================
# These use storage layer (async) - no blocking operations

async def get_user_balance_async(user_id: int) -> float:
    """Async get user balance using storage layer."""
    from app.services.user_service import get_user_balance as get_balance_async
    return await get_balance_async(user_id)


async def set_user_balance_async(user_id: int, amount: float):
    """Async set user balance using storage layer."""
    from app.services.user_service import set_user_balance as set_balance_async
    await set_balance_async(user_id, amount)


async def add_user_balance_async(user_id: int, amount: float) -> float:
    """Async add to user balance using storage layer."""
    from app.services.user_service import add_user_balance as add_balance_async
    return await add_balance_async(user_id, amount)


async def subtract_user_balance_async(user_id: int, amount: float) -> bool:
    """Async subtract from user balance using storage layer."""
    from app.services.user_service import subtract_user_balance as subtract_balance_async
    return await subtract_balance_async(user_id, amount)


def db_update_user_balance(user_id: int, amount: float):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞–ø—Ä—è–º—É—é –≤ –ë–î (–¥–ª—è —Ç–µ—Å—Ç–æ–≤/–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏).
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–æ–º.
    
    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        amount: –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å
    """
    logger.info(f"db_update_user_balance: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")
    set_user_balance(user_id, amount)


# ==================== User Language System ====================

# –ö—ç—à –¥–ª—è —è–∑—ã–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
_user_language_cache = {}
_user_language_cache_time = {}
CACHE_TTL_LANGUAGE = 300  # 5 –º–∏–Ω—É—Ç

def get_user_language(user_id: int) -> str:
    """Get user language preference (default: 'ru') with caching."""
    user_key = str(user_id)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    current_time = time.time()
    if user_key in _user_language_cache:
        cache_time = _user_language_cache_time.get(user_key, 0)
        if current_time - cache_time < CACHE_TTL_LANGUAGE:
            return _user_language_cache[user_key]
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    lang = languages.get(user_key, 'ru')  # Default to Russian
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
    _user_language_cache[user_key] = lang
    _user_language_cache_time[user_key] = current_time
    
    return lang

def has_user_language_set(user_id: int) -> bool:
    """Check if user has explicitly set their language preference."""
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    return str(user_id) in languages


def set_user_language(user_id: int, language: str):
    """Set user language preference ('ru' or 'en') and update cache."""
    user_key = str(user_id)
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    languages[user_key] = language
    save_json_file(USER_LANGUAGES_FILE, languages)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
    _user_language_cache[user_key] = language
    _user_language_cache_time[user_key] = time.time()


# ==================== Gift System ====================

def has_claimed_gift(user_id: int) -> bool:
    """Check if user has already claimed their gift."""
    claimed = load_json_file(GIFT_CLAIMED_FILE, {})
    return claimed.get(str(user_id), False)


def set_gift_claimed(user_id: int):
    """Mark gift as claimed for user."""
    claimed = load_json_file(GIFT_CLAIMED_FILE, {})
    claimed[str(user_id)] = True
    save_json_file(GIFT_CLAIMED_FILE, claimed)


def spin_gift_wheel() -> float:
    """Spin the gift wheel and return random amount between 10 and 30 rubles."""
    import random
    # Generate random amount between 10 and 30 with 2 decimal places
    amount = round(random.uniform(10.0, 30.0), 2)
    return amount


# ==================== Free Generations System ====================

def get_free_generations_data() -> dict:
    """Get daily free generations data."""
    return load_json_file(FREE_GENERATIONS_FILE, {})


def save_free_generations_data(data: dict):
    """Save daily free generations data."""
    save_json_file(FREE_GENERATIONS_FILE, data)


def get_user_free_generations_today(user_id: int) -> int:
    """Get number of free generations used by user today."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        return 0
    
    user_data = data[user_key]
    if user_data.get('date') == today:
        return user_data.get('count', 0)
    else:
        # Reset for new day
        return 0


def get_user_free_generations_remaining(user_id: int) -> int:
    """Get remaining free generations for user today (including bonus)."""
    used = get_user_free_generations_today(user_id)
    data = get_free_generations_data()
    user_key = str(user_id)
    bonus = data.get(user_key, {}).get('bonus', 0)
    total_available = FREE_GENERATIONS_PER_DAY + bonus
    remaining = total_available - used
    return max(0, remaining)


def use_free_generation(user_id: int) -> bool:
    """Use one free generation. Returns True if successful, False if limit reached."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        data[user_key] = {'date': today, 'count': 0, 'bonus': 0}
    
    user_data = data[user_key]
    
    # Reset if new day (but keep bonus)
    if user_data.get('date') != today:
        old_bonus = user_data.get('bonus', 0)
        user_data['date'] = today
        user_data['count'] = 0
        user_data['bonus'] = old_bonus  # Keep bonus across days
    
    # Get total available (base + bonus)
    bonus = user_data.get('bonus', 0)
    total_available = FREE_GENERATIONS_PER_DAY + bonus
    
    # Check limit (including bonus)
    if user_data.get('count', 0) >= total_available:
        return False
    
    # Increment count
    user_data['count'] = user_data.get('count', 0) + 1
    save_free_generations_data(data)
    return True


def is_free_generation_available(user_id: int, model_id: str) -> bool:
    """Check if free generation is available for this user and model."""
    # Only for regular users (not admins)
    if get_is_admin(user_id):
        return False
    
    # Only for free model
    if model_id != FREE_MODEL_ID:
        return False
    
    # Check if user has remaining free generations
    remaining = get_user_free_generations_remaining(user_id)
    return remaining > 0


# ==================== Referral System ====================

def get_referrals_data() -> dict:
    """Get referrals data."""
    return load_json_file(REFERRALS_FILE, {})


def save_referrals_data(data: dict):
    """Save referrals data."""
    save_json_file(REFERRALS_FILE, data)


def get_user_referrals(user_id: int) -> list:
    """Get list of users referred by this user."""
    data = get_referrals_data()
    user_key = str(user_id)
    return data.get(user_key, {}).get('referred_users', [])


def get_referrer(user_id: int) -> int:
    """Get the user who referred this user, or None if not referred."""
    data = get_referrals_data()
    user_key = str(user_id)
    return data.get(user_key, {}).get('referred_by')


def add_referral(referrer_id: int, referred_id: int):
    """Add a referral relationship and give bonus to referrer."""
    import time
    data = get_referrals_data()
    referrer_key = str(referrer_id)
    referred_key = str(referred_id)
    
    # Check if already referred
    if referred_key in data and data[referred_key].get('referred_by'):
        return  # Already referred by someone
    
    # Add referral relationship
    if referred_key not in data:
        data[referred_key] = {}
    data[referred_key]['referred_by'] = referrer_id
    data[referred_key]['referred_at'] = int(time.time())
    
    # Add to referrer's list
    if referrer_key not in data:
        data[referrer_key] = {'referred_users': []}
    if 'referred_users' not in data[referrer_key]:
        data[referrer_key]['referred_users'] = []
    
    if referred_id not in data[referrer_key]['referred_users']:
        data[referrer_key]['referred_users'].append(referred_id)
    
    save_referrals_data(data)
    
    # Give bonus generations to referrer
    give_bonus_generations(referrer_id, REFERRAL_BONUS_GENERATIONS)


def give_bonus_generations(user_id: int, bonus_count: int):
    """Give bonus free generations to a user."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        data[user_key] = {'date': today, 'count': 0, 'bonus': 0}
    
    user_data = data[user_key]
    
    # Reset if new day (but keep bonus)
    if user_data.get('date') != today:
        old_bonus = user_data.get('bonus', 0)
        user_data['date'] = today
        user_data['count'] = 0
        user_data['bonus'] = old_bonus + bonus_count
    else:
        user_data['bonus'] = user_data.get('bonus', 0) + bonus_count
    
    save_free_generations_data(data)


def get_user_referral_link(user_id: int, bot_username: str = None) -> str:
    """Get referral link for user."""
    if bot_username is None:
        bot_username = "Ferixdi_bot_ai_bot"
    return f"https://t.me/{bot_username}?start=ref_{user_id}"


def get_fake_online_count() -> int:
    """Generate dynamic fake online user count - changes every time it's called."""
    # Base number around 500
    base = 500
    # Random variation ¬±80 for more dynamic changes
    variation = random.randint(-80, 80)
    # Time-based variation (slight changes based on time of day)
    current_hour = time.localtime().tm_hour
    # More activity during day hours (9-22)
    if 9 <= current_hour <= 22:
        time_multiplier = random.randint(0, 50)
    else:
        time_multiplier = random.randint(-30, 20)
    
    # Add microsecond-based variation for more randomness
    microsecond_variation = random.randint(-20, 20)
    
    count = base + variation + time_multiplier + microsecond_variation
    # Ensure reasonable bounds (300-700 range)
    return max(300, min(700, count))


# ==================== Promocodes System ====================

def load_promocodes() -> list:
    """Load promocodes from file."""
    data = load_json_file(PROMOCODES_FILE, {})
    return data.get('promocodes', [])


def save_promocodes(promocodes: list):
    """Save promocodes to file."""
    data = {'promocodes': promocodes}
    save_json_file(PROMOCODES_FILE, data)


def get_active_promocode() -> dict:
    """Get the currently active promocode."""
    promocodes = load_promocodes()
    for promo in promocodes:
        if promo.get('active', False):
            return promo
    return None


# ==================== Broadcast System ====================

def get_all_users() -> list:
    """Get list of all user IDs from various sources."""
    user_ids = set()
    
    # From user balances
    balances = load_json_file(BALANCES_FILE, {})
    user_ids.update([int(uid) for uid in balances.keys() if uid.isdigit()])
    
    # From payments
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if 'user_id' in payment:
            user_ids.add(payment['user_id'])
    
    # From referrals
    referrals = get_referrals_data()
    for user_key in referrals.keys():
        if user_key.isdigit():
            user_ids.add(int(user_key))
        # Also get referred users
        referred_users = referrals.get(user_key, {}).get('referred_users', [])
        user_ids.update(referred_users)
    
    # From free generations
    free_gens = get_free_generations_data()
    for user_key in free_gens.keys():
        if user_key.isdigit():
            user_ids.add(int(user_key))
    
    return sorted(list(user_ids))


def save_broadcast(broadcast_data: dict):
    """Save broadcast statistics."""
    broadcasts = load_json_file(BROADCASTS_FILE, {})
    broadcast_id = broadcast_data.get('id', len(broadcasts) + 1)
    broadcasts[str(broadcast_id)] = broadcast_data
    save_json_file(BROADCASTS_FILE, broadcasts)
    return broadcast_id


def get_broadcasts() -> dict:
    """Get all broadcasts."""
    return load_json_file(BROADCASTS_FILE, {})


def get_broadcast(broadcast_id: int) -> dict:
    """Get specific broadcast by ID."""
    broadcasts = get_broadcasts()
    return broadcasts.get(str(broadcast_id), {})


# ==================== Generations History System ====================

def save_generation_to_history(user_id: int, model_id: str, model_name: str, params: dict, result_urls: list, task_id: str, price: float = 0.0, is_free: bool = False):
    """Save generation to user history (save to DB or JSON fallback)."""
    import time
    
    # Log operation (if create_operation is available)
    if create_operation:
        try:
            from decimal import Decimal
            # Get first result URL (if available)
            result_url = result_urls[0] if result_urls else None
            # Get prompt from params (truncate to 1000 chars)
            prompt = params.get('prompt', '')
            if prompt and len(prompt) > 1000:
                prompt = prompt[:1000]
            
            # Create operation in DB
            operation_id = create_operation(
                user_id=user_id,
                operation_type='generation',
                amount=Decimal(f'-{price}') if price > 0 else Decimal('0'),
                model=model_id,
                result_url=result_url,
                prompt=prompt if prompt else None
            )
            
            if operation_id:
                logger.info(f"‚úÖ Saved generation to DB: user_id={user_id}, model_id={model_id}, operation_id={operation_id}")
                # Return operation_id as generation_id for compatibility
                return operation_id
            else:
                logger.warning(f"‚ö†Ô∏è Failed to save generation to DB, using JSON fallback")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ –ë–î: {e}, –∏—Å–ø–æ–ª—å–∑—É–µ–º JSON fallback", exc_info=True)
            # Fallback to JSON
            pass
    
    # Fallback to JSON (original method)
    try:
        # Ensure history file exists
        if not os.path.exists(GENERATIONS_HISTORY_FILE):
            try:
                with open(GENERATIONS_HISTORY_FILE, 'w', encoding='utf-8') as f:
                    json.dump({}, f, ensure_ascii=False, indent=2)
                logger.info(f"Created history file {GENERATIONS_HISTORY_FILE}")
            except Exception as e:
                logger.error(f"Error creating history file {GENERATIONS_HISTORY_FILE}: {e}")
        
        history = load_json_file(GENERATIONS_HISTORY_FILE, {})
        user_key = str(user_id)
        
        if user_key not in history:
            history[user_key] = []
            logger.info(f"Created new history entry for user {user_id}")
        
        generation_entry = {
            'id': len(history[user_key]) + 1,
            'timestamp': int(time.time()),
            'model_id': model_id,
            'model_name': model_name,
            'params': params.copy(),
            'result_urls': result_urls.copy() if result_urls else [],
            'task_id': task_id,
            'price': price,
            'is_free': is_free
        }
        
        history[user_key].append(generation_entry)
        
        # Keep only last 100 generations per user
        if len(history[user_key]) > 100:
            history[user_key] = history[user_key][-100:]
        
        # Force immediate save for generations history (critical data)
        # Clear last save time to force immediate write
        if GENERATIONS_HISTORY_FILE in _last_save_time:
            del _last_save_time[GENERATIONS_HISTORY_FILE]
        
        # Ensure directory exists before saving
        dir_path = os.path.dirname(GENERATIONS_HISTORY_FILE)
        if dir_path and not os.path.exists(dir_path):
            os.makedirs(dir_path, exist_ok=True)
            logger.info(f"‚úÖ Created directory for history file: {dir_path}")
        
        save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
        
        # Verify file was saved and data is correct (with retry)
        max_retries = 3
        for retry in range(max_retries):
            if os.path.exists(GENERATIONS_HISTORY_FILE):
                # Reload to verify
                verify_history = load_json_file(GENERATIONS_HISTORY_FILE, {})
                if user_key in verify_history and len(verify_history[user_key]) > 0:
                    logger.info(f"‚úÖ Saved generation to history: user_id={user_id}, model_id={model_id}, gen_id={generation_entry['id']}, total_for_user={len(verify_history[user_key])}")
                    break
                elif retry < max_retries - 1:
                    logger.warning(f"‚ö†Ô∏è Retry {retry + 1}/{max_retries}: History verification failed, retrying save...")
                    save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=False)
                    import time
                    time.sleep(0.1)  # Small delay before retry
                else:
                    logger.error(f"‚ùå History saved but user data not found in file after {max_retries} retries! user_key={user_key}, file_keys={list(verify_history.keys())[:5]}")
            elif retry < max_retries - 1:
                logger.warning(f"‚ö†Ô∏è Retry {retry + 1}/{max_retries}: History file not found, retrying save...")
                save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=False)
                time.sleep(0.1)  # Small delay before retry
            else:
                logger.error(f"‚ùå Failed to save generation history file after {max_retries} retries: {GENERATIONS_HISTORY_FILE} does not exist after save!")
        
        return generation_entry['id']
    except Exception as e:
        logger.error(f"Error saving generation to history: {e}", exc_info=True)
        return None


def get_user_generations_history(user_id: int, limit: int = 20) -> list:
    """Get user's generation history."""
    try:
        # Check if file exists, create if it doesn't
        if not os.path.exists(GENERATIONS_HISTORY_FILE):
            # Create empty history file
            try:
                with open(GENERATIONS_HISTORY_FILE, 'w', encoding='utf-8') as f:
                    json.dump({}, f, ensure_ascii=False, indent=2)
                logger.info(f"Created history file {GENERATIONS_HISTORY_FILE}")
            except Exception as e:
                logger.error(f"Error creating history file {GENERATIONS_HISTORY_FILE}: {e}")
                return []
        
        history = load_json_file(GENERATIONS_HISTORY_FILE, {})
        if not history:
            # Empty history file is normal for new users or first run - use INFO instead of WARNING
            logger.info(f"History file {GENERATIONS_HISTORY_FILE} is empty (normal for new users)")
            return []
        
        # Try both string and integer keys (for compatibility)
        user_key_str = str(user_id)
        user_key_int = user_id
        
        # Debug: log what we're looking for
        logger.info(f"Loading history for user_id={user_id}, trying keys: '{user_key_str}' and {user_key_int}, total_users_in_file={len(history)}")
        
        # Check both string and integer keys
        user_history = None
        if user_key_str in history:
            user_history = history[user_key_str]
            logger.info(f"Found history with string key '{user_key_str}': {len(user_history)} generations")
        elif user_key_int in history:
            user_history = history[user_key_int]
            logger.info(f"Found history with integer key {user_key_int}: {len(user_history)} generations")
            # Migrate to string key for consistency
            history[user_key_str] = user_history
            if user_key_int != user_key_str:
                del history[user_key_int]
            save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
        else:
            # Try to find by checking all keys
            all_keys = list(history.keys())
            logger.info(f"User {user_id} not found in history file. Available keys (first 20): {all_keys[:20]}")
            
            # Try to find numeric matches
            for key in all_keys:
                try:
                    if int(key) == user_id:
                        user_history = history[key]
                        logger.info(f"Found history with numeric match: key={key}, generations={len(user_history)}")
                        # Migrate to string key
                        history[user_key_str] = user_history
                        if key != user_key_str:
                            del history[key]
                        save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
                        break
                except (ValueError, TypeError):
                    continue
            
            if user_history is None:
                logger.info(f"No history found for user {user_id} after checking all keys")
                return []
        
        if not user_history:
            logger.info(f"User {user_id} has empty history")
            return []
        
        # Return last N generations, sorted by timestamp (newest first)
        logger.info(f"Returning {min(limit, len(user_history))} generations for user {user_id} (total: {len(user_history)})")
        user_history.sort(key=lambda x: x.get('timestamp', 0), reverse=True)
        return user_history[:limit]
    except Exception as e:
        logger.error(f"Error loading user generations history: {e}", exc_info=True)
        return []


def get_generation_by_id(user_id: int, generation_id: int) -> dict:
    """Get specific generation by ID."""
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    user_key = str(user_id)
    
    if user_key not in history:
        return None
    
    for gen in history[user_key]:
        if gen.get('id') == generation_id:
            return gen
    
    return None


def is_new_user(user_id: int) -> bool:
    """Check if user is new (no balance, no history, no payments)."""
    # Check balance
    balance = get_user_balance(user_id)
    if balance > 0:
        return False
    
    # Check history
    history = get_user_generations_history(user_id, limit=1)
    if history:
        return False
    
    # Check payments
    payments = get_user_payments(user_id)
    if payments:
        return False
    
    return True


async def send_broadcast(context: ContextTypes.DEFAULT_TYPE, broadcast_id: int, user_ids: list, message_text: str = None, message_photo=None):
    """Send broadcast message to all users."""
    sent = 0
    delivered = 0
    failed = 0
    
    for user_id in user_ids:
        try:
            # Skip blocked users
            if is_user_blocked(user_id):
                continue
            
            # Send message
            if message_photo:
                # Send photo with caption
                try:
                    await context.bot.send_photo(
                        chat_id=user_id,
                        photo=message_photo.file_id,
                        caption=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast photo to {user_id}: {e}")
                    failed += 1
            else:
                # Send text message
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast message to {user_id}: {e}")
                    failed += 1
            
            sent += 1
            
            # Small delay to avoid rate limiting
            await asyncio.sleep(0.05)  # 50ms delay between messages
            
        except Exception as e:
            logger.error(f"Error in broadcast to {user_id}: {e}")
            failed += 1
            sent += 1
    
    # Update broadcast statistics
    broadcasts = get_broadcasts()
    if str(broadcast_id) in broadcasts:
        broadcasts[str(broadcast_id)]['sent'] = sent
        broadcasts[str(broadcast_id)]['delivered'] = delivered
        broadcasts[str(broadcast_id)]['failed'] = failed
        save_json_file(BROADCASTS_FILE, broadcasts)
        
        # Notify admin
        try:
            admin_id = ADMIN_ID
            await context.bot.send_message(
                chat_id=admin_id,
                text=(
                    f"‚úÖ <b>–†–∞—Å—Å—ã–ª–∫–∞ #{broadcast_id} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                    f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                    f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}\n"
                    f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered}\n"
                    f"‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    f"üìà <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å:</b> {(delivered/sent*100) if sent > 0 else 0:.1f}%"
                ),
                parse_mode='HTML'
            )
        except Exception as e:
            logger.error(f"Error notifying admin about broadcast: {e}")


def is_user_blocked(user_id: int) -> bool:
    """Check if user is blocked."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    return blocked.get(str(user_id), False)


def block_user(user_id: int):
    """Block a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    blocked[str(user_id)] = True
    save_json_file(BLOCKED_USERS_FILE, blocked)


def unblock_user(user_id: int):
    """Unblock a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    if str(user_id) in blocked:
        del blocked[str(user_id)]
        save_json_file(BLOCKED_USERS_FILE, blocked)


def check_duplicate_payment(screenshot_file_id: str) -> bool:
    """Check if this screenshot was already used for payment."""
    if not screenshot_file_id:
        return False
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if payment.get('screenshot_file_id') == screenshot_file_id:
            return True
    return False


def add_payment(user_id: int, amount: float, screenshot_file_id: str = None) -> dict:
    """Add a payment record. Returns payment dict with id, timestamp, etc."""
    # Ensure payments file exists
    if not os.path.exists(PAYMENTS_FILE):
        try:
            with open(PAYMENTS_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
            logger.info(f"Created payments file {PAYMENTS_FILE}")
        except Exception as e:
            logger.error(f"Error creating payments file {PAYMENTS_FILE}: {e}")
    
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_id = len(payments) + 1
    import time
    payment = {
        "id": payment_id,
        "user_id": user_id,
        "amount": amount,
        "timestamp": time.time(),
        "screenshot_file_id": screenshot_file_id,
        "status": "completed"  # Auto-completed
    }
    payments[str(payment_id)] = payment
    
    # Force immediate save for payments (critical data)
    if PAYMENTS_FILE in _last_save_time:
        del _last_save_time[PAYMENTS_FILE]
    save_json_file(PAYMENTS_FILE, payments, use_cache=True)
    
    # Verify payment was saved
    if os.path.exists(PAYMENTS_FILE):
        verify_payments = load_json_file(PAYMENTS_FILE, {})
        if str(payment_id) in verify_payments:
            logger.info(f"‚úÖ Saved payment: user_id={user_id}, amount={amount}, payment_id={payment_id}")
        else:
            logger.error(f"‚ùå Payment saved but not found in file! payment_id={payment_id}")
    else:
        logger.error(f"‚ùå Failed to save payment file: {PAYMENTS_FILE} does not exist after save!")
    
    # Auto-add balance
    add_user_balance(user_id, amount)
    
    return payment


def get_all_payments() -> list:
    """Get all payments sorted by timestamp (newest first)."""
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_list = list(payments.values())
    payment_list.sort(key=lambda x: x.get("timestamp", 0), reverse=True)
    return payment_list


def get_user_payments(user_id: int) -> list:
    """Get all payments for a specific user."""
    all_payments = get_all_payments()
    return [p for p in all_payments if p.get("user_id") == user_id]


def get_payment_stats() -> dict:
    """Get payment statistics."""
    payments = get_all_payments()
    total_amount = sum(p.get("amount", 0) for p in payments)
    total_count = len(payments)
    return {
        "total_amount": total_amount,
        "total_count": total_count,
        "payments": payments
    }


def get_extended_admin_stats() -> dict:
    """Get extended statistics for admin panel."""
    import time
    from datetime import datetime, timedelta
    
    now = time.time()
    today_start = int((datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)).timestamp())
    week_start = int((datetime.now() - timedelta(days=7)).timestamp())
    month_start = int((datetime.now() - timedelta(days=30)).timestamp())
    
    # Get all users
    all_users = get_all_users()
    total_users = len(all_users)
    
    # Get active users (users with activity in period)
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    active_today = set()
    active_week = set()
    active_month = set()
    
    for user_key, user_history in history.items():
        for gen in user_history:
            timestamp = gen.get('timestamp', 0)
            user_id = int(user_key) if user_key.isdigit() else None
            if user_id:
                if timestamp >= today_start:
                    active_today.add(user_id)
                if timestamp >= week_start:
                    active_week.add(user_id)
                if timestamp >= month_start:
                    active_month.add(user_id)
    
    # Get top models by usage
    model_usage = {}
    for user_key, user_history in history.items():
        for gen in user_history:
            model_id = gen.get('model_id', '')
            if model_id:
                model_usage[model_id] = model_usage.get(model_id, 0) + 1
    
    # Sort models by usage and get top 5
    top_models = sorted(model_usage.items(), key=lambda x: x[1], reverse=True)[:5]
    top_models_list = []
    for model_id, count in top_models:
        model_info = get_model_by_id(model_id)
        model_name = model_info.get('name', model_id) if model_info else model_id
        top_models_list.append({'name': model_name, 'id': model_id, 'count': count})
    
    # Get payment statistics
    payment_stats = get_payment_stats()
    total_revenue = payment_stats.get('total_amount', 0)
    total_payments = payment_stats.get('total_count', 0)
    
    # Calculate conversion rate (users who made at least one payment)
    users_with_payments = set()
    for payment in payment_stats.get('payments', []):
        user_id = payment.get('user_id')
        if user_id:
            users_with_payments.add(user_id)
    
    conversion_rate = (len(users_with_payments) / total_users * 100) if total_users > 0 else 0
    
    # Calculate average check
    avg_check = (total_revenue / total_payments) if total_payments > 0 else 0
    
    # Get revenue for periods
    payments = payment_stats.get('payments', [])
    revenue_today = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= today_start)
    revenue_week = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= week_start)
    revenue_month = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= month_start)
    
    # Total generations count
    total_generations = sum(len(user_history) for user_history in history.values())
    
    return {
        'total_users': total_users,
        'active_today': len(active_today),
        'active_week': len(active_week),
        'active_month': len(active_month),
        'top_models': top_models_list,
        'total_revenue': total_revenue,
        'revenue_today': revenue_today,
        'revenue_week': revenue_week,
        'revenue_month': revenue_month,
        'total_payments': total_payments,
        'conversion_rate': conversion_rate,
        'avg_check': avg_check,
        'total_generations': total_generations
    }


def get_payment_details() -> str:
    """Get payment details from .env (–°–ë–ü - –°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)."""
    # –£–±—Ä–∞–Ω–æ: load_dotenv()
    # –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard –∏–ª–∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV)
    # –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    
    # Get from environment (works both for .env and Render Environment Variables)
    card_holder = os.getenv('PAYMENT_CARD_HOLDER', '').strip()
    phone = os.getenv('PAYMENT_PHONE', '').strip()
    bank = os.getenv('PAYMENT_BANK', '').strip()
    
    # Enhanced debug logging for troubleshooting
    logger.debug(f"Loading payment details - PAYMENT_PHONE: {'SET' if phone else 'NOT SET'}, PAYMENT_BANK: {'SET' if bank else 'NOT SET'}, PAYMENT_CARD_HOLDER: {'SET' if card_holder else 'NOT SET'}")
    
    # Check if any payment details are missing
    if not phone and not bank and not card_holder:
        logger.warning("Payment details not found in environment variables!")
        logger.warning("Make sure these environment variables are set in Render dashboard:")
        logger.warning("  - PAYMENT_PHONE")
        logger.warning("  - PAYMENT_BANK")
        logger.warning("  - PAYMENT_CARD_HOLDER")
        # Also log all environment variables that start with PAYMENT_ for debugging
        payment_env_vars = {k: v for k, v in os.environ.items() if k.startswith('PAYMENT_')}
        logger.debug(f"All PAYMENT_* environment variables: {payment_env_vars}")
    
    details = "üí≥ <b>–†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã (–°–ë–ü):</b>\n\n"
    
    if phone:
        details += f"üì± <b>–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:</b> <code>{phone}</code>\n"
    if bank:
        details += f"üè¶ <b>–ë–∞–Ω–∫:</b> {bank}\n"
    if card_holder:
        details += f"üë§ <b>–ü–æ–ª—É—á–∞—Ç–µ–ª—å:</b> {card_holder}\n"
    
    if not phone and not bank and not card_holder:
        details += "‚ö†Ô∏è <b>–í–ù–ò–ú–ê–ù–ò–ï: –†–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã!</b>\n\n"
        details += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è:\n"
        details += "‚Ä¢ <code>PAYMENT_PHONE</code> - –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è –°–ë–ü\n"
        details += "‚Ä¢ <code>PAYMENT_BANK</code> - –Ω–∞–∑–≤–∞–Ω–∏–µ –±–∞–Ω–∫–∞\n"
        details += "‚Ä¢ <code>PAYMENT_CARD_HOLDER</code> - –∏–º—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è\n\n"
        details += "–ù–∞ Render: –¥–æ–±–∞–≤—å—Ç–µ –∏—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ Environment Variables\n"
        details += "–õ–æ–∫–∞–ª—å–Ω–æ: –¥–æ–±–∞–≤—å—Ç–µ –≤ —Ñ–∞–π–ª .env\n\n"
    
    details += "\n‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ —ç—Ç–æ—Ç —á–∞—Ç.\n\n"
    details += "‚úÖ <b>–ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</b> –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞."
    
    return details


def get_support_contact() -> str:
    """Get support contact information from .env (only Telegram)."""
    # –£–±—Ä–∞–Ω–æ: load_dotenv()
    # –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard –∏–ª–∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV)
    # –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    
    support_telegram = os.getenv('SUPPORT_TELEGRAM', '').strip()
    support_text = os.getenv('SUPPORT_TEXT', '').strip()
    
    # Enhanced debug logging for troubleshooting
    logger.debug(f"Loading support contact - SUPPORT_TELEGRAM: {'SET' if support_telegram else 'NOT SET'}, SUPPORT_TEXT: {'SET' if support_text else 'NOT SET'}")
    
    contact = "üÜò <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>\n\n"
    
    if support_text:
        contact += f"{support_text}\n\n"
    else:
        contact += "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏:\n\n"
    
    if support_telegram:
        telegram_username = support_telegram.replace('@', '')
        contact += f"üí¨ <b>Telegram:</b> @{telegram_username}\n"
    else:
        logger.warning("Support contact not found in environment variables!")
        logger.warning("Make sure these environment variables are set in Render dashboard:")
        logger.warning("  - SUPPORT_TELEGRAM")
        logger.warning("  - SUPPORT_TEXT (optional)")
        # Also log all environment variables that start with SUPPORT_ for debugging
        support_env_vars = {k: v for k, v in os.environ.items() if k.startswith('SUPPORT_')}
        logger.debug(f"All SUPPORT_* environment variables: {support_env_vars}")
        contact += "‚ö†Ô∏è <b>–ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.</b>\n\n"
        contact += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å SUPPORT_TELEGRAM –≤ —Ñ–∞–π–ª–µ .env –∏–ª–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Render (Environment Variables).\n\n"
        contact += "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
    
    return contact


async def analyze_payment_screenshot(image_data: bytes, expected_amount: float, expected_phone: str = None) -> dict:
    """
    Analyze payment screenshot using OCR.
    Returns dict with 'valid', 'amount_found', 'phone_found', 'message'.
    """
    if not OCR_AVAILABLE or not PIL_AVAILABLE:
        # If OCR not available, allow payment without check
        return {
            'valid': True,  # Allow without OCR check
            'amount_found': False,
            'phone_found': False,
            'message': '‚ÑπÔ∏è OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
        }
    
    try:
        # Convert bytes to PIL Image
        image = Image.open(BytesIO(image_data))
        
        # Use OCR to extract text
        try:
            extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
        except Exception as e:
            logger.error(f"OCR error: {e}")
            # Try with English only if Russian fails
            try:
                extracted_text = pytesseract.image_to_string(image, lang='eng')
            except:
                extracted_text = pytesseract.image_to_string(image)
        
        extracted_text = extracted_text.lower()
        logger.info(f"Extracted text from screenshot (first 200 chars): {extracted_text[:200]}")
        
        # Check for payment-related keywords (Russian and English)
        payment_keywords = [
            '–ø–µ—Ä–µ–≤–æ–¥', '–æ–ø–ª–∞—Ç–∞', '–ø–ª–∞—Ç–µ–∂', '—Å–ø–±', '—Å–±–ø', 'payment', 'transfer',
            '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', '—É—Å–ø–µ—à–Ω–æ', 'success', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å:',
            '—Å—É–º–º–∞', '–∏—Ç–æ–≥–æ', 'amount', 'total', '—Å—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞', '–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ',
            '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '—Å—Ç–∞—Ç—É—Å', 'status', '–∫–æ–º–∏—Å—Å–∏—è', 'commission'
        ]
        
        has_payment_keywords = any(keyword in extracted_text for keyword in payment_keywords)
        
        # Extract amount from text (look for numbers with ‚ÇΩ, —Ä—É–±, –†, or near payment keywords)
        amount_patterns = [
            # With currency symbols
            r'(\d+[.,]\d+)\s*[‚ÇΩ—Ä—É–±–†]',
            r'(\d+)\s*[‚ÇΩ—Ä—É–±–†]',
            r'[‚ÇΩ—Ä—É–±–†]\s*(\d+[.,]\d+)',
            r'[‚ÇΩ—Ä—É–±–†]\s*(\d+)',
            # Near payment keywords
            r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]+(\d+[.,]?\d*)',
            r'(\d+[.,]?\d*)\s*(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)',
            # Standalone numbers near payment context (more flexible)
            r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]*\s*(\d+[.,]?\d*)\s*[‚ÇΩ—Ä—É–±–†]?',
            # Numbers that might be misrecognized (B instead of –†, 2 instead of –†)
            r'(\d+)\s*[B2]',  # 500 B or 500 2 might be 500 –†
            r'(\d+)\s*[‚ÇΩ—Ä—É–±–†B2]',
            # Just numbers in context of payment (last resort)
            r'\b(\d{2,6})\b',  # 2-6 digit numbers (likely amounts)
        ]
        
        amount_found = False
        found_amount = None
        all_found_amounts = []
        
        for pattern in amount_patterns:
            matches = re.findall(pattern, extracted_text, re.IGNORECASE)
            if matches:
                try:
                    amounts = [float(m.replace(',', '.')) for m in matches]
                    all_found_amounts.extend(amounts)
                except:
                    continue
        
        if all_found_amounts:
            # Remove duplicates and sort
            unique_amounts = sorted(set(all_found_amounts), reverse=True)
            
            # Try to find amount that matches expected (with tolerance)
            for amt in unique_amounts:
                # Check if amount matches (allow small difference for rounding)
                diff = abs(amt - expected_amount)
                diff_percent = diff / expected_amount if expected_amount > 0 else 1
                
                # Match if difference is less than 1 ruble or less than 10%
                if diff < 1.0 or diff_percent < 0.1:
                    amount_found = True
                    found_amount = amt
                    break
            
            # If no exact match, use the largest reasonable amount
            if not amount_found and unique_amounts:
                # Filter amounts that are reasonable (between 10 and 100000)
                reasonable_amounts = [a for a in unique_amounts if 10 <= a <= 100000]
                if reasonable_amounts:
                    # Check if any reasonable amount is close to expected
                    for amt in reasonable_amounts:
                        diff = abs(amt - expected_amount)
                        if diff < 10.0:  # Allow up to 10 rubles difference
                            amount_found = True
                            found_amount = amt
                            break
        
        # Extract phone number from text
        phone_found = False
        if expected_phone:
            # Normalize phone (remove +, spaces, dashes)
            normalized_expected = re.sub(r'[+\s\-()]', '', expected_phone)
            
            # Look for phone patterns
            phone_patterns = [
                r'\+?7\d{10}',
                r'\+?7\s?\d{3}\s?\d{3}\s?\d{2}\s?\d{2}',
                r'\d{11}',
                r'\+?\d{1}\s?\d{3}\s?\d{3}\s?\d{2}\s?\d{2}',
            ]
            
            for pattern in phone_patterns:
                matches = re.findall(pattern, extracted_text)
                for match in matches:
                    normalized_match = re.sub(r'[+\s\-()]', '', match)
                    if normalized_match == normalized_expected or normalized_match.endswith(normalized_expected[-10:]):
                        phone_found = True
                        break
                if phone_found:
                    break
        
        # Improved validation with scoring system
        score = 0
        max_score = 4
        
        # Amount match: +2 points (most important)
        if amount_found:
            score += 2
        elif all_found_amounts:
            # If amount found but doesn't match exactly, check if close
            reasonable_amounts = [a for a in all_found_amounts if 10 <= a <= 100000]
            if reasonable_amounts:
                # Check if any amount is within 20% of expected
                for amt in reasonable_amounts:
                    diff_percent = abs(amt - expected_amount) / expected_amount if expected_amount > 0 else 1
                    if diff_percent <= 0.2:  # Within 20%
                        score += 1  # Partial credit
                        break
        
        # Phone match: +1 point (if expected)
        if expected_phone and phone_found:
            score += 1
        
        # Payment keywords: +1 point (required for security)
        if has_payment_keywords:
            score += 1
        
        # Additional checks for better validation
        # Check for duplicate screenshots (by file_id if available)
        # This will be checked in the payment handler
        
        # Validation: Need at least 2.5 points (flexible but secure)
        # This means: (amount + keywords) OR (amount + phone) OR (amount perfect match)
        valid = score >= 2.5
        
        # Additional security: if no amount found at all, reject (unless OCR failed)
        if not all_found_amounts and not has_payment_keywords:
            valid = False
        
        # Additional check: if amount is found but way off, be more strict
        if amount_found and found_amount:
            diff_percent = abs(found_amount - expected_amount) / expected_amount if expected_amount > 0 else 1
            # If difference is more than 30%, require additional verification
            if diff_percent > 0.3:
                # Require both phone and keywords if amount is way off
                if not (phone_found and has_payment_keywords):
                    valid = False
        
        message_parts = []
        if amount_found:
            message_parts.append(f"‚úÖ –°—É–º–º–∞ –Ω–∞–π–¥–µ–Ω–∞: {found_amount:.2f} ‚ÇΩ")
        else:
            message_parts.append(f"‚ö†Ô∏è –°—É–º–º–∞ {expected_amount:.2f} ‚ÇΩ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–∫—Ä–∏–Ω—à–æ—Ç–µ")
        
        if expected_phone:
            if phone_found:
                message_parts.append(f"‚úÖ –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞–π–¥–µ–Ω")
            else:
                message_parts.append(f"‚ö†Ô∏è –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        if has_payment_keywords:
            message_parts.append("‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞")
        else:
            message_parts.append("‚ö†Ô∏è –ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã")
        
        return {
            'valid': valid,
            'amount_found': amount_found,
            'phone_found': phone_found if expected_phone else None,
            'has_payment_keywords': has_payment_keywords,
            'found_amount': found_amount,
            'message': '\n'.join(message_parts)
        }
        
    except Exception as e:
        logger.error(f"Error analyzing payment screenshot: {e}", exc_info=True)
        return {
            'valid': True,  # Allow if analysis fails (fallback)
            'amount_found': False,
            'phone_found': False,
            'message': f'‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é.'
        }


# ==================== End Payment System Functions ====================


async def upload_image_to_hosting(image_data: bytes, filename: str = "image.jpg") -> str:
    """
    Upload image to public hosting and return public URL.
    
    üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ü–†–ê–í–ò–õ–û: –≠–¢–ê –§–£–ù–ö–¶–ò–Ø –î–û–õ–ñ–ù–ê –ë–´–¢–¨ –ó–ê–ú–ï–ù–ï–ù–ê –ù–ê KIE AI FILE UPLOAD API!
    
    –í–°–ï —Ñ–∞–π–ª—ã (–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –≤–∏–¥–µ–æ, –∞—É–¥–∏–æ) –î–û–õ–ñ–ù–´ –∑–∞–≥—Ä—É–∂–∞—Ç—å—Å—è —á–µ—Ä–µ–∑ KIE AI File Upload API:
    - Base URL: https://kieai.redpandaai.co
    - Endpoints:
      * POST /api/file-stream-upload - –¥–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
      * POST /api/file-base64-upload - –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ (‚â§10MB)
      * POST /api/file-url-upload - –¥–ª—è —É–¥–∞–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    - Authentication: Authorization: Bearer YOUR_API_KEY
    - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: https://docs.kie.ai/file-upload-api
    
    ‚ö†Ô∏è –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–Ω–µ—à–Ω–∏–µ —Ö–æ—Å—Ç–∏–Ω–≥–∏ (0x0.st, catbox.moe, transfer.sh)!
    ‚ö†Ô∏è –§–∞–π–ª—ã –≤ KIE AI File Upload API –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ 3 –¥–Ω—è!
    
    TODO: –ó–∞–º–µ–Ω–∏—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ KIE AI File Upload API
    """
    if not image_data or len(image_data) == 0:
        logger.error("Empty image data provided")
        return None
    
    # üî¥ –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤–Ω–µ—à–Ω–∏–µ —Ö–æ—Å—Ç–∏–Ω–≥–∏
    # TODO: –ó–ê–ú–ï–ù–ò–¢–¨ –ù–ê KIE AI FILE UPLOAD API (https://kieai.redpandaai.co/api/file-stream-upload)
    # Try multiple hosting services
    hosting_services = [
        # 0x0.st - simple file hosting (most reliable)
        {
            'url': 'https://0x0.st',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'file'
        },
        # catbox.moe - image hosting
        {
            'url': 'https://catbox.moe/user/api.php',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'fileToUpload',
            'extra_params': {'reqtype': 'fileupload'}
        },
        # transfer.sh - file sharing
        {
            'url': f'https://transfer.sh/{filename}',
            'method': 'PUT',
            'data_type': 'raw',
            'field_name': None
        }
    ]
    
    for service in hosting_services:
        try:
            logger.info(f"Trying to upload to {service['url']}")
            session = await get_http_client()
            if service['data_type'] == 'form':
                data = aiohttp.FormData()
                # Add extra params if needed
                if 'extra_params' in service:
                    for key, value in service['extra_params'].items():
                        data.add_field(key, value)
                
                # Add file
                data.add_field(
                    service['field_name'],
                    BytesIO(image_data),
                    filename=filename,
                    content_type='image/jpeg'
                )
                
                async with session.post(service['url'], data=data, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                    status = resp.status
                    text = await resp.text()
                    logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                    
                    if status in [200, 201]:
                        text = text.strip()
                        # For catbox.moe, response is direct URL
                        if 'catbox.moe' in service['url']:
                            if text.startswith('http'):
                                return text
                        # For 0x0.st, response is direct URL
                        elif text.startswith('http'):
                            return text
                    else:
                        logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
            else:  # raw
                    headers = {'Content-Type': 'image/jpeg', 'Max-Downloads': '1', 'Max-Days': '7'}
                    async with session.put(service['url'], data=image_data, headers=headers, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                        status = resp.status
                        text = await resp.text()
                        logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                        
                        if status in [200, 201]:
                            text = text.strip()
                            if text.startswith('http'):
                                return text
                        else:
                            logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
        except asyncio.TimeoutError:
            logger.warning(f"Timeout uploading to {service['url']}")
            continue
        except Exception as e:
            logger.error(f"Exception uploading to {service['url']}: {e}", exc_info=True)
            continue
    
    # If all services fail, return None
    logger.error("All image hosting services failed. Image size: {} bytes".format(len(image_data)))
    return None


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a marketing welcome message with model selection."""
    try:
        logger.info(f"üî• /start command received from user_id={update.effective_user.id if update.effective_user else 'None'}")
        
        user = update.effective_user
        if not user:
            logger.error("‚ùå No effective_user in update")
            return
        
        user_id = user.id
        
        # Check if language is set, if not - show language selection
        if not has_user_language_set(user_id):
            keyboard = [
                [
                    InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="language_select:ru"),
                    InlineKeyboardButton("üá¨üáß English", callback_data="language_select:en")
                ]
            ]
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –µ–≥–æ Telegram —è–∑—ã–∫—É –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –∫–∞–∫ –±–æ–ª–µ–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π
            user_lang_code = update.effective_user.language_code or 'en'
            # –ï—Å–ª–∏ —è–∑—ã–∫ –Ω–µ —Ä—É—Å—Å–∫–∏–π, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º
            display_lang = 'ru' if user_lang_code.startswith('ru') else 'en'
            
            await update.message.reply_html(
                t('select_language', lang=display_lang),
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            logger.info(f"‚úÖ Language selection shown for user_id={user_id}")
            return
        
        # Check if user is admin
        is_admin = (user_id == ADMIN_ID)
        
        # Get user language
        user_lang = get_user_language(user_id)
        
        # Get generation types and models count
        generation_types = get_generation_types()
        total_models = len(get_models_sync())
        
        # Both admin and regular users see the same menu, but admin gets additional "Admin Panel" button
        # Common menu for both admin and regular users
        remaining_free = get_user_free_generations_remaining(user_id)
        is_new = is_new_user(user_id)
        referral_link = get_user_referral_link(user_id)
        referrals_count = len(get_user_referrals(user_id))
        online_count = get_fake_online_count()
        
        # Use translations
        if is_new:
            welcome_text = t('welcome_new', lang=user_lang,
                            name=user.mention_html(),
                            free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                            models=total_models,
                            types=len(generation_types),
                            online=online_count,
                            ref_bonus=REFERRAL_BONUS_GENERATIONS,
                            ref_link=referral_link)
        else:
            referral_bonus_text = ""
            if referrals_count > 0:
                referral_bonus_text = t('msg_referral_bonus', lang=user_lang,
                                        count=referrals_count,
                                        bonus=referrals_count * REFERRAL_BONUS_GENERATIONS)
            
            welcome_text = t('welcome_returning', lang=user_lang,
                            name=user.mention_html(),
                            online=online_count,
                            free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                            models=total_models,
                            types=len(generation_types))
            welcome_text += referral_bonus_text
            
            # Add full functionality text using translations
            welcome_text += t('msg_full_functionality', lang=user_lang,
                            remaining=remaining_free,
                            total=FREE_GENERATIONS_PER_DAY,
                            ref_bonus=REFERRAL_BONUS_GENERATIONS,
                            ref_link=referral_link,
                            models=total_models,
                            types=len(generation_types))
        
        # Common keyboard for both admin and regular users
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
        keyboard = await build_main_menu_keyboard(user_id, user_lang, is_new)
        
        await update.message.reply_html(
            welcome_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        logger.info(f"‚úÖ /start command completed successfully for user_id={user_id}")
        
    except Exception as e:
        logger.error(f"‚ùå‚ùå‚ùå ERROR in /start command: {e}", exc_info=True)
        logger.error(f"   User ID: {update.effective_user.id if update.effective_user else 'None'}")
        logger.error(f"   Error type: {type(e).__name__}")
        
        # Try to send error message to user
        try:
            user_lang = 'ru'
            if update.effective_user:
                try:
                    user_lang = get_user_language(update.effective_user.id) if update.effective_user else 'ru'
                except:
                    pass
            
            error_msg = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            await update.message.reply_text(error_msg)
        except Exception as send_error:
            logger.error(f"‚ùå Failed to send error message to user: {send_error}", exc_info=True)
        
        logger.info(f"‚úÖ /start command completed successfully for user_id={user_id}")
        
    except Exception as e:
        logger.error(f"‚ùå‚ùå‚ùå ERROR in /start command: {e}", exc_info=True)
        logger.error(f"   User ID: {update.effective_user.id if update.effective_user else 'None'}")
        logger.error(f"   Error type: {type(e).__name__}")
        
        # Try to send error message to user
        try:
            user_lang = 'ru'
            if update.effective_user:
                try:
                    user_lang = get_user_language(update.effective_user.id) if update.effective_user else 'ru'
                except:
                    pass
            
            error_msg = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            await update.message.reply_text(error_msg)
        except Exception as send_error:
            logger.error(f"‚ùå Failed to send error message to user: {send_error}", exc_info=True)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a message when the command /help is issued."""
    await update.message.reply_text(
        'üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n\n'
        '/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n'
        '/models - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π\n'
        '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é\n'
        '/search [–∑–∞–ø—Ä–æ—Å] - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
        '/ask [–≤–æ–ø—Ä–æ—Å] - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å\n'
        '/add [–∑–Ω–∞–Ω–∏–µ] - –î–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ –≤ –±–∞–∑—É\n\n'
        'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
        '1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /models —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏\n'
        '2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /balance —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /generate —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
        '4. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞\n'
        '5. –í–≤–µ–¥–∏—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n'
        '6. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!',
        parse_mode='HTML'
    )


async def list_models(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """List available models from static menu."""
    user_id = update.effective_user.id
    
    # Get models grouped by category
    categories = get_categories_from_registry()
    
    # Create category selection keyboard
    keyboard = []
    for category in categories:
        models_in_category = get_models_by_category_from_registry(category)
        emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
        keyboard.append([InlineKeyboardButton(
            f"{emoji} {category} ({len(models_in_category)})",
            callback_data=f"category:{category}"
        )])
    
    user_lang = get_user_language(update.effective_user.id)
    keyboard.append([InlineKeyboardButton(t('btn_all_models_short', lang=user_lang), callback_data="all_models")])
    keyboard.append([
        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
    ])
    keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    models_text = "üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n\n"
    models_text += "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤—Å–µ –º–æ–¥–µ–ª–∏:\n\n"
    for category in categories:
        models_in_category = get_models_by_category_from_registry(category)
        models_text += f"<b>{category}</b>: {len(models_in_category)} –º–æ–¥–µ–ª–µ–π\n"
    
    await update.message.reply_text(
        models_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def start_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the generation process."""
    global kie
    user_id = update.effective_user.id
    
    # Check if KIE API is configured (initialize if needed)
    if kie is None:
        kie = get_client()
    if not kie.api_key:
        await update.message.reply_text(
            '‚ùå API –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£–∫–∞–∂–∏—Ç–µ API –∫–ª—é—á –≤ —Ñ–∞–π–ª–µ .env'
        )
        return
    
    await update.message.reply_text(
        'üöÄ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é!\n\n'
        '–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞:',
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üìã –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏", callback_data="show_models")
        ]])
    )
    
    return SELECTING_MODEL


async def show_admin_generation(query, context, gen: dict, current_index: int, total_count: int):
    """Show admin generation with navigation."""
    try:
        from datetime import datetime
        
        gen_id = gen.get('id', 0)
        user_id = gen.get('user_id', 0)
        model_id = gen.get('model_id', 'Unknown')
        model_name = gen.get('model_name', model_id)
        timestamp = gen.get('timestamp', 0)
        price = gen.get('price', 0)
        is_free = gen.get('is_free', False)
        result_urls = gen.get('result_urls', [])
        params = gen.get('params', {})
        
        if timestamp:
            dt = datetime.fromtimestamp(timestamp)
            date_str = dt.strftime("%d.%m.%Y %H:%M")
        else:
            date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        user_link = f"tg://user?id={user_id}"
        user_lang = get_user_language(query.from_user.id)
        
        if user_lang == 'ru':
            gen_text = (
                f"üìö <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen_id}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id}</a>\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
            )
            
            if params:
                params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in list(params.items())[:5]])
                gen_text += f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
            
            gen_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            gen_text += f"üìÑ {current_index + 1} –∏–∑ {total_count}"
        else:
            gen_text = (
                f"üìö <b>Generation #{gen_id}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ <a href=\"{user_link}\">User {user_id}</a>\n"
                f"üìÖ <b>Date:</b> {date_str}\n"
                f"ü§ñ <b>Model:</b> {model_name}\n"
                f"üí∞ <b>Cost:</b> {'üéÅ Free' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                f"üì¶ <b>Results:</b> {len(result_urls)}\n\n"
            )
            
            if params:
                params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in list(params.items())[:5]])
                gen_text += f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
            
            gen_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            gen_text += f"üìÑ {current_index + 1} of {total_count}"
        
        keyboard = []
        
        # Navigation buttons
        if total_count > 1:
            keyboard.append([
                InlineKeyboardButton(t('btn_previous', lang=user_lang), callback_data=f"admin_gen_nav:prev"),
                InlineKeyboardButton(t('btn_next', lang=user_lang), callback_data=f"admin_gen_nav:next")
            ])
        
        # View result button
        if result_urls:
            keyboard.append([
                InlineKeyboardButton(t('btn_view_result', lang=user_lang), callback_data=f"admin_gen_view:{current_index}")
            ])
        
        # Back button
        keyboard.append([
            InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")
        ])
        
        await query.edit_message_text(
            gen_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML',
            disable_web_page_preview=False
        )
    except Exception as e:
        logger.error(f"Error showing admin generation: {e}", exc_info=True)
        user_lang = get_user_language(query.from_user.id)
        await query.answer(t('error_display_generation', lang=user_lang), show_alert=True)


async def show_payment_screenshot(query, payment: dict, current_index: int, total_count: int):
    """Show payment screenshot with navigation."""
    try:
        import datetime
        
        payment_id = payment.get('id', 0)
        user_id = payment.get('user_id', 0)
        amount = payment.get('amount', 0)
        timestamp = payment.get('timestamp', 0)
        screenshot_file_id = payment.get('screenshot_file_id')
        
        if not screenshot_file_id:
            await query.edit_message_text("‚ùå –°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —ç—Ç–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞.")
            return
        
        # Format payment info
        amount_str = f"{amount:.2f}".rstrip('0').rstrip('.')
        if timestamp:
            dt = datetime.datetime.fromtimestamp(timestamp)
            date_str = dt.strftime("%d.%m.%Y %H:%M")
        else:
            date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        user_link = f"tg://user?id={user_id}"
        caption = (
            f"üì∏ <b>–°–∫—Ä–∏–Ω—à–æ—Ç –ø–ª–∞—Ç–µ–∂–∞ #{payment_id}</b>\n\n"
            f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id}</a>\n"
            f"üíµ –°—É–º–º–∞: {amount_str} ‚ÇΩ\n"
            f"üìÖ –î–∞—Ç–∞: {date_str}\n\n"
            f"üìÑ {current_index + 1} –∏–∑ {total_count}"
        )
        
        # Create navigation keyboard
        keyboard = []
        nav_row = []
        
        if total_count > 1:
            if current_index > 0:
                nav_row.append(InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∏–π", callback_data="payment_screenshot_nav:prev"))
            if current_index < total_count - 1:
                nav_row.append(InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∏–π ‚ñ∂Ô∏è", callback_data="payment_screenshot_nav:next"))
            
            if nav_row:
                keyboard.append(nav_row)
        
        keyboard.append([InlineKeyboardButton("üìä –ù–∞–∑–∞–¥ –∫ –ø–ª–∞—Ç–µ–∂–∞–º", callback_data="admin_payments_back")])
        
        reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
        
        # Send photo with caption
        try:
            # Edit original message first to show we're loading
            await query.edit_message_text(
                f"üì∏ <b>–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞...</b>\n\n"
                f"–ü–ª–∞—Ç–µ–∂ #{payment_id}",
                parse_mode='HTML'
            )
            
            # Send photo as new message
            await query.message.reply_photo(
                photo=screenshot_file_id,
                caption=caption,
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        except Exception as e:
            logger.error(f"Error sending payment screenshot: {e}")
            await query.edit_message_text(
                f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞</b>\n\n"
                f"–ü–ª–∞—Ç–µ–∂ #{payment_id}\n"
                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}\n"
                f"–°—É–º–º–∞: {amount_str} ‚ÇΩ\n"
                f"–î–∞—Ç–∞: {date_str}\n\n"
                f"‚ö†Ô∏è –°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–≤–æ–∑–º–æ–∂–Ω–æ, —Ñ–∞–π–ª —É–¥–∞–ª–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Error in show_payment_screenshot: {e}", exc_info=True)
        try:
            await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞.")
        except:
            pass


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button callbacks. CRITICAL: Always calls query.answer() to prevent button hanging."""
    import time
    start_time = time.time()
    query = None
    user_id = None
    data = None
    user_lang = 'ru'
    
    # ==================== NO-SILENCE GUARD: Track outgoing actions ====================
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
    guard = get_no_silence_guard()
    update_id = update.update_id
    # ==================== END NO-SILENCE GUARD ====================
    
    # üî• MAXIMUM LOGGING: Log entry point
    try:
        query = update.callback_query
        user_id = query.from_user.id if query and query.from_user else None
        data = query.data if query else None
        logger.info(f"üî•üî•üî• BUTTON_CALLBACK ENTRY: user_id={user_id}, data={data}, query_id={query.id if query else 'None'}, message_id={query.message.message_id if query and query.message else 'None'}")
    except Exception as e:
        logger.error(f"‚ùå‚ùå‚ùå ERROR in button_callback entry logging: {e}", exc_info=True)
    
    # CRITICAL: Always answer callback query to prevent button hanging
    # This must be done FIRST, before any other operations
    try:
        query = update.callback_query
        if not query:
            logger.error("No callback_query in update")
            return ConversationHandler.END
        
        user_id = update.effective_user.id if update.effective_user else None
        data = query.data if query else None
        
        # ALWAYS answer callback immediately to prevent button hanging
        # This is critical - if we don't answer, button will hang
        try:
            await query.answer()
            # NO-SILENCE GUARD: Track outgoing action
            track_outgoing_action(update_id)
        except Exception as answer_error:
            logger.warning(f"Could not answer callback query: {answer_error}")
            # Continue anyway - better to process than to fail completely
        
        logger.info(f"Button callback received: user_id={user_id}, data='{data}'")
        
        if not data:
            logger.error("No data in callback_query")
            try:
                user_lang = get_user_language(user_id) if user_id else 'ru'
                await query.answer(t('error_no_data', lang=user_lang), show_alert=True)
            except:
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ –∫–Ω–æ–ø–∫–µ", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        # Get user language early for error messages
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
        except:
            user_lang = 'ru'
            
    except Exception as e:
        logger.error(f"Error in button_callback setup: {e}", exc_info=True)
        # Try to answer anyway if we have query
        if query:
            try:
                await query.answer("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–Ω–æ–ø–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start", show_alert=True)
            except:
                pass
        return ConversationHandler.END
    
    # Wrap all callback handling in try-except for error handling
    try:
        # Initialize common variables that might be used in multiple handlers
        # This prevents UnboundLocalError if variable is assigned in one branch but used in another
        categories = None
        total_models = None
        tutorial_text = None
        help_text = None
        referral_text = None
        history_text = None
        model_info_text = None
        prompt_text = None
        admin_text = None
        settings_text = None
        promocodes_text = None
        broadcast_text = None
        stats_text = None
        
        # Handle language selection
        if data.startswith("language_select:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_language', lang=user_lang), show_alert=True)
                return ConversationHandler.END
            lang_code = parts[1]
            if lang_code in ['ru', 'en']:
                set_user_language(user_id, lang_code)
                user_lang = get_user_language(user_id)
                
                # After language selection, show full welcome menu (same as /start)
                # Get user info
                user = update.effective_user
                is_admin = (user_id == ADMIN_ID)
                
                # Get generation types and models count
                generation_types = get_generation_types()
                total_models = len(get_models_sync())
                
                # Common menu for both admin and regular users
                remaining_free = get_user_free_generations_remaining(user_id)
                is_new = is_new_user(user_id)
                referral_link = get_user_referral_link(user_id)
                referrals_count = len(get_user_referrals(user_id))
                online_count = get_fake_online_count()
                
                # Use translations for welcome message
                if is_new:
                    welcome_text = t('welcome_new', lang=user_lang,
                                    name=user.mention_html(),
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types),
                                    online=online_count,
                                    ref_bonus=REFERRAL_BONUS_GENERATIONS,
                                    ref_link=referral_link)
                else:
                    referral_bonus_text = ""
                    if referrals_count > 0:
                        referral_bonus_text = t('msg_referral_bonus', lang=user_lang,
                                              count=referrals_count,
                                              bonus=referrals_count * REFERRAL_BONUS_GENERATIONS)
                    
                    welcome_text = t('welcome_returning', lang=user_lang,
                                    name=user.mention_html(),
                                    online=online_count,
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types))
                    welcome_text += referral_bonus_text
                    welcome_text += t('msg_full_functionality', lang=user_lang,
                                    remaining=remaining_free,
                                    total=FREE_GENERATIONS_PER_DAY,
                                    ref_bonus=REFERRAL_BONUS_GENERATIONS,
                                    ref_link=referral_link,
                                    models=total_models,
                                    types=len(generation_types))
                
                # Build full keyboard (–∏—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
                keyboard = await build_main_menu_keyboard(user_id, user_lang, is_new)
                
                await query.edit_message_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            else:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_language', lang=user_lang))
                return ConversationHandler.END
        
        # Handle claim gift
        if data == "claim_gift":
            if has_claimed_gift(user_id):
                user_lang = get_user_language(user_id)
                await query.answer(t('error_already_claimed', lang=user_lang), show_alert=True)
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            # Show initial spinning message
            await query.answer(t('msg_spinning_wheel', lang=user_lang))
            if user_lang == 'ru':
                spin_message = await query.edit_message_text(
                    "üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>–ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ...</b>\n\n"
                    "‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                    parse_mode='HTML'
                )
            else:
                spin_message = await query.edit_message_text(
                    "üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>Spinning the wheel...</b>\n\n"
                    "‚è≥ Please wait, determining your prize...",
                    parse_mode='HTML'
                )
            
            # Animate wheel spinning with different sectors
            wheel_sectors = [
                ("üéØ", "üé™", "üé®", "üé≠", "üé™", "üéØ"),
                ("üí∞", "üíé", "üéÅ", "‚≠ê", "üíé", "üí∞"),
                ("üé∞", "üé≤", "üéØ", "üé™", "üé≤", "üé∞"),
                ("üí´", "‚ú®", "üåü", "‚≠ê", "‚ú®", "üí´"),
                ("üéä", "üéâ", "üéà", "üéÅ", "üéâ", "üéä")
            ]
            
            progress_steps = [
                ("üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ"),
                ("‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°"),
                ("‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®"),
                ("üí´", "üí´", "üí´", "üí´", "üí´", "üí´"),
                ("üéØ", "üéØ", "üéØ", "üéØ", "üéØ", "üéØ")
            ]
            
            # Show spinning animation
            for i in range(8):
                await asyncio.sleep(0.25)
                sector_idx = i % len(wheel_sectors)
                progress_idx = min(i, len(progress_steps) - 1)
                
                wheel_display = " ".join(wheel_sectors[sector_idx])
                progress_display = " ".join(progress_steps[progress_idx])
                
                # Progress bar simulation
                progress_percent = min((i + 1) * 12.5, 100)
                progress_bar = "‚ñà" * int(progress_percent / 5) + "‚ñë" * (20 - int(progress_percent / 5))
                
                try:
                    if user_lang == 'ru':
                        await spin_message.edit_text(
                            f"üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>–ö—Ä—É—Ç–∏–º...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                            parse_mode='HTML'
                        )
                    else:
                        await spin_message.edit_text(
                            f"üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>Spinning...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ Please wait, determining your prize...",
                            parse_mode='HTML'
                        )
                except:
                    pass
            
            # Final spin - slow down
            await asyncio.sleep(0.4)
            
            # Get the gift amount
            amount = spin_gift_wheel()
            add_user_balance(user_id, amount)
            set_gift_claimed(user_id)
            
            # Show result with celebration
            if user_lang == 'ru':
                gift_text = (
                    f'üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>–ö–û–õ–ï–°–û –û–°–¢–ê–ù–û–í–ò–õ–û–°–¨!</b> üé∞\n\n'
                    f'üéÅ <b>–í–∞—à –≤—ã–∏–≥—Ä—ã—à:</b>\n\n'
                    f'üí∞ <b>{amount:.2f} ‚ÇΩ</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>–°—É–º–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!</b>\n\n'
                    f'üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n'
                    f'‚Ä¢ –ù–∞—á–Ω–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å\n'
                    f'‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª—é–±—É—é –º–æ–¥–µ–ª—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞\n'
                    f'‚Ä¢ –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –ø—Ä–µ–º–∏—É–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏!\n\n'
                    f'‚ú® <b>–£–¥–∞—á–∏ –≤ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞!</b>'
                )
            else:
                gift_text = (
                    f'üéâ <b>CONGRATULATIONS!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>WHEEL STOPPED!</b> üé∞\n\n'
                    f'üéÅ <b>Your prize:</b>\n\n'
                    f'üí∞ <b>{amount:.2f} ‚ÇΩ</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>Amount automatically added to your balance!</b>\n\n'
                    f'üí° <b>What\'s next:</b>\n'
                    f'‚Ä¢ Start content generation right now\n'
                    f'‚Ä¢ Use any model from the catalog\n'
                    f'‚Ä¢ Enjoy premium features!\n\n'
                    f'‚ú® <b>Good luck creating content!</b>'
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_check_balance', lang=user_lang), callback_data="check_balance")],
                [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            await spin_message.edit_text(
                gift_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle admin user mode toggle (MUST be first, before any other checks)
        if data == "admin_user_mode":
            # Toggle user mode for admin
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            
            current_mode = user_sessions[user_id].get('admin_user_mode', False)
            user_sessions[user_id]['admin_user_mode'] = not current_mode
            
            if not current_mode:
                # Switching to user mode - send new message directly
                user_lang = get_user_language(user_id)
                await query.answer(t('msg_user_mode_enabled', lang=user_lang))
                user = update.effective_user
                categories = get_categories_from_registry()
                total_models = len(get_models_sync())
                
                remaining_free = get_user_free_generations_remaining(user_id)
                free_info = ""
                if remaining_free > 0:
                    free_info = f"\nüéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image\n"
                
                welcome_text = (
                    f'‚ú® <b>–ü–†–ï–ú–ò–£–ú AI MARKETPLACE</b> ‚ú®\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üëã –ü—Ä–∏–≤–µ—Ç, {user.mention_html()}!\n\n'
                    f'üöÄ <b>–¢–æ–ø–æ–≤—ã–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –±–µ–∑ VPN</b>\n'
                    f'üì¶ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> | <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>{free_info}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíé <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n'
                    f'‚Ä¢ –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –º–∏—Ä–æ–≤—ã–º AI\n'
                    f'‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                    f'‚Ä¢ –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                    f'üéØ <b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –≤—Å–µ –º–æ–¥–µ–ª–∏</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category_from_registry(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîô –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="admin_back_to_admin")
                ])
                keyboard.append([
                    InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu"),
                    InlineKeyboardButton("üí¨ –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support_contact")
                ])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            else:
                # Switching back to admin mode - send new message with full admin panel
                user_sessions[user_id]['admin_user_mode'] = False
                user_lang = get_user_language(user_id)
                await query.answer(t('msg_returning_to_admin', lang=user_lang))
                user = update.effective_user
                generation_types = get_generation_types()
                total_models = len(get_models_sync())
                
                welcome_text = (
                    f'üëë ‚ú® <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> ‚ú®\n\n'
                    f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                    f'üéØ <b>–ü–û–õ–ù–´–ô –ö–û–ù–¢–†–û–õ–¨ –ù–ê–î AI MARKETPLACE</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´:</b>\n\n'
                    f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
                    f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üî• <b>–¢–û–ü–û–í–´–ï –ú–û–î–ï–õ–ò –í –°–ò–°–¢–ï–ú–ï:</b>\n\n'
                    f'üé® <b>Google Imagen 4 Ultra</b> - –§–ª–∞–≥–º–∞–Ω –æ—Ç Google DeepMind\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 4.63 ‚ÇΩ)\n'
                    f'   ‚≠êÔ∏è –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è\n\n'
                    f'üçå <b>Nano Banana Pro</b> - 4K –æ—Ç Google\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (1K/2K: 6.95 ‚ÇΩ, 4K: 9.27 ‚ÇΩ)\n'
                    f'   üéØ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 2K/4K\n\n'
                    f'üé• <b>Sora 2</b> - –í–∏–¥–µ–æ –æ—Ç OpenAI\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 11.58 ‚ÇΩ) –∑–∞ 10-—Å–µ–∫—É–Ω–¥–Ω–æ–µ –≤–∏–¥–µ–æ\n'
                    f'   üé¨ –ö–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –≤–∏–¥–µ–æ —Å –∞—É–¥–∏–æ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:</b>\n\n'
                    f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
                    f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
                    f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
                    f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí´ <b>–ù–ê–ß–ù–ò–¢–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–õ–ò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï!</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category_from_registry(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                keyboard.append([
                    InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                    InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                    InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
                ])
                keyboard.append([
                    InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
                ])
                keyboard.append([
                    InlineKeyboardButton("üë§ –†–µ–∂–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", callback_data="admin_user_mode")
                ])
                keyboard.append([InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu")])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "admin_back_to_admin":
            # Return to admin mode - send new message directly
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if user_id in user_sessions:
                user_sessions[user_id]['admin_user_mode'] = False
            await query.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")
            user = update.effective_user
            categories = get_categories_from_registry()
            total_models = len(KIE_MODELS)
            
            welcome_text = (
                f'üëë <b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n'
                f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                f'üöÄ <b>–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</b>\n\n'
                f'üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n'
                f'‚úÖ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> –¥–æ—Å—Ç—É–ø–Ω–æ\n'
                f'‚úÖ <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>\n\n'
                f'‚öôÔ∏è <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã</b>'
            )
            
            keyboard = []
            
            # All models button first
            keyboard.append([
                InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
            ])
            
            keyboard.append([])
            for category in categories:
                models_in_category = get_models_by_category_from_registry(category)
                emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {category} ({len(models_in_category)})",
                    callback_data=f"category:{category}"
                )])
            
            keyboard.append([
                InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
            ])
            keyboard.append([
                InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
            ])
            keyboard.append([
                InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            await query.message.reply_text(
                welcome_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "back_to_menu":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language before showing menu
            user_id = update.effective_user.id
            user_lang = get_user_language(user_id)
            
            # Return to start menu - show menu in correct language
            try:
                user = update.effective_user
                user_id = user.id
                is_admin = (user_id == ADMIN_ID)
                
                generation_types = get_generation_types()
                total_models = len(get_models_sync())
                remaining_free = get_user_free_generations_remaining(user_id)
                is_new = is_new_user(user_id)
                referral_link = get_user_referral_link(user_id)
                referrals_count = len(get_user_referrals(user_id))
                
                # Use translations based on user language
                if is_new:
                    welcome_text = t('welcome_new', lang=user_lang,
                                    name=user.mention_html(),
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types),
                                    online=get_fake_online_count(),
                                    ref_bonus=REFERRAL_BONUS_GENERATIONS,
                                    ref_link=referral_link)
                else:
                    referral_bonus_text = ""
                    if referrals_count > 0:
                        if user_lang == 'ru':
                            referral_bonus_text = (
                                f"\nüéÅ <b>–û—Ç–ª–∏—á–Ω–æ!</b> –¢—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª <b>{referrals_count}</b> –¥—Ä—É–∑–µ–π\n"
                                f"   ‚Üí –ü–æ–ª—É—á–µ–Ω–æ <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>! üéâ\n\n"
                            )
                        else:
                            referral_bonus_text = (
                                f"\nüéÅ <b>Great!</b> You invited <b>{referrals_count}</b> friends\n"
                                f"   ‚Üí Received <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} free generations</b>! üéâ\n\n"
                            )
                    
                    welcome_text = t('welcome_returning', lang=user_lang,
                                    name=user.mention_html(),
                                    online=get_fake_online_count(),
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types))
                    welcome_text += referral_bonus_text
                    
                    if user_lang == 'ru':
                        welcome_text += (
                            f'üíé <b>–ü–û–õ–ù–´–ô –§–£–ù–ö–¶–ò–û–ù–ê–õ:</b>\n\n'
                            f'<b>üì∏ –†–ê–ë–û–¢–ê –° –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø–ú–ò:</b>\n'
                            f'‚Ä¢ ‚ú® –¢–µ–∫—Å—Ç –≤ —Ñ–æ—Ç–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                            f'‚Ä¢ üé® –§–æ—Ç–æ –≤ —Ñ–æ—Ç–æ - —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                            f'‚Ä¢ üñºÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–æ—Ç–æ - —É–ª—É—á—à–µ–Ω–∏–µ, –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ, —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞\n'
                            f'‚Ä¢ üé® –†–µ—Ñ—Ä–µ–π–º–∏–Ω–≥ - –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–¥—Ä–∞ –∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω\n\n'
                            f'<b>üé¨ –†–ê–ë–û–¢–ê –° –í–ò–î–ï–û:</b>\n'
                            f'‚Ä¢ üé¨ –¢–µ–∫—Å—Ç –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è\n'
                            f'‚Ä¢ üì∏ –§–æ—Ç–æ –≤ –≤–∏–¥–µ–æ - –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –¥–∏–Ω–∞–º–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                            f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ä–µ—á–∏ –∏ –∞—É–¥–∏–æ\n'
                            f'‚Ä¢ üëÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≥—É–± - –∞–≤–∞—Ç–∞—Ä—ã —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –≥—É–±\n'
                            f'‚Ä¢ ‚úÇÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞, —É–¥–∞–ª–µ–Ω–∏–µ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤\n\n'
                            f'<b>üéôÔ∏è –†–ê–ë–û–¢–ê –° –ê–£–î–ò–û:</b>\n'
                            f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ —Ç–µ–∫—Å—Ç - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä–µ—á–∏ –≤ —Ç–µ–∫—Å—Ç —Å –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üÜì <b>–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´:</b>\n'
                            f'‚Ä¢ <b>Recraft Remove Background</b> - —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞ (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                            f'‚Ä¢ <b>Recraft Crisp Upscale</b> - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                            f'‚Ä¢ <b>Z-Image</b> - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                            f'   üìä <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> <b>{remaining_free}/{FREE_GENERATIONS_PER_DAY}</b> –≥–µ–Ω–µ—Ä–∞—Ü–∏–π —Å–µ–≥–æ–¥–Ω—è\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n'
                            f'‚Ä¢ {total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π\n'
                            f'‚Ä¢ {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n'
                            f'‚Ä¢ üåê –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –ë–ï–ó VPN\n'
                            f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                            f'üí∞ <b>–¶–ï–ù–´:</b>\n'
                            f'–û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n\n'
                            f'üéØ <b>–í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞—á–Ω–∏ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π!</b>'
                        )
                    else:
                        welcome_text += (
                            f'üíé <b>FULL FUNCTIONALITY:</b>\n\n'
                            f'<b>üì∏ IMAGE GENERATION:</b>\n'
                            f'‚Ä¢ ‚ú® Text to Image - create images from text\n'
                            f'‚Ä¢ üé® Image to Image - transform and style images\n'
                            f'‚Ä¢ üñºÔ∏è Image Editing - enhance, upscale, remove background\n'
                            f'‚Ä¢ üé® Reframing - change frame and aspect ratio\n\n'
                            f'<b>üé¨ VIDEO GENERATION:</b>\n'
                            f'‚Ä¢ üé¨ Text to Video - create videos from text descriptions\n'
                            f'‚Ä¢ üì∏ Image to Video - turn images into dynamic videos\n'
                            f'‚Ä¢ üéôÔ∏è Speech to Video - create videos from speech and audio\n'
                            f'‚Ä¢ üëÑ Lip Sync - avatars with lip synchronization\n'
                            f'‚Ä¢ ‚úÇÔ∏è Video Editing - quality enhancement, watermark removal\n\n'
                            f'<b>üéôÔ∏è AUDIO PROCESSING:</b>\n'
                            f'‚Ä¢ üéôÔ∏è Speech to Text - convert speech to text with high accuracy\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üÜì <b>FREE TOOLS:</b>\n'
                            f'‚Ä¢ <b>Recraft Remove Background</b> - remove background (free and unlimited!)\n'
                            f'‚Ä¢ <b>Recraft Crisp Upscale</b> - enhance image quality (free and unlimited!)\n'
                            f'‚Ä¢ <b>Z-Image</b> - image generation\n'
                            f'   üìä <b>Free:</b> <b>{remaining_free}/{FREE_GENERATIONS_PER_DAY}</b> generations today\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üìä <b>STATISTICS:</b>\n'
                            f'‚Ä¢ {total_models} top AI models\n'
                            f'‚Ä¢ {len(generation_types)} generation types\n'
                            f'‚Ä¢ üåê Direct access WITHOUT VPN\n'
                            f'‚Ä¢ ‚ö° Instant generation\n\n'
                            f'üí∞ <b>PRICING:</b>\n'
                            f'From 0.62 ‚ÇΩ per image ‚Ä¢ From 3.86 ‚ÇΩ per video\n\n'
                            f'üéØ <b>Choose generation format below or start with free!</b>'
                        )
                
                # Build keyboard (same as start function)
                keyboard = []
                
                # Free generation button
                if user_lang == 'ru':
                    if remaining_free > 0:
                        button_text = f"üéÅ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ë–ï–°–ü–õ–ê–¢–ù–û ({remaining_free}/{FREE_GENERATIONS_PER_DAY} –æ—Å—Ç–∞–ª–æ—Å—å)"
                    else:
                        button_text = f"üéÅ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ë–ï–°–ü–õ–ê–¢–ù–û (0/{FREE_GENERATIONS_PER_DAY} –æ—Å—Ç–∞–ª–æ—Å—å)"
                else:
                    if remaining_free > 0:
                        button_text = f"üéÅ GENERATE FREE ({remaining_free}/{FREE_GENERATIONS_PER_DAY} left)"
                    else:
                        button_text = f"üéÅ GENERATE FREE (0/{FREE_GENERATIONS_PER_DAY} left)"
                
                keyboard.append([
                    InlineKeyboardButton(button_text, callback_data="select_model:z-image")
                ])
                
                # Add referral button
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton(f"üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö!", callback_data="referral_info")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton(f"üéÅ Invite friend ‚Üí get +{REFERRAL_BONUS_GENERATIONS} free!", callback_data="referral_info")
                    ])
                
                keyboard.append([])
                
                # Add free tools button
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton("üÜì –ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´", callback_data="free_tools")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton("üÜì FREE TOOLS", callback_data="free_tools")
                    ])
                
                keyboard.append([])
                
                # Generation types
                text_to_image_type = None
                gen_type_rows = []
                gen_type_index = 0
                
                for gen_type in generation_types:
                    gen_info = get_generation_type_info(gen_type)
                    models_count = len(get_models_by_generation_type(gen_type))
                    
                    if models_count == 0:
                        continue
                    
                    if gen_type == 'text-to-image':
                        text_to_image_type = gen_type
                        continue
                        
                    # Get translated name for generation type
                    gen_type_key = f'gen_type_{gen_type.replace("-", "_")}'
                    gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', gen_type))
                    button_text = f"{gen_type_name} ({models_count})"
                    
                    if gen_type_index % 2 == 0:
                        gen_type_rows.append([InlineKeyboardButton(button_text, callback_data=f"gen_type:{gen_type}")])
                    else:
                        if gen_type_rows:
                            gen_type_rows[-1].append(InlineKeyboardButton(button_text, callback_data=f"gen_type:{gen_type}"))
                        else:
                            gen_type_rows.append([InlineKeyboardButton(button_text, callback_data=f"gen_type:{gen_type}")])
                    
                    gen_type_index += 1
                
                if text_to_image_type:
                    gen_info = get_generation_type_info(text_to_image_type)
                    models_count = len(get_models_by_generation_type(text_to_image_type))
                    if models_count > 0:
                        gen_type_key = f'gen_type_{text_to_image_type.replace("-", "_")}'
                        gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', text_to_image_type))
                        button_text = f"{gen_type_name} ({models_count})"
                        keyboard.append([
                            InlineKeyboardButton(button_text, callback_data=f"gen_type:{text_to_image_type}")
                        ])
                        keyboard.append([])
                
                keyboard.extend(gen_type_rows)
                
                keyboard.append([])
                
                # All models button
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton(f"ü§ñ –í—Å–µ –º–æ–¥–µ–ª–∏ ({total_models})", callback_data="show_models")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton(f"ü§ñ All Models ({total_models})", callback_data="show_models")
                    ])
                keyboard.append([])
                
                # Claim gift button
                if not has_claimed_gift(user_id):
                    keyboard.append([
                        InlineKeyboardButton(t('btn_claim_gift', lang=user_lang), callback_data="claim_gift")
                    ])
                    keyboard.append([])
                
                # Bottom buttons
                keyboard.append([
                    InlineKeyboardButton(t('balance', lang=user_lang), callback_data="check_balance"),
                    InlineKeyboardButton(t('my_generations', lang=user_lang), callback_data="my_generations")
                ])
                keyboard.append([
                    InlineKeyboardButton("üí≥ " + (t('topup', lang=user_lang) if user_lang == 'ru' else "Top up"), callback_data="topup_balance"),
                    InlineKeyboardButton(t('referral', lang=user_lang), callback_data="referral_info")
                ])
                
                if is_new:
                    if user_lang == 'ru':
                        keyboard.append([
                            InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")
                        ])
                    else:
                        keyboard.append([
                            InlineKeyboardButton("‚ùì How it works?", callback_data="tutorial_start")
                        ])
                
                keyboard.append([
                    InlineKeyboardButton(t('help', lang=user_lang), callback_data="help_menu"),
                    InlineKeyboardButton(t('support', lang=user_lang), callback_data="support_contact")
                ])
                
                # Add language selection button (always visible)
                keyboard.append([
                    InlineKeyboardButton("üåê " + ("–Ø–∑—ã–∫ / Language" if user_lang == 'ru' else "Language / –Ø–∑—ã–∫"), callback_data="change_language")
                ])
                
                if is_admin:
                    keyboard.append([])
                    if user_lang == 'ru':
                        keyboard.append([
                            InlineKeyboardButton("üëë –ê–î–ú–ò–ù –ü–ê–ù–ï–õ–¨", callback_data="admin_stats")
                        ])
                    else:
                        keyboard.append([
                            InlineKeyboardButton("üëë ADMIN PANEL", callback_data="admin_stats")
                        ])
                
                try:
                    await query.edit_message_text(
                        welcome_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in back_to_menu: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            welcome_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in back_to_menu: {send_error}", exc_info=True)
                        await query.answer(t('error_try_start', lang=user_lang), show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in back_to_menu: {e}", exc_info=True)
                try:
                    await query.answer(t('error_try_start', lang=user_lang), show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
    
        if data == "generate_again":
            # Generate again - restore model and show model info, then ask for new prompt
            await query.answer()  # Acknowledge the callback
            
            logger.info(f"Generate again requested by user {user_id}")
            
            if user_id not in saved_generations:
                logger.warning(f"No saved generation data for user {user_id}")
                await query.edit_message_text(
                    "‚ùå <b>–î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                    "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —á–µ—Ä–µ–∑ –º–µ–Ω—é.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            saved_data = saved_generations[user_id]
            logger.info(f"Restoring generation data for user {user_id}, model: {saved_data.get('model_id')}")
            
            # Restore session with model info, but clear params to start fresh
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            
            model_id = saved_data['model_id']
            model_info = saved_data['model_info']
            
            # Restore model info but clear params - user will enter new prompt
            user_sessions[user_id].update({
                'model_id': model_id,
                'model_info': model_info,
                'properties': saved_data['properties'].copy(),
                'required': saved_data['required'].copy(),
                'params': {}  # Clear params - start fresh
            })
            
            # Get user balance and calculate available generations (same as select_model)
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            
            # Calculate price for default parameters (minimum price)
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}  # Cheapest option
            elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
                default_params = {"quality": "basic"}  # Basic quality (same price, but for consistency)
            
            min_price = calculate_price_rub(model_id, default_params, is_admin)
            price_text = format_price_rub(min_price, is_admin)
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif user_balance >= min_price:
                available_count = int(user_balance / min_price)
            else:
                available_count = 0
            
            # Show model info with price and available generations (improved format)
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –º–æ–¥–µ–ª–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            model_category = model_info.get('category', '')
            gen_type = model_info.get('generation_type', '')

            model_info_text = (
                f"{model_emoji} <b>{model_name}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if model_category:
                model_info_text += f"üìÅ <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {model_category}\n"
            if gen_type:
                gen_type_display = gen_type.replace('_', ' ').replace('-', ' ').title()
                model_info_text += f"üéØ <b>–¢–∏–ø:</b> {gen_type_display}\n"
            
            if model_category or gen_type:
                model_info_text += "\n"
            
            if model_desc:
                model_info_text += f"‚ÑπÔ∏è <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{model_desc}\n\n"
            
            model_info_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            model_info_text += f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {price_text} ‚ÇΩ\n"
            
            if is_admin:
                model_info_text += t('msg_unlimited_available', lang=user_lang) + "\n\n"
            else:
                if available_count > 0:
                    model_info_text += t('msg_available_generations', lang=user_lang, 
                                        count=available_count, 
                                        balance=format_price_rub(user_balance, is_admin)) + "\n\n"
                else:
                    # Not enough balance - show warning
                    model_info_text += t('msg_insufficient_funds', lang=user_lang,
                                        balance=format_price_rub(user_balance, is_admin),
                                        required=price_text)
                    
                    keyboard = [
                        [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                        [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                    ]
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
            
            # Check balance before starting generation
            if not is_admin and user_balance < min_price:
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                
                needed = min_price - user_balance
                needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
                remaining_free = get_user_free_generations_remaining(user_id)
                
                if user_lang == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º:</b> {price_text} ‚ÇΩ\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image ({remaining_free} –¥–æ—Å—Ç—É–ø–Ω–æ)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å—ã\n\n"
                        f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient Funds for Generation</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>Your balance:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üíµ <b>Minimum required:</b> {price_text} ‚ÇΩ\n"
                        f"‚ùå <b>Need:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>What to do:</b>\n"
                        f"‚Ä¢ Top up balance via button below\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ Use free Z-Image generations ({remaining_free} available)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ Invite a friend and get bonuses\n\n"
                        f"üîÑ After topping up, try generation again."
                    )
                
                await query.edit_message_text(
                    insufficient_msg,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get input parameters from model info
            input_params = model_info.get('input_params', {})
            
            if not input_params:
                # If no params defined, ask for simple text input
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
                    parse_mode='HTML'
                )
                user_sessions[user_id]['params'] = {}
                user_sessions[user_id]['waiting_for'] = 'text'
                return INPUTTING_PARAMS
            
            # Store session data
            user_sessions[user_id]['params'] = {}
            user_sessions[user_id]['properties'] = input_params
            user_sessions[user_id]['required'] = [p for p, info in input_params.items() if info.get('required', False)]
            user_sessions[user_id]['current_param'] = None
            # NOTE: model_id and model_info are already stored above at lines 8449-8450
            
            # Start with prompt parameter first (or image_input/image_urls first for image-to-video models)
            # Special case: Models that require image_input first (nano-banana-pro, recraft models, etc.)
            # These models need image before prompt
            # Models that require image_input first (before prompt or other parameters)
            # These models need image to be uploaded first
            models_require_image_first = [
                "nano-banana-pro",              # Requires image_input + prompt
                "recraft/remove-background",    # Requires only image_input (no prompt)
                "recraft/crisp-upscale",        # Requires only image_input (no prompt)
                "ideogram/v3-reframe",          # Requires image_input first (no prompt)
                "topaz/image-upscale",          # Requires image_input (no prompt)
            ]
            
            # Check if model requires image_input first
            requires_image_first = model_id in models_require_image_first
            has_required_image = 'image_input' in input_params and input_params['image_input'].get('required', False)
            
            logger.info(f"üî•üî•üî• SELECT_MODEL CHECK: model_id={model_id}, requires_image_first={requires_image_first}, has_required_image={has_required_image}, input_params_keys={list(input_params.keys())}, user_id={user_id}")
            
            if requires_image_first or has_required_image:
                logger.info(f"üî•üî•üî• SELECT_MODEL: Model requires image first! Setting up image input, user_id={user_id}")
                # Determine parameter name
                if 'image_input' in input_params:
                    image_param_name = 'image_input'
                elif 'image_urls' in input_params:
                    image_param_name = 'image_urls'
                else:
                    image_param_name = 'image_input'  # Default
                
                # Start with image_input first
                has_image_input = True
                user_lang = get_user_language(user_id)
                
                # Get translated text with model-specific messages
                if user_lang == 'en':
                    step_text = "üì∑ <b>Step 1: Upload image</b>\n\n"
                    if model_id == "recraft/remove-background":
                        step_text += "Send a photo to remove the background.\n\n"
                    elif model_id == "recraft/crisp-upscale":
                        step_text += "Send a photo to enhance quality.\n\n"
                    elif model_id == "ideogram/v3-reframe":
                        step_text += "Send a photo to reframe and change aspect ratio.\n\n"
                    elif model_id == "topaz/image-upscale":
                        step_text += "Send a photo to upscale and enhance resolution.\n\n"
                    elif model_id == "nano-banana-pro":
                        step_text += "Send a photo to use as reference or for transformation.\n\n"
                        step_text += "üí° <i>After uploading the image, you can enter a prompt</i>"
                    else:
                        step_text += "Send a photo to use as reference or for transformation.\n\n"
                        # Check if model has prompt parameter
                        if 'prompt' in input_params:
                            step_text += "üí° <i>After uploading the image, you can enter a prompt</i>"
                else:
                    step_text = (
                        "üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    )
                    if model_id == "recraft/remove-background":
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB\n\n"
                            "‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> —Ñ–æ–Ω –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏"
                        )
                    elif model_id == "recraft/crisp-upscale":
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB\n\n"
                            "‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –±—É–¥–µ—Ç —É–ª—É—á—à–µ–Ω–æ"
                        )
                    elif model_id == "ideogram/v3-reframe":
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–∞–¥—Ä–∞ –∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB\n\n"
                            "‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤—ã–±—Ä–∞—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω"
                        )
                    elif model_id == "topaz/image-upscale":
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB\n\n"
                            "‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –±—É–¥–µ—Ç —É–≤–µ–ª–∏—á–µ–Ω–æ"
                        )
                    elif model_id == "nano-banana-pro":
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB\n\n"
                            "‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"
                        )
                    else:
                        step_text += (
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
                            "üí° <b>–ß—Ç–æ –Ω—É–∂–Ω–æ:</b>\n"
                            "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB"
                        )
                        # Check if model has prompt parameter
                        if 'prompt' in input_params:
                            step_text += "\n\n‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                
                await query.edit_message_text(
                    f"{model_info_text}\n\n{step_text}",
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = image_param_name
                user_sessions[user_id]['waiting_for'] = image_param_name
                if image_param_name not in user_sessions[user_id]:
                    user_sessions[user_id][image_param_name] = []  # Initialize as array
                await query.answer()
                logger.info(f"üî•üî•üî• SELECT_MODEL: Image input setup complete! model_id={model_id}, user_id={user_id}, waiting_for={image_param_name}, session_keys={list(user_sessions[user_id].keys())[:10]}")
                logger.info(f"üî•üî•üî• SELECT_MODEL: RETURNING INPUTTING_PARAMS for user {user_id}, model {model_id}, waiting_for={image_param_name}")
                elapsed = time.time() - start_time
                logger.info(f"üî•üî•üî• SELECT_MODEL: Total time={elapsed:.3f}s, user_id={user_id}")
                return INPUTTING_PARAMS
            
            # Special case: sora-2-pro-image-to-video starts with image_urls first
            if model_id == "sora-2-pro-image-to-video" and 'image_urls' in input_params and input_params['image_urls'].get('required', False):
                # Start with image_urls first for sora-2-pro-image-to-video
                has_image_input = True
                image_param_name = 'image_urls'
                await query.edit_message_text(
                    f"{model_info_text}\n\n"
                    f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                    f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫–∞–∫ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –≤–∏–¥–µ–æ.\n\n"
                    f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>",
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'image_urls'
                user_sessions[user_id]['waiting_for'] = 'image_urls'
                if 'image_urls' not in user_sessions[user_id]:
                    user_sessions[user_id]['image_urls'] = []  # Initialize as array
                await query.answer()
                return INPUTTING_PARAMS
            
            # Start with prompt parameter first (default behavior)
            if 'prompt' in input_params:
                # Check if model supports image input (image_input or image_urls)
                # BUT: z-image does NOT support image input (text-to-image only)
                # AND: text-to-video models do NOT require image input (text-to-video only)
                is_text_to_video = "text-to-video" in model_id.lower()
                has_image_input = (model_id != "z-image" and 
                                 not is_text_to_video and
                                 ('image_input' in input_params or 'image_urls' in input_params))
                
                prompt_text = (
                    f"{model_info_text}"
                )
                
                # Determine if this is a video or audio model
                is_video = is_video_model(model_id)
                is_audio = is_audio_model(model_id)
                
                if has_image_input:
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</i>"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</i>"
                        )
                else:
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                        )
                    elif is_audio:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                        )
                
                # Add keyboard with "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é" and "–û—Ç–º–µ–Ω–∞" buttons
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                await query.edit_message_text(
                    prompt_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'prompt'
                user_sessions[user_id]['waiting_for'] = 'prompt'
                user_sessions[user_id]['has_image_input'] = has_image_input
            else:
                # If no prompt, start with first required parameter
                await start_next_parameter(update, context, user_id)
            
            return INPUTTING_PARAMS
        
        if data.startswith("set_language:"):
            # Handle language selection
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(query.from_user.id)
                await query.answer(t('error_invalid_format', lang=user_lang), show_alert=True)
                return ConversationHandler.END
            lang = parts[1]
            if lang in ['ru', 'en']:
                set_user_language(user_id, lang)
                await query.answer(t('language_set', lang))
                # Show main menu after language selection
                await start(update, context)
                return ConversationHandler.END
            else:
                await query.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —è–∑—ã–∫ / Invalid language")
            return ConversationHandler.END
        
        if data == "cancel":
            user_lang = get_user_language(user_id)
            await query.answer(t('btn_cancel', lang=user_lang).replace('‚ùå ', ''))
            if user_id in user_sessions:
                del user_sessions[user_id]
            try:
                keyboard = [[InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]]
                await query.edit_message_text(
                    t('msg_operation_cancelled', lang=user_lang),
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e:
                logger.error(f"Error editing message on cancel: {e}")
                try:
                    keyboard = [[InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]]
                    await query.message.reply_text(
                        t('msg_operation_cancelled', lang=user_lang),
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data.startswith("retry_generate:"):
            # Retry generation with same parameters
            await query.answer("–ü–æ–≤—Ç–æ—Ä—è—é –ø–æ–ø—ã—Ç–∫—É...")
            
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            
            # Show confirmation again with same parameters
            model_name = session.get('model_info', {}).get('name', 'Unknown')
            params = session.get('params', {})
            params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
            
            user_lang = get_user_language(user_id)
            keyboard = [
                [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            
            await query.edit_message_text(
                f"üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞:</b>\n\n"
                f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return CONFIRMING_GENERATION
        
        # Handle category selection (can be called from main menu)
        if data.startswith("gen_type:"):
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # User selected a generation type
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            gen_type = parts[1]
            gen_info = get_generation_type_info(gen_type)
            models = get_models_by_generation_type(gen_type)
            
            if not models:
                user_lang = get_user_language(user_id)
                error_text = t('msg_gen_type_no_models', lang=user_lang)
                try:
                    await query.edit_message_text(
                        error_text,
                        parse_mode='HTML'
                    )
                except:
                    try:
                        await query.message.reply_text(
                            error_text,
                            parse_mode='HTML'
                        )
                    except:
                        pass
                return ConversationHandler.END
            
            # Get admin status for price calculations
            is_admin = get_is_admin(user_id)
            
            # Show generation type info and models with marketing text
            remaining_free = get_user_free_generations_remaining(user_id)
            user_lang = get_user_language(user_id)
            
            # Get translated name and description
            gen_type_key = f'gen_type_{gen_type.replace("-", "_")}'
            gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', gen_type))
            gen_desc_key = f'gen_type_desc_{gen_type.replace("-", "_")}'
            gen_type_description = t(gen_desc_key, lang=user_lang, default=gen_info.get('description', ''))
            
            gen_type_text = (
                f"{t('msg_gen_type_title', lang=user_lang, name=gen_type_name)}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"{t('msg_gen_type_description', lang=user_lang, description=gen_type_description)}\n\n"
            )
            
            if remaining_free > 0 and gen_type == "text-to-image":
                gen_type_text += (
                    f"{t('msg_gen_type_free', lang=user_lang, remaining=remaining_free)}\n"
                    f"üí° {t('btn_invite_friend', lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}\n\n"
                )
            
            gen_type_text += (
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"{t('msg_gen_type_models_available', lang=user_lang, count=len(models))}\n\n"
                f"{t('msg_gen_type_select_model', lang=user_lang)}"
            )
            
            # Create keyboard with models (2 per row for compact display)
            keyboard = []
            
            # Free generation button if available and this is text-to-image
            # Always show button with count, even if 0
            if gen_type == "text-to-image":
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    button_text = f"üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ ({remaining_free}/{FREE_GENERATIONS_PER_DAY} –æ—Å—Ç–∞–ª–æ—Å—å)"
                else:
                    button_text = f"üéÅ Generate free ({remaining_free}/{FREE_GENERATIONS_PER_DAY} left)"
                keyboard.append([
                    InlineKeyboardButton(button_text, callback_data="select_model:z-image")
                ])
                
                # Add referral button
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton(f"üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö!", callback_data="referral_info")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton(f"üéÅ Invite friend ‚Üí get +{REFERRAL_BONUS_GENERATIONS} free!", callback_data="referral_info")
                    ])
                
                keyboard.append([])  # Empty row
            
            # Show models in compact format with prices (2 per row)
            model_rows = []
            for i, model in enumerate(models):
                model_name = model.get('name', model.get('id', 'Unknown'))
                model_emoji = model.get('emoji', 'ü§ñ')
                model_id = model.get('id')
                
                # Calculate price for display
                default_params = {}
                if model_id == "nano-banana-pro":
                    default_params = {"resolution": "1K"}
                elif model_id in ["seedream/4.5-text-to-image", "seedream/4.5-edit"]:
                    default_params = {"quality": "basic"}
                
                # IMPORTANT: Use get_is_admin() if user_id is available to respect admin_user_mode
                is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
                min_price = calculate_price_rub(model_id, default_params, is_admin_check, user_id)
                price_text = get_model_price_text(model_id, default_params, is_admin_check, user_id)
                
                # Extract price number from price_text for compact display
                import re
                price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_text)
                if price_match:
                    price_display = price_match.group(1)
                    # Check if it's "–û—Ç" (from) or fixed price
                    if "–û—Ç" in price_text or "–æ—Ç" in price_text.lower():
                        price_display = f"–æ—Ç {price_display} ‚ÇΩ"
                    else:
                        price_display = f"{price_display} ‚ÇΩ"
                elif "–ë–ï–°–ü–õ–ê–¢–ù–û" in price_text or "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" in price_text:
                    price_display = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ"
                else:
                    # Fallback: show calculated price
                    price_display = f"{min_price:.2f} ‚ÇΩ"
                
                # Compact button text (Telegram limit: 64 characters for button text)
                # Make it shorter to fit price and avoid overlap
                max_name_length = 20  # Shorter to fit price
                button_text = f"{model_emoji} {model_name}"
                if len(button_text) > max_name_length:
                    # Truncate model name if too long
                    button_text = f"{model_emoji} {model_name[:max_name_length-4]}..."
                
                button_text_with_price = f"{button_text} ‚Ä¢ {price_display}"
                
                # Final check: Telegram button text limit is 64 characters
                if len(button_text_with_price) > 64:
                    # If still too long, truncate more aggressively
                    max_total = 60  # Leave some margin
                    available_for_name = max_total - len(f" ‚Ä¢ {price_display}")
                    if available_for_name > 0:
                        button_text = f"{model_emoji} {model_name[:available_for_name-4]}..."
                        button_text_with_price = f"{button_text} ‚Ä¢ {price_display}"
                    else:
                        # If price is too long, just show model name
                        button_text_with_price = button_text[:60] + "..."
                
                # Ensure callback_data is not too long (Telegram limit: 64 bytes)
                callback_data = f"select_model:{model_id}"
                if len(callback_data.encode('utf-8')) > 64:
                    logger.error(f"Callback data too long for model {model_id}: {len(callback_data.encode('utf-8'))} bytes")
                    # Use shorter model_id if possible
                    callback_data = f"sel:{model_id[:50]}"
                
                if i % 2 == 0:
                    # First button in row
                    model_rows.append([InlineKeyboardButton(
                        button_text_with_price,
                        callback_data=callback_data
                    )])
                else:
                    # Second button in row - add to last row
                    if model_rows:
                        model_rows[-1].append(InlineKeyboardButton(
                            button_text_with_price,
                            callback_data=callback_data
                        ))
                    else:
                        model_rows.append([InlineKeyboardButton(
                            button_text_with_price,
                            callback_data=callback_data
                        )])
            
            keyboard.extend(model_rows)
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            try:
                await query.edit_message_text(
                    gen_type_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in gen_type: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        gen_type_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e2:
                    logger.error(f"Error sending new message in gen_type: {e2}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
            
            # IMPORTANT: Return SELECTING_MODEL state so that select_model: buttons work
            # If we return END, the buttons won't be clickable
            return SELECTING_MODEL
        
        if data.startswith("category:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            category = parts[1]
            models = get_models_by_category_from_registry(category)
            
            if not models:
                try:
                    await query.edit_message_text(f"‚ùå –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category} –Ω–µ—Ç –º–æ–¥–µ–ª–µ–π.")
                except:
                    try:
                        await query.message.reply_text(f"‚ùå –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category} –Ω–µ—Ç –º–æ–¥–µ–ª–µ–π.")
                    except:
                        pass
                return ConversationHandler.END
            
            # Get user balance for showing available generations
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            
            keyboard = []
            for model in models:
                # Calculate price for display
                default_params = {}
                if model['id'] == "nano-banana-pro":
                    default_params = {"resolution": "1K"}
                elif model['id'] in ["seedream/4.5-text-to-image", "seedream/4.5-edit"]:
                    default_params = {"quality": "basic"}
                
                # IMPORTANT: Use get_is_admin() if user_id is available to respect admin_user_mode
                is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
                min_price = calculate_price_rub(model['id'], default_params, is_admin_check, user_id)
                price_text = get_model_price_text(model['id'], default_params, is_admin_check, user_id)
                
                # Extract price number from price_text for compact display
                import re
                price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_text)
                if price_match:
                    price_display = price_match.group(1)
                    # Check if it's "–û—Ç" (from) or fixed price
                    if "–û—Ç" in price_text or "–æ—Ç" in price_text.lower():
                        price_display = f"–æ—Ç {price_display} ‚ÇΩ"
                    else:
                        price_display = f"{price_display} ‚ÇΩ"
                elif "–ë–ï–°–ü–õ–ê–¢–ù–û" in price_text or "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" in price_text:
                    price_display = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ"
                else:
                    # Fallback: show calculated price
                    price_display = f"{min_price:.2f} ‚ÇΩ"
                
                # Compact button text with price (Telegram limit: 64 characters)
                model_name = model.get('name', model.get('id', 'Unknown'))
                model_emoji = model.get('emoji', 'ü§ñ')
                model_id = model.get('id')
                
                # Extract price for display
                import re
                price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_text)
                if price_match:
                    price_display = price_match.group(1)
                    if "–û—Ç" in price_text or "–æ—Ç" in price_text.lower():
                        price_display = f"–æ—Ç {price_display} ‚ÇΩ"
                    else:
                        price_display = f"{price_display} ‚ÇΩ"
                elif "–ë–ï–°–ü–õ–ê–¢–ù–û" in price_text or "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" in price_text:
                    price_display = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ"
                else:
                    price_display = f"{min_price:.2f} ‚ÇΩ"
                
                # Compact button text (Telegram limit: 64 characters for button text)
                max_name_length = 20  # Shorter to fit price
                button_text = f"{model_emoji} {model_name}"
                if len(button_text) > max_name_length:
                    button_text = f"{model_emoji} {model_name[:max_name_length-4]}..."
                
                button_text_with_price = f"{button_text} ‚Ä¢ {price_display}"
                
                # Final check: Telegram button text limit is 64 characters
                if len(button_text_with_price) > 64:
                    max_total = 60  # Leave some margin
                    available_for_name = max_total - len(f" ‚Ä¢ {price_display}")
                    if available_for_name > 0:
                        button_text = f"{model_emoji} {model_name[:available_for_name-4]}..."
                        button_text_with_price = f"{button_text} ‚Ä¢ {price_display}"
                    else:
                        button_text_with_price = button_text[:60] + "..."
                
                # Ensure callback_data is not too long (Telegram limit: 64 bytes)
                callback_data = f"select_model:{model_id}"
                if len(callback_data.encode('utf-8')) > 64:
                    logger.error(f"Callback data too long for model {model_id}: {len(callback_data.encode('utf-8'))} bytes")
                    callback_data = f"sel:{model_id[:50]}"
                
                keyboard.append([InlineKeyboardButton(
                    button_text_with_price,
                    callback_data=callback_data
                )])
            user_lang = get_user_language(query.from_user.id)
            keyboard.append([InlineKeyboardButton(t('btn_back_to_categories', lang=user_lang), callback_data="show_models")])
            keyboard.append([InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")])
            
            # Premium formatted header
            category_emoji = {
                "–í–∏–¥–µ–æ": "üé¨",
                "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è": "üñºÔ∏è",
                "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ": "‚úèÔ∏è"
            }.get(category, "üìÅ")
            
            models_text = (
                f"‚ú® <b>–ü–†–ï–ú–ò–£–ú –ö–ê–¢–ê–õ–û–ì</b> ‚ú®\n\n"
                f"{category_emoji} <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}</b>\n"
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ –º–æ–¥–µ–ª–µ–π:</b> {len(models)}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <i>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ</i>\n"
                f"<i>–ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—Å—è –ø—Ä–∏ –≤—ã–±–æ—Ä–µ</i>"
            )
            
            await query.edit_message_text(
                models_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        if data == "free_tools":
            # Answer callback immediately
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for free_tools: {e}")
                pass
            
            logger.info(f"User {user_id} clicked 'free_tools' button")
            
            # Get free tools (models with price = 0)
            free_models = []
            for model in get_models_sync():
                model_id = model.get('id')
                # Check if model is free (price = 0)
                price = calculate_price_rub(model_id, {}, False, user_id)  # Use user price (x2)
                if price == 0.0:
                    free_models.append(model)
            
            if not free_models:
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    await query.edit_message_text(
                        "‚ùå <b>–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                        "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.",
                        parse_mode='HTML'
                    )
                else:
                    await query.edit_message_text(
                        "‚ùå <b>Free tools not found</b>\n\n"
                        "No free tools are currently available.",
                        parse_mode='HTML'
                    )
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            if user_lang == 'ru':
                free_tools_text = (
                    f"üÜì <b>–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>–í—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã!</b>\n\n"
                    f"ü§ñ <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ({len(free_models)}):</b>\n\n"
                    f"üí° <b>–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –Ω–∏–∂–µ</b>"
                )
            else:
                free_tools_text = (
                    f"üÜì <b>FREE TOOLS</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>All tools in this section are completely free!</b>\n\n"
                    f"ü§ñ <b>Available tools ({len(free_models)}):</b>\n\n"
                    f"üí° <b>Select a tool below</b>"
                )
            
            # Create keyboard with free models (2 per row)
            keyboard = []
            model_rows = []
            for i, model in enumerate(free_models):
                model_name = model.get('name', model.get('id', 'Unknown'))
                model_emoji = model.get('emoji', 'üÜì')
                model_id = model.get('id')
                
                # Compact button text
                max_name_length = 25
                button_text = f"{model_emoji} {model_name}"
                if len(button_text) > max_name_length:
                    button_text = f"{model_emoji} {model_name[:max_name_length-4]}..."
                
                # Ensure callback_data is not too long
                callback_data = f"select_model:{model_id}"
                if len(callback_data.encode('utf-8')) > 64:
                    logger.error(f"Callback data too long for model {model_id}: {len(callback_data.encode('utf-8'))} bytes")
                    callback_data = f"sel:{model_id[:50]}"
                
                if i % 2 == 0:
                    # First button in row
                    model_rows.append([InlineKeyboardButton(
                        button_text,
                        callback_data=callback_data
                    )])
                else:
                    # Second button in row
                    if model_rows:
                        model_rows[-1].append(InlineKeyboardButton(
                            button_text,
                            callback_data=callback_data
                        ))
                    else:
                        model_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=callback_data
                        )])
            
            keyboard.extend(model_rows)
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            try:
                await query.edit_message_text(
                    free_tools_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in free_tools: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        free_tools_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e2:
                    logger.error(f"Error sending new message in free_tools: {e2}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
            
            # Return SELECTING_MODEL state so that select_model: buttons work
            return SELECTING_MODEL
        
        if data == "show_models" or data == "all_models":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for show_models/all_models: {e}")
                pass
            
            logger.info(f"User {user_id} clicked 'show_models' or 'all_models' button (data: {data})")
            
            # Show generation types instead of all models with marketing text
            generation_types = get_generation_types()
            remaining_free = get_user_free_generations_remaining(user_id)
            
            models_text = (
                f"ü§ñ <b>–í–´–ë–ï–†–ò–¢–ï –ù–ï–ô–†–û–°–ï–¢–¨</b> ü§ñ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <b>–ö–ê–ö –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢:</b>\n"
                f"1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (—Ç–µ–∫—Å—Ç‚Üí—Ñ–æ—Ç–æ, —Ñ–æ—Ç–æ‚Üí–≤–∏–¥–µ–æ –∏ —Ç.–¥.)\n"
                f"2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞\n"
                f"3Ô∏è‚É£ –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç! üöÄ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if remaining_free > 0:
                models_text += (
                    f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–û:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image –¥–æ—Å—Ç—É–ø–Ω–æ!\n"
                    f"üí° –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                )
            
            models_text += (
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª–µ–π:</b> {len(get_models_sync())} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π"
            )
            
            keyboard = []
            
            # Free generation button - always show with count
            user_lang = get_user_language(user_id)
            if user_lang == 'ru':
                button_text = f"üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ ({remaining_free}/{FREE_GENERATIONS_PER_DAY} –æ—Å—Ç–∞–ª–æ—Å—å)"
            else:
                button_text = f"üéÅ Generate free ({remaining_free}/{FREE_GENERATIONS_PER_DAY} left)"
            keyboard.append([
                InlineKeyboardButton(button_text, callback_data="select_model:z-image")
            ])
            
            # Add referral button
            referral_link = get_user_referral_link(user_id)
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton(f"üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö!", callback_data="referral_info")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton(f"üéÅ Invite friend ‚Üí get +{REFERRAL_BONUS_GENERATIONS} free!", callback_data="referral_info")
                ])
            
            keyboard.append([])  # Empty row
            
            # Generation types buttons (2 per row for compact display)
            # Find text-to-image type and add it after free generation button
            text_to_image_type = None
            gen_type_rows = []
            gen_type_index = 0  # Separate index for non-text-to-image types
            
            for gen_type in generation_types:
                gen_info = get_generation_type_info(gen_type)
                models_count = len(get_models_by_generation_type(gen_type))
                
                # Skip if no models in this type
                if models_count == 0:
                    logger.warning(f"No models found for generation type: {gen_type}")
                    continue
                
                # Identify text-to-image type (will be added separately)
                if gen_type == 'text-to-image':
                    text_to_image_type = gen_type
                    continue
                
                # Get translated name for generation type
                gen_type_key = f'gen_type_{gen_type.replace("-", "_")}'
                gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', gen_type))
                button_text = f"{gen_type_name} ({models_count})"
                
                # Add buttons in pairs (2 per row)
                if gen_type_index % 2 == 0:
                    gen_type_rows.append([InlineKeyboardButton(
                        button_text,
                        callback_data=f"gen_type:{gen_type}"
                    )])
                else:
                    if gen_type_rows:
                        gen_type_rows[-1].append(InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        ))
                    else:
                        gen_type_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        )])
                
                gen_type_index += 1
            
            # Add text-to-image button after free generation (if it exists and has models)
            if text_to_image_type:
                gen_info = get_generation_type_info(text_to_image_type)
                models_count = len(get_models_by_generation_type(text_to_image_type))
                if models_count > 0:
                    gen_type_key = f'gen_type_{text_to_image_type.replace("-", "_")}'
                    gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', text_to_image_type))
                    button_text = f"{gen_type_name} ({models_count})"
                    keyboard.append([
                        InlineKeyboardButton(button_text, callback_data=f"gen_type:{text_to_image_type}")
                    ])
                    keyboard.append([])  # Empty row for spacing
            
            # Add other generation types
            keyboard.extend(gen_type_rows)
            
            # Add free tools button (always visible, prominent)
            keyboard.append([])  # Empty row for spacing
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton("üÜì –ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´", callback_data="free_tools")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton("üÜì FREE TOOLS", callback_data="free_tools")
                ])
            
            # Add button to show all models directly (without grouping by type)
            keyboard.append([])  # Empty row for spacing
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton(f"üìã –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ {len(get_models_sync())} –º–æ–¥–µ–ª–µ–π", callback_data="show_all_models_list")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton(f"üìã Show all {len(get_models_sync())} models", callback_data="show_all_models_list")
                ])
            
            user_lang = get_user_language(user_id)
            keyboard.append([
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
            
            try:
                await query.edit_message_text(
                    models_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in show_models: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        models_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return SELECTING_MODEL
        
        if data == "show_all_models_list":
            # Answer callback immediately
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for show_all_models_list: {e}")
                pass
            
            logger.info(f"User {user_id} clicked 'show_all_models_list' button")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            try:
                from app.helpers.models_menu_handlers import handle_show_all_models_list
                user_lang = get_user_language(user_id)
                await handle_show_all_models_list(query, user_id, user_lang)
                return SELECTING_MODEL
            except Exception as e:
                logger.error(f"Error in handle_show_all_models_list: {e}", exc_info=True)
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    error_msg = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                else:
                    error_msg = "‚ùå Error loading models. Please try later."
                await query.answer(error_msg, show_alert=True)
                return SELECTING_MODEL
            
            try:
                await query.edit_message_text(
                    models_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error showing all models: {e}", exc_info=True)
                await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
            
            return SELECTING_MODEL
        
        if data == "add_image":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            session = user_sessions.get(user_id, {})
            # Determine which parameter name to use (image_input or image_urls)
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            if 'image_urls' in input_params:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'
            session['waiting_for'] = image_param_name
            session['current_param'] = image_param_name
            if image_param_name not in session:
                session[image_param_name] = []  # Initialize as array
            
            await query.edit_message_text(
                "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                "–ú–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ 8 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
        
        if data == "image_done":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END
            session = user_sessions[user_id]
            waiting_for = session.get('waiting_for', 'image_input')
            # Normalize: if waiting_for is 'image', use the actual parameter name from properties
            if waiting_for == 'image':
                properties = session.get('properties', {})
                if 'image_input' in properties:
                    image_param_name = 'image_input'
                elif 'image_urls' in properties:
                    image_param_name = 'image_urls'
                else:
                    image_param_name = 'image_input'  # Default fallback
            else:
                image_param_name = waiting_for
            
            if image_param_name in session and session[image_param_name]:
                if 'params' not in session:
                    session['params'] = {}
                session['params'][image_param_name] = session[image_param_name]
                await query.edit_message_text(
                    f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(session[image_param_name])}\n\n"
                    f"–ü—Ä–æ–¥–æ–ª–∂–∞—é..."
                )
            session['waiting_for'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_free = is_free_generation_available(user_id, model_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if is_free:
                        price = 0.0
                    price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                    
                    # Prepare price info
                    if is_free:
                        remaining = get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                    
                    # Format improved confirmation message with price
                    if user_lang == 'ru':
                        confirm_msg = (
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                            f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                            f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                            f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                        )
                    else:
                        price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                        confirm_msg = (
                            f"üìã <b>Generation Confirmation</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info_en}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>What's next:</b>\n"
                            f"‚Ä¢ Generation will start after confirmation\n"
                            f"‚Ä¢ Result will come automatically\n"
                            f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                            f"üöÄ <b>Ready to start?</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after image done: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS
        
        if data == "add_audio":
            # User wants to add audio file
            await query.answer()
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions.get(user_id, {})
            if not session:
                user_lang = get_user_language(query.from_user.id)
                await query.edit_message_text(t('error_session_empty', lang=user_lang))
                return ConversationHandler.END
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            
            audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
            user_lang = get_user_language(query.from_user.id)
            
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton(t('btn_skip', lang=user_lang), callback_data="skip_audio")]
            ]
            
            await query.edit_message_text(
                "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏.\n\n"
                "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG\n"
                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            
            session['waiting_for'] = audio_param_name
            session['current_param'] = audio_param_name
            return INPUTTING_PARAMS
        
        if data == "skip_audio":
            # User wants to skip audio upload
            await query.answer("–ê—É–¥–∏–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_free = is_free_generation_available(user_id, model_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if is_free:
                        price = 0.0
                    price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                    
                    # Prepare price info
                    if is_free:
                        remaining = get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                    
                    # Format improved confirmation message with price
                    if user_lang == 'ru':
                        confirm_msg = (
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                            f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                            f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                            f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                        )
                    else:
                        price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                        confirm_msg = (
                            f"üìã <b>Generation Confirmation</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info_en}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>What's next:</b>\n"
                            f"‚Ä¢ Generation will start after confirmation\n"
                            f"‚Ä¢ Result will come automatically\n"
                            f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                            f"üöÄ <b>Ready to start?</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping audio: {e}", exc_info=True)
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
        
        if data == "skip_image":
            await query.answer("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    if user_id not in user_sessions:
                        await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                        return ConversationHandler.END
                    session = user_sessions[user_id]
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                
                await query.edit_message_text(
                    f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                    f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                    f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping image: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS
        
        if data.startswith("set_param:"):
            # Handle parameter setting via button
            parts = data.split(":", 2)
            if len(parts) == 3:
                param_name = parts[1]
                param_value = parts[2]
                
                if user_id not in user_sessions:
                    await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                    return ConversationHandler.END
                
                session = user_sessions[user_id]
                properties = session.get('properties', {})
                param_info = properties.get(param_name, {})
                param_type = param_info.get('type', 'string')
                
                # üî¥ –í–ê–õ–ò–î–ê–¶–ò–Ø ENUM –ó–ù–ê–ß–ï–ù–ò–ô: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö
                enum_values = param_info.get('enum')
                if enum_values and param_value not in enum_values:
                    # –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ enum –∑–Ω–∞—á–µ–Ω–∏–µ
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_text = (
                        f"‚ùå <b>–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ</b>\n\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(enum_values)}\n"
                        f"–í–≤–µ–¥–µ–Ω–æ: {param_value}"
                    ) if user_lang == 'ru' else (
                        f"‚ùå <b>Invalid value</b>\n\n"
                        f"Allowed values: {', '.join(enum_values)}\n"
                        f"Entered: {param_value}"
                    )
                    await query.answer(error_text, show_alert=True)
                    return ConversationHandler.END
                
                # Convert boolean string to actual boolean
                if param_type == 'boolean':
                    if param_value.lower() == 'true':
                        param_value = True
                    elif param_value.lower() == 'false':
                        param_value = False
                    else:
                        # Use default if invalid
                        param_value = param_info.get('default', True)
                
                if 'params' not in session:
                    session['params'] = {}
                session['params'][param_name] = param_value
                session['current_param'] = None
                
                # Check if there are more parameters
                required = session.get('required', [])
                params = session.get('params', {})
                missing = [p for p in required if p not in params]
                
                if missing:
                    await query.edit_message_text(f"‚úÖ {param_name} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {param_value}")
                    # Move to next parameter
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                    except Exception as e:
                        logger.error(f"Error starting next parameter: {e}")
                        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                        return INPUTTING_PARAMS
                else:
                    # All parameters collected
                    # Get model_id from session (CRITICAL: must be defined before use)
                    model_id = session.get('model_id', '')
                    if not model_id:
                        logger.error(f"‚ùå model_id not found in session for user_id={user_id}")
                        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–µ—Å—Å–∏–∏.")
                        return ConversationHandler.END
                    
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {v}" for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_free = is_free_generation_available(user_id, model_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if is_free:
                        price = 0.0
                    price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                    
                    # Prepare price info
                    if is_free:
                        remaining = get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                    
                    # Format improved confirmation message with price
                    if user_lang == 'ru':
                        confirm_msg = (
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                            f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                            f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                            f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                        )
                    else:
                        price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                        confirm_msg = (
                            f"üìã <b>Generation Confirmation</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info_en}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>What's next:</b>\n"
                            f"‚Ä¢ Generation will start after confirmation\n"
                            f"‚Ä¢ Result will come automatically\n"
                            f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                            f"üöÄ <b>Ready to start?</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
        
        # Handle back to previous step
        if data == "back_to_previous_step":
            await query.answer("‚óÄÔ∏è –í–æ–∑–≤—Ä–∞—â–∞—é—Å—å –Ω–∞–∑–∞–¥...")
            user_lang = get_user_language(user_id)
            
            if user_id not in user_sessions:
                await query.edit_message_text(
                    t('error_try_start', lang=user_lang),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            current_param = session.get('current_param')
            waiting_for = session.get('waiting_for')
            
            # Show helpful message about going back
            model_name = session.get('model_info', {}).get('name', 'Unknown')
            if user_lang == 'ru':
                back_msg = (
                    f"‚óÄÔ∏è <b>–í–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —à–∞–≥—É</b>\n\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                    f"üí° –í—ã –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–ª–∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ."
                )
            else:
                back_msg = (
                    f"‚óÄÔ∏è <b>Going back to previous step</b>\n\n"
                    f"ü§ñ <b>Model:</b> {model_name}\n\n"
                    f"üí° You can change parameters or start over."
                )
            
            # If we're waiting for a parameter, clear it and go back
            if waiting_for:
                session['waiting_for'] = None
                session['current_param'] = None
            
            # Try to go back to previous parameter or model selection
            try:
                # If we have params, remove the last one and restart
                params = session.get('params', {})
                if params:
                    # Remove last parameter (simple approach - remove current_param if set)
                    if current_param and current_param in params:
                        del params[current_param]
                        session['params'] = params
                
                # Restart parameter collection from beginning
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # If no more parameters, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_free = is_free_generation_available(user_id, model_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if is_free:
                        price = 0.0
                    price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                    
                    # Prepare price info
                    if is_free:
                        remaining = get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                    
                    # Format improved confirmation message with price
                    if user_lang == 'ru':
                        confirm_msg = (
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                            f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                            f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                            f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                        )
                    else:
                        price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                        confirm_msg = (
                            f"üìã <b>Generation Confirmation</b>\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_name}\n\n"
                            f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{price_info_en}\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"üí° <b>What's next:</b>\n"
                            f"‚Ä¢ Generation will start after confirmation\n"
                            f"‚Ä¢ Result will come automatically\n"
                            f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                            f"üöÄ <b>Ready to start?</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error in back_to_previous_step: {e}", exc_info=True)
                # Fallback: return to model selection
                await query.edit_message_text(
                    t('error_try_start', lang=user_lang),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "check_balance":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Check user's personal balance (–∏—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
            try:
                user_lang = get_user_language(user_id)
                balance_info = await get_balance_info(user_id, user_lang)
                balance_text = await format_balance_message(balance_info, user_lang)
                keyboard = get_balance_keyboard(balance_info, user_lang)
                
                try:
                    await query.edit_message_text(
                        balance_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in check_balance: {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            balance_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
            except Exception as e:
                logger.error(f"Error in check_balance: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –±–∞–ª–∞–Ω—Å–∞", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        if data == "topup_balance":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Check if user is blocked
            if is_user_blocked(user_id):
                await query.edit_message_text(
                    "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
                    "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get payment details to show immediately
            payment_details = get_payment_details()
            user_lang = get_user_language(user_id)
            
            # Show amount selection - focus on small amounts with marketing
            keyboard = [
                [
                    InlineKeyboardButton("üíé 50 ‚ÇΩ", callback_data="topup_amount:50"),
                    InlineKeyboardButton("üíé 100 ‚ÇΩ", callback_data="topup_amount:100"),
                    InlineKeyboardButton("üíé 150 ‚ÇΩ", callback_data="topup_amount:150")
                ],
                [
                    InlineKeyboardButton(t('btn_custom_amount', lang=user_lang), callback_data="topup_custom")
                ],
                [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            current_balance = await get_user_balance_async(user_id)
            balance_str = f"{current_balance:.2f}".rstrip('0').rstrip('.')
            
            await query.edit_message_text(
                f'üí≥ <b>–ü–û–ü–û–õ–ù–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê</b> üí≥\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí∞ <b>–¢–≤–æ–π —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{payment_details}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 0.5 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üöÄ <b>–í–´–ë–ï–†–ò –°–£–ú–ú–£:</b>\n'
                f'‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                f'‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏ —Å–≤–æ—é —Å—É–º–º—É\n\n'
                f'üìù <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'–ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ | –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ',
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        if data.startswith("topup_amount:"):
            # User selected a preset amount
            parts = data.split(":", 1)
            if len(parts) < 2:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã", show_alert=True)
                return ConversationHandler.END
            try:
                amount = float(parts[1])
            except (ValueError, TypeError):
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞", show_alert=True)
                return ConversationHandler.END
            user_lang = get_user_language(user_id)
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–í–´–ë–ï–†–ò –°–ü–û–°–û–ë –û–ü–õ–ê–¢–´:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>CHOOSE PAYMENT METHOD:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            # For English users - only Telegram Stars, no SBP
            if user_lang == 'en':
                keyboard = [
                    [InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}")],
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
            else:
                # For Russian users - both options
                keyboard = [
                    [
                        InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}"),
                        InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")
                    ],
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
            
            await query.edit_message_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        # Handle payment method selection
        if data.startswith("pay_stars:"):
            # User chose Telegram Stars payment
            parts = data.split(":", 1)
            if len(parts) < 2:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã", show_alert=True)
                return ConversationHandler.END
            try:
                amount = float(parts[1])
            except (ValueError, TypeError):
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞", show_alert=True)
                return ConversationHandler.END
            user_lang = get_user_language(user_id)
            
            # Convert rubles to stars using exchange rate 1.6
            # 1 ruble = 1.6 stars
            # Telegram Stars are integers, so we round to nearest integer
            stars_amount = int(round(amount * 1.6))
            
            if stars_amount < 1:
                stars_amount = 1  # Minimum 1 star
            
            try:
                # Create invoice for Telegram Stars
                # Note: Invoice prices are in XTR (XTR is the currency for Telegram Stars)
                # 1 XTR = 1 Star
                from telegram import LabeledPrice
                
                invoice_text_ru = f"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –Ω–∞ {amount:.2f} ‚ÇΩ"
                invoice_text_en = f"Balance top-up for {amount:.2f} ‚ÇΩ"
                invoice_text = invoice_text_ru if user_lang == 'ru' else invoice_text_en
                
                # Store payment info in session
                user_sessions[user_id] = {
                    'topup_amount': amount,
                    'payment_method': 'stars',
                    'stars_amount': stars_amount,
                    'invoice_payload': f"topup_{user_id}_{int(time.time())}"
                }
                
                # Send invoice directly (Telegram Stars payment)
                # Note: provider_token is not needed for Telegram Stars (use empty string or None)
                await context.bot.send_invoice(
                    chat_id=query.message.chat_id,
                    title=invoice_text,
                    description=invoice_text,
                    payload=f"topup_{user_id}_{int(time.time())}",
                    provider_token="",  # Empty for Telegram Stars
                    currency="XTR",  # XTR is the currency code for Telegram Stars
                    prices=[LabeledPrice(invoice_text, stars_amount)],
                )
                
                invoice = None  # Will be sent as message
                
                # Invoice is sent directly, just answer the query
                await query.answer()
                if user_lang == 'ru':
                    await query.edit_message_text(
                        f'‚≠ê <b>–û–ü–õ–ê–¢–ê –ß–ï–†–ï–ó TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>–°—É–º–º–∞:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>–°—á–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—ã—à–µ. –û–ø–ª–∞—Ç–∏—Ç–µ —á–µ—Ä–µ–∑ Telegram Stars.</b>'
                    )
                else:
                    await query.edit_message_text(
                        f'‚≠ê <b>PAYMENT VIA TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>Amount:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>Invoice sent above. Pay via Telegram Stars.</b>'
                    )
                    
            except Exception as e:
                logger.error(f"Error creating Stars invoice: {e}", exc_info=True)
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
                else:
                    await query.answer("Error creating invoice. Please try later.", show_alert=True)
            
            return SELECTING_AMOUNT
        
        if data.startswith("pay_sbp:"):
            # User chose SBP payment
            parts = data.split(":", 1)
            if len(parts) < 2:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã", show_alert=True)
                return ConversationHandler.END
            try:
                amount = float(parts[1])
            except (ValueError, TypeError):
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞", show_alert=True)
                return ConversationHandler.END
            user_lang = get_user_language(user_id)
            
            # English users can only pay via Telegram Stars
            if user_lang == 'en':
                # Redirect to Stars payment
                await query.answer("For English users, only Telegram Stars payment is available.", show_alert=True)
                # Trigger Stars payment instead
                # Convert rubles to stars using exchange rate 1.6
                # 1 ruble = 1.6 stars
                stars_amount = int(round(amount * 1.6))
                if stars_amount < 1:
                    stars_amount = 1
                
                try:
                    from telegram import LabeledPrice
                    invoice_text = f"Balance top-up for {amount:.2f} ‚ÇΩ"
                    
                    user_sessions[user_id] = {
                        'topup_amount': amount,
                        'payment_method': 'stars',
                        'stars_amount': stars_amount,
                        'invoice_payload': f"topup_{user_id}_{int(time.time())}"
                    }
                    
                    await context.bot.send_invoice(
                        chat_id=query.message.chat_id,
                        title=invoice_text,
                        description=invoice_text,
                        payload=f"topup_{user_id}_{int(time.time())}",
                        provider_token="",
                        currency="XTR",
                        prices=[LabeledPrice(invoice_text, stars_amount)],
                    )
                    
                    await query.edit_message_text(
                        f'‚≠ê <b>PAYMENT VIA TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>Amount:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>Invoice sent above. Pay via Telegram Stars.</b>'
                    )
                except Exception as e:
                    logger.error(f"Error creating Stars invoice: {e}", exc_info=True)
                    await query.answer("Error creating invoice. Please try later.", show_alert=True)
                
                return SELECTING_AMOUNT
            
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_screenshot',
                'payment_method': 'sbp'
            }
            
            payment_details = get_payment_details()
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            keyboard = [
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            
            if user_lang == 'ru':
                sbp_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ (–°–ë–ü)</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{payment_details}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üì∏ <b>–ö–ê–ö –û–ü–õ–ê–¢–ò–¢–¨:</b>\n'
                    f'1Ô∏è‚É£ –ü–µ—Ä–µ–≤–µ–¥–∏ {amount:.2f} ‚ÇΩ –ø–æ —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º –≤—ã—à–µ\n'
                    f'2Ô∏è‚É£ –°–¥–µ–ª–∞–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞\n'
                    f'3Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Å—é–¥–∞\n'
                    f'4Ô∏è‚É£ –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏! ‚ö°\n\n'
                    f'‚úÖ <b>–í—Å–µ –ø—Ä–æ—Å—Ç–æ –∏ –±—ã—Å—Ç—Ä–æ!</b>'
                )
            else:
                sbp_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ (SBP)</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{payment_details}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üì∏ <b>HOW TO PAY:</b>\n'
                    f'1Ô∏è‚É£ Transfer {amount:.2f} ‚ÇΩ using details above\n'
                    f'2Ô∏è‚É£ Take a screenshot of the transfer\n'
                    f'3Ô∏è‚É£ Send screenshot here\n'
                    f'4Ô∏è‚É£ Balance will be added automatically! ‚ö°\n\n'
                    f'‚úÖ <b>Simple and fast!</b>'
                )
            
            await query.edit_message_text(
                sbp_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return WAITING_PAYMENT_SCREENSHOT
        
        if data == "topup_custom":
            # User wants to enter custom amount
            await query.edit_message_text(
                f'üí∞ <b>–í–í–ï–î–ò –°–í–û–Æ –°–£–ú–ú–£</b> üí∞\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìù <b>–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å —á–∏—Å–ª–æ</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 0.5 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìã <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'‚Ä¢ –ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ\n'
                f'‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ\n\n'
                f'üí¨ <b>–û—Ç–ø—Ä–∞–≤—å —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'topup_amount_input'
            }
            return SELECTING_AMOUNT
        
        # Admin functions (only for admin)
        if user_id == ADMIN_ID:
            if data == "admin_stats":
                # Answer callback immediately
                try:
                    await query.answer()
                except:
                    pass
                
                # Show full admin panel menu with extended statistics
                generation_types = get_generation_types()
                total_models = len(get_models_sync())
                
                # Get extended statistics
                stats = get_extended_admin_stats()
                
                # Get KIE API balance (for admin info only)
                kie_balance_info = ""
                try:
                    balance_result = await kie.get_credits()
                    if balance_result.get('ok'):
                        balance = balance_result.get('credits', 0)
                        balance_rub = balance * CREDIT_TO_USD * get_usd_to_rub_rate()
                        balance_rub_str = f"{balance_rub:.2f}".rstrip('0').rstrip('.')
                        kie_balance_info = f"üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> {balance_rub_str} ‚ÇΩ ({balance} –∫—Ä–µ–¥–∏—Ç–æ–≤)\n\n"
                except Exception as e:
                    logger.error(f"Error getting KIE balance: {e}")
                    kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω\n\n"
                
                # Format top models
                top_models_text = ""
                if stats['top_models']:
                    top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b>\n"
                    for i, model in enumerate(stats['top_models'], 1):
                        top_models_text += f"{i}. {model['name']}: {model['count']} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
                    top_models_text += "\n"
                else:
                    top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b> –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö\n\n"
                
                admin_text = (
                    f'üëë <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> üëë\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{kie_balance_info}'
                    f'üìä <b>–†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n\n'
                    f'üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ: <b>{stats["total_users"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <b>{stats["active_today"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{stats["active_week"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –º–µ—Å—è—Ü: <b>{stats["active_month"]}</b>\n\n'
                    f'üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: <b>{stats["total_generations"]}</b>\n'
                    f'{top_models_text}'
                    f'üí∞ <b>–§–∏–Ω–∞–Ω—Å—ã:</b>\n'
                    f'   ‚Ä¢ –û–±—â–∏–π –¥–æ—Ö–æ–¥: <b>{stats["total_revenue"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ —Å–µ–≥–æ–¥–Ω—è: <b>{stats["revenue_today"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{stats["revenue_week"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –º–µ—Å—è—Ü: <b>{stats["revenue_month"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ –ø–ª–∞—Ç–µ–∂–µ–π: <b>{stats["total_payments"]}</b>\n'
                    f'   ‚Ä¢ –°—Ä–µ–¥–Ω–∏–π —á–µ–∫: <b>{stats["avg_check"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –æ–ø–ª–∞—Ç—É: <b>{stats["conversion_rate"]:.1f}%</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üìä <b>–°–ò–°–¢–ï–ú–ê:</b>\n\n'
                    f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
                    f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –§–£–ù–ö–¶–ò–ò:</b>\n\n'
                    f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
                    f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
                    f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
                    f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí´ <b>–í–´–ë–ï–†–ò–¢–ï –î–ï–ô–°–¢–í–ò–ï:</b>'
                )
                
                keyboard = [
                    [InlineKeyboardButton("üìä –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É", callback_data="admin_stats")],
                    [InlineKeyboardButton("üìö –ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π", callback_data="admin_view_generations")],
                    [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")],
                    [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search")],
                    [InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")],
                    [InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    admin_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Handle payment screenshots viewing
            if data == "view_payment_screenshots":
                await query.answer()
                
                # Get all payments with screenshots
                payments = get_all_payments()
                payments_with_screenshots = [p for p in payments if p.get('screenshot_file_id')]
                
                if not payments_with_screenshots:
                    await query.edit_message_text(
                        "üì∏ <b>–°–∫—Ä–∏–Ω—à–æ—Ç—ã –ø–ª–∞—Ç–µ–∂–µ–π</b>\n\n"
                        "–ù–µ—Ç –ø–ª–∞—Ç–µ–∂–µ–π —Å–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞–º–∏.",
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
                
                # Show first payment screenshot
                first_payment = payments_with_screenshots[0]
                payment_index = 0
                
                # Store current index in context for navigation
                context.user_data['payment_screenshot_index'] = 0
                context.user_data['payment_screenshots_list'] = [p.get('id') for p in payments_with_screenshots]
                
                await show_payment_screenshot(query, first_payment, payment_index, len(payments_with_screenshots))
                return ConversationHandler.END
            
            # Handle navigation between payment screenshots
            if data.startswith("payment_screenshot_nav:"):
                await query.answer()
                
                parts = data.split(":")
                if len(parts) < 2:
                    await query.answer("–û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏", show_alert=True)
                    return ConversationHandler.END
                
                direction = parts[1]  # "prev" or "next"
                current_index = context.user_data.get('payment_screenshot_index', 0)
                payment_ids = context.user_data.get('payment_screenshots_list', [])
                
                if not payment_ids:
                    await query.answer("–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                    return ConversationHandler.END
                
                # Navigate
                if direction == "prev":
                    current_index = (current_index - 1) % len(payment_ids)
                elif direction == "next":
                    current_index = (current_index + 1) % len(payment_ids)
                else:
                    await query.answer("–ù–µ–≤–µ—Ä–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", show_alert=True)
                    return ConversationHandler.END
                
                context.user_data['payment_screenshot_index'] = current_index
                
                # Get payment by ID
                payment_id = payment_ids[current_index]
                payments = get_all_payments()
                payment = next((p for p in payments if p.get('id') == payment_id), None)
                
                if not payment:
                    await query.answer("–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                    return ConversationHandler.END
                
                await show_payment_screenshot(query, payment, current_index, len(payment_ids))
                return ConversationHandler.END
            
            # Handle back to payments list
            if data == "admin_payments_back":
                await query.answer()
                await show_admin_payments(query, context, is_callback=True)
                return ConversationHandler.END
        
        # Handle admin view all generations
        if data == "admin_view_generations":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É." if get_user_language(user_id) == 'ru' else "This function is available only to administrator.")
                return ConversationHandler.END
            
            await query.answer()
            user_lang = get_user_language(user_id)
            
            # Load all generations from all users
            history = load_json_file(GENERATIONS_HISTORY_FILE, {})
            
            if not history:
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                        "‚ùå –í —Å–∏—Å—Ç–µ–º–µ –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n\n"
                        "üí° –ì–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –∏—Ö —Å–æ–∑–¥–∞–Ω–∏—è."
                    )
                else:
                    message_text = (
                        "üìö <b>View Generations</b>\n\n"
                        "‚ùå No saved generations in the system yet.\n\n"
                        "üí° User generations will appear here after they are created."
                    )
                
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                ]
                await query.edit_message_text(
                    message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Collect all generations with user info
            all_generations = []
            for user_key, user_history in history.items():
                try:
                    user_id_int = int(user_key) if user_key.isdigit() else None
                    if user_id_int:
                        for gen in user_history:
                            gen_with_user = gen.copy()
                            gen_with_user['user_id'] = user_id_int
                            all_generations.append(gen_with_user)
                except (ValueError, TypeError):
                    continue
            
            # Sort by timestamp (newest first)
            all_generations.sort(key=lambda x: x.get('timestamp', 0), reverse=True)
            
            if not all_generations:
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                        "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                else:
                    message_text = (
                        "üìö <b>View Generations</b>\n\n"
                        "‚ùå No generations found to display."
                    )
                
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                ]
                await query.edit_message_text(
                    message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Store in context for navigation
            context.user_data['admin_generations_list'] = all_generations
            context.user_data['admin_generation_index'] = 0
            
            # Show first generation
            await show_admin_generation(query, context, all_generations[0], 0, len(all_generations))
            return ConversationHandler.END
        
        # Handle admin generation navigation
        if data.startswith("admin_gen_nav:"):
            if user_id != ADMIN_ID:
                await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            await query.answer()
            parts = data.split(":")
            if len(parts) < 2:
                return ConversationHandler.END
            
            direction = parts[1]  # "prev" or "next"
            all_generations = context.user_data.get('admin_generations_list', [])
            current_index = context.user_data.get('admin_generation_index', 0)
            
            if not all_generations:
                await query.answer("–°–ø–∏—Å–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            # Navigate
            if direction == "prev":
                current_index = (current_index - 1) % len(all_generations)
            elif direction == "next":
                current_index = (current_index + 1) % len(all_generations)
            else:
                return ConversationHandler.END
            
            context.user_data['admin_generation_index'] = current_index
            gen = all_generations[current_index]
            
            await show_admin_generation(query, context, gen, current_index, len(all_generations))
            return ConversationHandler.END
        
        # Handle admin view generation result
        if data.startswith("admin_gen_view:"):
            if user_id != ADMIN_ID:
                await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            await query.answer()
            parts = data.split(":")
            if len(parts) < 2:
                return ConversationHandler.END
            
            try:
                gen_index = int(parts[1])
            except (ValueError, TypeError):
                return ConversationHandler.END
            
            all_generations = context.user_data.get('admin_generations_list', [])
            if gen_index < 0 or gen_index >= len(all_generations):
                await query.answer("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            gen = all_generations[gen_index]
            result_urls = gen.get('result_urls', [])
            
            if not result_urls:
                await query.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
                return ConversationHandler.END
            
            # Send media
            user_lang = get_user_language(user_id)
            session_http = await get_http_client()
            for i, url in enumerate(result_urls[:5]):
                try:
                    async with session_http.get(url) as resp:
                        if resp.status == 200:
                            media_data = await resp.read()
                            
                            is_last = (i == len(result_urls[:5]) - 1)
                            is_video = gen.get('model_id', '') in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard']
                            
                            keyboard = []
                            if is_last:
                                keyboard = [
                                    [InlineKeyboardButton(t('btn_back_to_list', lang=user_lang), callback_data="admin_view_generations")],
                                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                                ]
                            
                            if is_video:
                                video_file = io.BytesIO(media_data)
                                video_file.name = f"generated_video_{i+1}.mp4"
                                await context.bot.send_video(
                                    chat_id=query.message.chat_id,
                                    video=video_file,
                                    reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                )
                            else:
                                photo_file = io.BytesIO(media_data)
                                photo_file.name = f"generated_image_{i+1}.png"
                                await context.bot.send_photo(
                                    chat_id=query.message.chat_id,
                                    photo=photo_file,
                                    reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                )
                except Exception as e:
                    logger.error(f"Error sending admin generation result: {e}")
            
            await query.answer("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
            return ConversationHandler.END
        
        if data == "admin_settings":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É." if get_user_language(user_id) == 'ru' else "This function is available only to administrator.")
                return ConversationHandler.END
            
            # Get user language
            user_lang = get_user_language(user_id)
            
            # Get support contact info
            support_telegram = os.getenv('SUPPORT_TELEGRAM', '–ù–µ —É–∫–∞–∑–∞–Ω–æ' if user_lang == 'ru' else 'Not specified')
            
            if user_lang == 'ru':
                settings_text = (
                    f'‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n'
                    f'üîß <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n\n'
                    f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                    f'‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n'
                    f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API\n\n'
                    f'üí° <b>–ö–æ–º–∞–Ω–¥—ã:</b>\n'
                    f'/models - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                    f'/balance - –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞\n'
                    f'/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                    f'/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                    f'/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                    f'/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                    f'/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                    f'/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n'
                    f'üí¨ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>\n\n'
                    f'üí¨ Telegram: {support_telegram if support_telegram != "–ù–µ —É–∫–∞–∑–∞–Ω–æ" else "–ù–µ —É–∫–∞–∑–∞–Ω–æ"}\n\n'
                    f'üí° –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª .env'
                )
            else:
                settings_text = (
                    f'‚öôÔ∏è <b>Administrator Settings:</b>\n\n'
                    f'üîß <b>Available Functions:</b>\n\n'
                    f'‚úÖ Model Management\n'
                    f'‚úÖ View Statistics\n'
                    f'‚úÖ User Management\n'
                    f'‚úÖ API Settings\n\n'
                    f'üí° <b>Commands:</b>\n'
                    f'/models - Model Management\n'
                    f'/balance - Check Balance\n'
                    f'/search - Search Knowledge Base\n'
                    f'/add - Add Knowledge\n'
                    f'/payments - View Payments\n'
                    f'/block_user - Block User\n'
                    f'/unblock_user - Unblock User\n'
                    f'/user_balance - User Balance\n\n'
                    f'üí¨ <b>Support Settings:</b>\n\n'
                    f'üí¨ Telegram: {support_telegram if support_telegram != "Not specified" else "Not specified"}\n\n'
                    f'üí° To change support settings, edit the .env file'
                )
            
            # Get current exchange rate
            current_rate = get_usd_to_rub_rate()
            
            if user_lang == 'ru':
                settings_text += f'\nüí± <b>–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã:</b>\n'
                settings_text += f'1 USD = {current_rate:.2f} RUB\n\n'
                keyboard = [
                    [InlineKeyboardButton("üåê –Ø–∑—ã–∫ / Language", callback_data="change_language")],
                    [InlineKeyboardButton("üí± –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫—É—Ä—Å –≤–∞–ª—é—Ç—ã", callback_data="admin_set_currency_rate")],
                    [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")],
                    [InlineKeyboardButton("üéÅ –ü—Ä–æ–º–æ–∫–æ–¥—ã", callback_data="admin_promocodes")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_back_to_admin")]
                ]
            else:
                settings_text += f'\nüí± <b>Exchange Rate:</b>\n'
                settings_text += f'1 USD = {current_rate:.2f} RUB\n\n'
                keyboard = [
                    [InlineKeyboardButton("üåê Language / –Ø–∑—ã–∫", callback_data="change_language")],
                    [InlineKeyboardButton("üí± Set Exchange Rate", callback_data="admin_set_currency_rate")],
                    [InlineKeyboardButton("üì¢ Broadcast", callback_data="admin_broadcast")],
                    [InlineKeyboardButton("üéÅ Promocodes", callback_data="admin_promocodes")],
                    [InlineKeyboardButton("‚óÄÔ∏è Back", callback_data="admin_back_to_admin")]
                ]
            
            await query.edit_message_text(
                settings_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_promocodes":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show promocodes menu
            promocodes = load_promocodes()
            active_promo = get_active_promocode()
            
            promocodes_text = "üéÅ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏</b>\n\n"
            
            if active_promo:
                promo_code = active_promo.get('code', 'N/A')
                promo_value = active_promo.get('value', 0)
                promo_expires = active_promo.get('expires', 'N/A')
                promo_used = active_promo.get('used_count', 0)
                
                promocodes_text += (
                    f"‚úÖ <b>–ê–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥:</b>\n"
                    f"üîë <b>–ö–æ–¥:</b> <code>{promo_code}</code>\n"
                    f"üí∞ <b>–ó–Ω–∞—á–µ–Ω–∏–µ:</b> {promo_value} ‚ÇΩ\n"
                    f"üìÖ <b>–î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –¥–æ:</b> {promo_expires}\n"
                    f"üë• <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ä–∞–∑:</b> {promo_used}\n\n"
                )
            else:
                promocodes_text += "‚ùå <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞</b>\n\n"
            
            # Show all promocodes
            if promocodes:
                promocodes_text += f"üìã <b>–í—Å–µ –ø—Ä–æ–º–æ–∫–æ–¥—ã ({len(promocodes)}):</b>\n\n"
                for i, promo in enumerate(promocodes, 1):
                    promo_code = promo.get('code', 'N/A')
                    promo_value = promo.get('value', 0)
                    promo_expires = promo.get('expires', 'N/A')
                    promo_used = promo.get('used_count', 0)
                    is_active = promo.get('active', False)
                    
                    status = "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω" if is_active else "‚ùå –ù–µ–∞–∫—Ç–∏–≤–µ–Ω"
                    
                    promocodes_text += (
                        f"{i}. <b>{status}</b>\n"
                        f"   üîë <code>{promo_code}</code>\n"
                        f"   üí∞ {promo_value} ‚ÇΩ | üë• {promo_used} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
                        f"   üìÖ –î–æ: {promo_expires}\n\n"
                    )
            else:
                promocodes_text += "üìã <b>–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤</b>\n\n"
            
            promocodes_text += "üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:</b>\n"
            promocodes_text += "‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n"
            promocodes_text += "‚Ä¢ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω–æ–º –ø—Ä–æ–º–æ–∫–æ–¥–µ\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_promocodes")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                promocodes_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_broadcast":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show broadcast menu
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            broadcast_text = "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
            broadcast_text += f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n\n"
            
            if broadcasts:
                broadcast_text += f"üìã <b>–ò—Å—Ç–æ—Ä–∏—è —Ä–∞—Å—Å—ã–ª–æ–∫ ({len(broadcasts)}):</b>\n\n"
                # Show last 5 broadcasts
                sorted_broadcasts = sorted(
                    broadcasts.items(),
                    key=lambda x: x[1].get('created_at', 0),
                    reverse=True
                )[:5]
                
                for broadcast_id, broadcast in sorted_broadcasts:
                    created_at = broadcast.get('created_at', 0)
                    sent = broadcast.get('sent', 0)
                    delivered = broadcast.get('delivered', 0)
                    failed = broadcast.get('failed', 0)
                    message_preview = broadcast.get('message', '')[:30] + '...' if len(broadcast.get('message', '')) > 30 else broadcast.get('message', '')
                    
                    from datetime import datetime
                    if created_at:
                        date_str = datetime.fromtimestamp(created_at).strftime('%Y-%m-%d %H:%M')
                    else:
                        date_str = 'N/A'
                    
                    broadcast_text += (
                        f"üì® <b>#{broadcast_id}</b> ({date_str})\n"
                        f"   üìù {message_preview}\n"
                        f"   ‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent} | üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered} | ‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    )
            else:
                broadcast_text += "üìã <b>–ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
            
            broadcast_text += "üí° <b>–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ä–∞—Å—Å—ã–ª–∫—É:</b>\n"
            broadcast_text += "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏."
            
            keyboard = [
                [InlineKeyboardButton("üì¢ –°–æ–∑–¥–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É", callback_data="admin_create_broadcast")],
                [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                broadcast_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_create_broadcast":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Start broadcast creation
            await query.edit_message_text(
                "üì¢ <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n\n"
                "üí° <b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:</b>\n"
                "‚Ä¢ –¢–µ–∫—Å—Ç\n"
                "‚Ä¢ HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n"
                "‚Ä¢ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'broadcast_message'
            }
            return WAITING_BROADCAST_MESSAGE
        
        if data == "admin_set_currency_rate":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Get current exchange rate
            current_rate = get_usd_to_rub_rate()
            
            currency_text = (
                f'üí± <b>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã</b>\n\n'
                f'üìä <b>–¢–µ–∫—É—â–∏–π –∫—É—Ä—Å:</b>\n'
                f'1 USD = {current_rate:.2f} RUB\n\n'
                f'üí° <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>\n'
                f'–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã.\n'
                f'–ù–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> (–æ–∑–Ω–∞—á–∞–µ—Ç 1 USD = 100 RUB)\n\n'
                f'‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>\n'
                f'‚Ä¢ –ö—É—Ä—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º\n'
                f'‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É –¥–ª—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä: 95.5)\n'
                f'‚Ä¢ –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Å–µ —Ü–µ–Ω—ã –±—É–¥—É—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n\n'
                f'–î–ª—è –æ—Ç–º–µ–Ω—ã –Ω–∞–∂–º–∏—Ç–µ /cancel'
            )
            
            await query.edit_message_text(
                currency_text,
                parse_mode='HTML'
            )
            
            # Set session to wait for currency rate
            user_sessions[user_id] = {
                'waiting_for': 'currency_rate'
            }
            return WAITING_CURRENCY_RATE
        
        if data == "admin_broadcast_stats":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show detailed broadcast statistics
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            if not broadcasts:
                await query.edit_message_text(
                    "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                    "‚ùå –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
                    ]),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Calculate totals
            total_sent = sum(b.get('sent', 0) for b in broadcasts.values())
            total_delivered = sum(b.get('delivered', 0) for b in broadcasts.values())
            total_failed = sum(b.get('failed', 0) for b in broadcasts.values())
            
            stats_text = (
                f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
                f"üì® <b>–í—Å–µ–≥–æ —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {len(broadcasts)}\n\n"
                f"üìà <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {total_sent}\n"
                f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {total_delivered}\n"
                f"‚ùå –û—à–∏–±–æ–∫: {total_failed}\n\n"
            )
            
            if total_sent > 0:
                success_rate = (total_delivered / total_sent) * 100
                stats_text += f"üìä <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> {success_rate:.1f}%\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
            ]
            
            await query.edit_message_text(
                stats_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_search":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üîç <b>–ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/search [–∑–∞–ø—Ä–æ—Å]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/search –Ω–µ–π—Ä–æ—Å–µ—Ç–∏</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_add":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/add [–∑–∞–≥–æ–ª–æ–≤–æ–∫] | [—Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/add AI | –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç - —ç—Ç–æ...</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_test_ocr":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if not OCR_AVAILABLE or not PIL_AVAILABLE:
                await query.edit_message_text(
                    '‚ùå <b>OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>\n\n'
                    'Tesseract OCR –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.\n\n'
                    '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ:\n'
                    '1. pip install Pillow pytesseract\n'
                    '2. Tesseract OCR (—Å–º. TESSERACT_INSTALL.txt)',
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üß™ <b>–¢–µ—Å—Ç OCR</b>\n\n'
                '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–º –ø–ª–∞—Ç–µ–∂–∞.\n\n'
                '–°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç:\n'
                '‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞\n'
                '‚úÖ –ü–æ–∏—Å–∫ —Å—É–º–º\n'
                '‚úÖ –†–∞–±–æ—Ç–∞ Tesseract OCR\n\n'
                '–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'admin_test_ocr'
            }
            return ADMIN_TEST_OCR
        
        if data == "tutorial_start":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                # Interactive tutorial for new users
                tutorial_text = (
                    'üéì <b>–ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –¢–£–¢–û–†–ò–ê–õ</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è, –∫–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.\n\n'
                    'üìö <b>–ß—Ç–æ –≤—ã —É–∑–Ω–∞–µ—Ç–µ:</b>\n'
                    '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                    '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                    '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                    '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                    'üí° <b>–≠—Ç–æ –∑–∞–π–º–µ—Ç 2 –º–∏–Ω—É—Ç—ã!</b>'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Ç—É—Ç–æ—Ä–∏–∞–ª", callback_data="tutorial_step1")],
                    [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_start: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_start: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_start: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step1":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 1: –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è?</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'ü§ñ <b>–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç</b> –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å:\n\n'
                    'üé® <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                    '–û–ø–∏—à–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É —Å–ª–æ–≤–∞–º–∏, –∏ AI —Å–æ–∑–¥–∞—Å—Ç –µ—ë!\n'
                    '–ü—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ, –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç"\n\n'
                    'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                    '–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                    '–ü—Ä–∏–º–µ—Ä: "–õ–µ—Ç—è—â–∏–π –¥—Ä–∞–∫–æ–Ω –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º"\n\n'
                    'üñºÔ∏è <b>–£–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞</b>\n'
                    '–£–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ñ–æ—Ç–æ –≤ 4-8 —Ä–∞–∑\n\n'
                    'üí° <b>–í—Å–µ —ç—Ç–æ –±–µ–∑ VPN!</b> –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –ª—É—á—à–∏–º AI-–º–æ–¥–µ–ª—è–º.'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step2")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_start")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step1: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step1: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step1: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step2":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                categories = get_categories_from_registry()
                total_models = len(get_models_sync())
                tutorial_text = (
                    f'üìñ <b>–®–ê–ì 2: –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å?</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üéØ <b>–£ –Ω–∞—Å {total_models} –º–æ–¥–µ–ª–µ–π –≤ {len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏—è—Ö:</b>\n\n'
                    f'üñºÔ∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                    f'‚Ä¢ Z-Image - –±—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (–±–µ—Å–ø–ª–∞—Ç–Ω–æ 5 —Ä–∞–∑ –≤ –¥–µ–Ω—å!)\n'
                    f'‚Ä¢ Nano Banana Pro - –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                    f'‚Ä¢ Imagen 4 Ultra - –Ω–æ–≤–µ–π—à–∞—è –æ—Ç Google\n\n'
                    f'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                    f'‚Ä¢ Sora 2 - —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                    f'‚Ä¢ Grok Imagine - –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å\n\n'
                    f'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å Z-Image - –æ–Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step3")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step1")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step2: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step2: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step2: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step3":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 3: –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç?</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üìù <b>–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ—Ü–µ—Å—Å:</b>\n\n'
                    '1Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                    '2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, Z-Image)\n'
                    '3Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø—Ä–æ–º–ø—Ç)\n'
                    '   –ü—Ä–∏–º–µ—Ä: "–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"\n'
                    '4Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (—Ä–∞–∑–º–µ—Ä, —Å—Ç–∏–ª—å –∏ —Ç.–¥.)\n'
                    '5Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                    '6Ô∏è‚É£ –ü–æ–¥–æ–∂–¥–∏—Ç–µ 10-60 —Å–µ–∫—É–Ω–¥\n'
                    '7Ô∏è‚É£ –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç! üéâ\n\n'
                    'üí° <b>–°–æ–≤–µ—Ç:</b> –ß–µ–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, —Ç–µ–º –ª—É—á—à–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step4")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step2")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step3: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step3: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step3: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step4":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                remaining_free = get_user_free_generations_remaining(user_id)
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 4: –ë–∞–ª–∞–Ω—Å –∏ –æ–ø–ª–∞—Ç–∞</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üí∞ <b>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:</b>\n\n'
                    'üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b>\n'
                    f'‚Ä¢ {remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image –≤ –¥–µ–Ω—å\n'
                    '‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ - –ø–æ–ª—É—á–∏—Ç–µ +5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!\n\n'
                    'üí≥ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞:</b>\n'
                    '‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: 50 ‚ÇΩ\n'
                    '‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                    '‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ—é —Å—É–º–º—É\n'
                    '‚Ä¢ –û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü (–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)\n\n'
                    'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="tutorial_complete")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step3")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step4: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step4: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step4: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_complete":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                'üéâ <b>–¢–£–¢–û–†–ò–ê–õ –ó–ê–í–ï–†–®–ï–ù!</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                '‚úÖ –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–µ—Ç–µ:\n'
                '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                'üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>\n\n'
                'üí° <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:</b>\n'
                '–ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image!\n'
                '–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å.'
            )
            
                keyboard = [
                    [InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")],
                    [InlineKeyboardButton("üñºÔ∏è Z-Image (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)", callback_data="select_model:z-image")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_complete: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_complete: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_complete: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "help_menu":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            is_new = is_new_user(user_id)
            
            if is_new:
                if user_lang == 'ru':
                    help_text = (
                        'üìã <b>–ü–û–ú–û–©–¨ –î–õ–Ø –ù–û–í–´–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b>\n\n'
                        'üéØ <b>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç:</b>\n'
                        '1. –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                        '2. –í—ã–±–µ—Ä–∏—Ç–µ "üñºÔ∏è Z-Image" (–æ–Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è!)\n'
                        '3. –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ"\n'
                        '4. –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                        '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ 10-30 —Å–µ–∫—É–Ω–¥!\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üí° <b>–ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n'
                        '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                        '/models - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –º–æ–¥–µ–ª–∏\n'
                        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                        '/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n'
                        '‚ùì <b>–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?</b>\n'
                        '–ù–∞–∂–º–∏—Ç–µ "‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?" –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—É—Ç–æ—Ä–∏–∞–ª–∞!'
                    )
                else:
                    help_text = (
                        'üìã <b>HELP FOR NEW USERS</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üëã <b>Welcome!</b>\n\n'
                        'üéØ <b>Quick Start:</b>\n'
                        '1. Click "üìã All Models"\n'
                        '2. Select "üñºÔ∏è Z-Image" (it\'s free!)\n'
                        '3. Enter description, e.g.: "Cat in space"\n'
                        '4. Click "‚úÖ Generate"\n'
                        '5. Get result in 10-30 seconds!\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üí° <b>Useful Commands:</b>\n'
                        '/start - Main menu\n'
                        '/models - Show all models\n'
                        '/balance - Check balance\n'
                        '/help - This help\n\n'
                        '‚ùì <b>Need help?</b>\n'
                        'Click "‚ùì How it works?" for interactive tutorial!'
                    )
            else:
                if user_lang == 'ru':
                    help_text = (
                        'üìã <b>–î–û–°–¢–£–ü–ù–´–ï –ö–û–ú–ê–ù–î–´</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üîπ <b>–û—Å–Ω–æ–≤–Ω—ã–µ:</b>\n'
                        '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                        '/models - –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏\n'
                        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                        '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                        '/help - –°–ø—Ä–∞–≤–∫–∞\n\n'
                    )
                else:
                    help_text = (
                        'üìã <b>AVAILABLE COMMANDS</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üîπ <b>Main:</b>\n'
                        '/start - Main menu\n'
                        '/models - Show models\n'
                        '/balance - Check balance\n'
                        '/generate - Start generation\n'
                        '/help - Help\n\n'
                    )
                
                if user_id == ADMIN_ID:
                    if user_lang == 'ru':
                        help_text += (
                            'üëë <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ:</b>\n'
                            '/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                            '/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                            '/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                            '/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                            '/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                            '/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n'
                        )
                    else:
                        help_text += (
                            'üëë <b>Administrative:</b>\n'
                            '/search - Search knowledge base\n'
                            '/add - Add knowledge\n'
                            '/payments - View payments\n'
                            '/block_user - Block user\n'
                            '/unblock_user - Unblock user\n'
                            '/user_balance - User balance\n\n'
                        )
                
                if user_lang == 'ru':
                    help_text += (
                        'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
                        '1. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n'
                        '2. –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç (–æ–ø–∏—Å–∞–Ω–∏–µ)\n'
                        '3. –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏\n'
                        '4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                        '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!\n\n'
                        'üìö <b>–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n'
                        '‚Ä¢ "üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏" - –ø—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏\n'
                        '‚Ä¢ "üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å" - —Å–æ–∑–¥–∞—Ç—å —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏\n'
                        '‚Ä¢ "üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å" - –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞'
                    )
                else:
                    help_text += (
                        'üí° <b>How to use:</b>\n'
                        '1. Select model from menu\n'
                        '2. Enter prompt (description)\n'
                        '3. Select parameters via buttons\n'
                        '4. Confirm generation\n'
                        '5. Get result!\n\n'
                        'üìö <b>Useful features:</b>\n'
                        '‚Ä¢ "üìö My generations" - view history\n'
                        '‚Ä¢ "üîÑ Repeat" - create with same parameters\n'
                        '‚Ä¢ "üí≥ Top up" - top up balance'
                    )
            
            keyboard = []
            if is_new:
                if user_lang == 'ru':
                    keyboard.append([InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")])
                else:
                    keyboard.append([InlineKeyboardButton("‚ùì How it works?", callback_data="tutorial_start")])
            keyboard.append([
                InlineKeyboardButton("üåê " + ("–Ø–∑—ã–∫ / Language" if user_lang == 'ru' else "Language / –Ø–∑—ã–∫"), callback_data="change_language")
            ])
            keyboard.append([
                InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")
            ])
            
            try:
                await query.edit_message_text(
                    help_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in help_menu: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        help_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data == "support_contact":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            support_info = get_support_contact()
            
            # Translate support contact message if needed
            if user_lang == 'en' and '–ü–æ–¥–¥–µ—Ä–∂–∫–∞' in support_info:
                # If support info is in Russian but user wants English, add English header
                support_info = (
                    'üí¨ <b>SUPPORT</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'If you have any questions or need help, please contact our support team:\n\n'
                    + support_info.replace('üí¨ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>', '').replace('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', '').strip()
                )
            
            keyboard = [
                [InlineKeyboardButton("üåê " + ("–Ø–∑—ã–∫ / Language" if user_lang == 'ru' else "Language / –Ø–∑—ã–∫"), callback_data="change_language")],
                [InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    support_info,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in support_contact: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        support_info,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        # Handle copy bot request
        if data == "copy_bot":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            
            # Create admin link
            admin_link = f"tg://user?id={ADMIN_ID}"
            
            # Create message with admin link
            if user_lang == 'ru':
                copy_message = (
                    f"{t('msg_copy_bot_title', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"{t('msg_copy_bot_description', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üë®‚Äçüíª <a href=\"{admin_link}\">–°–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</a>"
                )
            else:
                copy_message = (
                    f"{t('msg_copy_bot_title', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"{t('msg_copy_bot_description', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üë®‚Äçüíª <a href=\"{admin_link}\">Contact Administrator</a>"
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    copy_message,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML',
                    disable_web_page_preview=False
                )
            except Exception as e:
                logger.error(f"Error editing message in copy_bot: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        copy_message,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML',
                        disable_web_page_preview=False
                    )
                except:
                    pass
            return ConversationHandler.END
        
        # Handle language change request
        if data == "change_language":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get current language to show appropriate text
            current_lang = get_user_language(user_id)
            
            # Show language selection menu
            if current_lang == 'ru':
                text = "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Choose language:\n\n–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –±–æ—Ç–∞."
            else:
                text = "üåê Choose language / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:\n\nSelect the bot interface language."
            
            keyboard = [
                [
                    InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="language_select:ru"),
                    InlineKeyboardButton("üá¨üáß English", callback_data="language_select:en")
                ],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥" if current_lang == 'ru' else "‚óÄÔ∏è Back", callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in change_language: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data == "referral_info":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Show referral information
            referral_link = get_user_referral_link(user_id)
            referrals_count = len(get_user_referrals(user_id))
            remaining_free = get_user_free_generations_remaining(user_id)
            
            user_lang = get_user_language(user_id)
            
            referral_text = (
                f'{t("msg_referral_title", lang=user_lang)}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{t("msg_referral_how_it_works", lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{t("msg_referral_stats", lang=user_lang, count=referrals_count, bonus_total=referrals_count * REFERRAL_BONUS_GENERATIONS, remaining=remaining_free)}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{t("msg_referral_important", lang=user_lang)}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{t("msg_referral_link_title", lang=user_lang)}\n\n'
                f'<code>{referral_link}</code>\n\n'
                f'{t("msg_referral_send", lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}'
            )
            keyboard = [
                [InlineKeyboardButton(t('btn_copy_link', lang=user_lang), url=referral_link)],
                [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    referral_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in referral_info: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        referral_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data == "my_generations":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Show user's generation history
            history = get_user_generations_history(user_id, limit=20)
            
            # Debug: log history loading
            logger.info(f"Loading history for user {user_id}: found {len(history)} generations")
            
            # Check if file exists and show helpful message
            if not history:
                user_lang = get_user_language(user_id)
                file_exists = os.path.exists(GENERATIONS_HISTORY_FILE)
                
                # Load full history to check if there are any users at all
                full_history = {}
                total_users = 0
                if file_exists:
                    try:
                        full_history = load_json_file(GENERATIONS_HISTORY_FILE, {})
                        total_users = len(full_history)
                        logger.info(f"History file exists with {total_users} users. Checking for user {user_id}...")
                    except Exception as e:
                        logger.error(f"Error loading history file: {e}", exc_info=True)
                
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        "‚ùå –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n\n"
                    )
                    if not file_exists:
                        message_text += (
                            "‚ö†Ô∏è <b>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:</b> –§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.\n"
                            "–≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞.\n\n"
                        )
                    elif total_users > 0:
                        message_text += (
                            f"‚ÑπÔ∏è –í —Å–∏—Å—Ç–µ–º–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ {total_users} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∏—Å—Ç–æ—Ä–∏–µ–π.\n"
                            f"–ï—Å–ª–∏ –≤—ã —Å–æ–∑–¥–∞–≤–∞–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–∞–Ω–µ–µ, –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è.\n\n"
                        )
                    message_text += "üí° –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤—Å–µ –≤–∞—à–∏ —Ä–∞–±–æ—Ç—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∑–¥–µ—Å—å."
                else:
                    message_text = (
                        "üìö <b>My Generations</b>\n\n"
                        "‚ùå You don't have any saved generations yet.\n\n"
                    )
                    if not file_exists:
                        message_text += (
                            "‚ö†Ô∏è <b>Note:</b> History file not found.\n"
                            "This may happen after bot update.\n\n"
                        )
                    elif total_users > 0:
                        message_text += (
                            f"‚ÑπÔ∏è System has {total_users} users with history saved.\n"
                            f"If you created generations before, they should appear.\n\n"
                        )
                    message_text += "üí° After creating content, all your works will be saved here."
                
                keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é" if user_lang == 'ru' else "‚óÄÔ∏è Back to menu", callback_data="back_to_menu")]]
                try:
                    await query.edit_message_text(
                        message_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in my_generations (empty): {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            message_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
                return ConversationHandler.END
            
            # Show first generation with navigation
            try:
                from datetime import datetime
                
                gen = history[0]
                timestamp = gen.get('timestamp', 0)
                if timestamp:
                    date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
                else:
                    date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                
                model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
                result_urls = gen.get('result_urls', [])
                price = gen.get('price', 0)
                is_free = gen.get('is_free', False)
                
                user_lang = get_user_language(user_id)
                
                history_text = (
                    f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>–í—Å–µ–≥–æ:</b> {len(history)} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n"
                    f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                    f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                    f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
                )
                
                if len(history) > 1:
                    history_text += f"üí° <b>–ü–æ–∫–∞–∑–∞–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n"
                    history_text += f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏\n\n"
                
                keyboard = []
                
                # Navigation buttons if more than 1 generation
                if len(history) > 1:
                    keyboard.append([
                        InlineKeyboardButton(t('btn_previous', lang=user_lang), callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                        InlineKeyboardButton(t('btn_next', lang=user_lang), callback_data=f"gen_history:{gen.get('id', 1)}:next")
                    ])
                
                # Action buttons
                if result_urls:
                    keyboard.append([
                        InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                    ])
                
                keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
                
                try:
                    await query.edit_message_text(
                        history_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in my_generations: {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            history_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
            except Exception as e:
                logger.error(f"Error in my_generations: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏—Å—Ç–æ—Ä–∏–∏", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        if data.startswith("gen_view:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # View specific generation result
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            try:
                gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            result_urls = gen.get('result_urls', [])
            if not result_urls:
                try:
                    await query.answer("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            # Send media
            try:
                session_http = await get_http_client()
                for i, url in enumerate(result_urls[:5]):
                    try:
                        async with session_http.get(url) as resp:
                                if resp.status == 200:
                                    media_data = await resp.read()
                                    
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    is_video = gen.get('model_id', '') in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard']
                                    
                                    keyboard = []
                                    if is_last:
                                        keyboard = [
                                            [InlineKeyboardButton(t('btn_back_to_history', lang=user_lang), callback_data="my_generations")],
                                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                                        ]
                                    
                                    if is_video:
                                        video_file = io.BytesIO(media_data)
                                        video_file.name = f"generated_video_{i+1}.mp4"
                                        await context.bot.send_video(
                                            chat_id=update.effective_chat.id,
                                            video=video_file,
                                            reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                        )
                                    else:
                                        photo_file = io.BytesIO(media_data)
                                        photo_file.name = f"generated_image_{i+1}.png"
                                        await context.bot.send_photo(
                                            chat_id=update.effective_chat.id,
                                            photo=photo_file,
                                            reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                        )
                    except Exception as e:
                        logger.error(f"Error sending generation result (HTTP API call): {e}", exc_info=True)
            except Exception as e:
                logger.error(f"Error in gen_view API calls: {e}", exc_info=True)
                try:
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                    await query.answer(error_msg, show_alert=True)
                except:
                    pass
            
            try:
                await query.answer("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
            except:
                pass
            return ConversationHandler.END
        
        if data.startswith("gen_repeat:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # Repeat generation with same parameters
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            try:
                gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Restore session from history
            model_id = gen.get('model_id')
            params = gen.get('params', {})
            model_info = get_model_by_id(model_id)
            
            if not model_info:
                try:
                    await query.answer("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            user_sessions[user_id] = {
                'model_id': model_id,
                'model_info': model_info,
                'params': params.copy(),
                'properties': model_info.get('input_params', {}),
                'required': []
            }
            
            # Go directly to confirmation
            try:
                await query.answer("‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
            except:
                pass
            
            try:
                # Format parameters for display
                params = gen.get('params', {})
                params_preview = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in list(params.items())[:5]])
                if len(params) > 5:
                    params_preview += f"\n  ... –∏ –µ—â–µ {len(params) - 5} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"
                
                if user_lang == 'ru':
                    repeat_msg = (
                        "üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_info.get('name', model_id)}\n\n"
                        f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏:</b>\n{params_preview if params_preview else '  (–Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)'}\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        "üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                        "‚Ä¢ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã\n"
                        "‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n"
                        "‚Ä¢ –ò–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∏ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\n"
                        "üöÄ <b>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é:</b>"
                    )
                else:
                    repeat_msg = (
                        "üîÑ <b>Repeat generation</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"ü§ñ <b>Model:</b> {model_info.get('name', model_id)}\n\n"
                        f"‚öôÔ∏è <b>Parameters restored from history:</b>\n{params_preview if params_preview else '  (no parameters)'}\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        "üí° <b>What's next:</b>\n"
                        "‚Ä¢ Parameters are already filled\n"
                        "‚Ä¢ You can start generation immediately\n"
                        "‚Ä¢ Or go back and change parameters\n\n"
                        "üöÄ <b>Confirm generation:</b>"
                    )
                
                logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved repeat generation message to user {user_id}")
                await query.edit_message_text(
                    repeat_msg,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t('btn_confirm_generate_text', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(t('btn_back_to_history', lang=user_lang), callback_data="my_generations")],
                        [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                    ]),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in gen_repeat: {e}", exc_info=True)
                try:
                    # Format parameters for display
                    params = gen.get('params', {})
                    params_preview = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in list(params.items())[:5]])
                    if len(params) > 5:
                        params_preview += f"\n  ... –∏ –µ—â–µ {len(params) - 5} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"
                    
                    if user_lang == 'ru':
                        repeat_msg = (
                            "üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_info.get('name', model_id)}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏:</b>\n{params_preview if params_preview else '  (–Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)'}\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            "‚Ä¢ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã\n"
                            "‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n"
                            "‚Ä¢ –ò–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∏ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\n"
                            "üöÄ <b>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é:</b>"
                        )
                    else:
                        repeat_msg = (
                            "üîÑ <b>Repeat generation</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_info.get('name', model_id)}\n\n"
                            f"‚öôÔ∏è <b>Parameters restored from history:</b>\n{params_preview if params_preview else '  (no parameters)'}\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üí° <b>What's next:</b>\n"
                            "‚Ä¢ Parameters are already filled\n"
                            "‚Ä¢ You can start generation immediately\n"
                            "‚Ä¢ Or go back and change parameters\n\n"
                            "üöÄ <b>Confirm generation:</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved repeat generation message (fallback) to user {user_id}")
                    await query.message.reply_text(
                        repeat_msg,
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" if user_lang == 'ru' else "‚úÖ Generate", callback_data="confirm_generate")],
                            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∏—Å—Ç–æ—Ä–∏–∏" if user_lang == 'ru' else "‚óÄÔ∏è Back to history", callback_data="my_generations")],
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                        ]),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return CONFIRMING_GENERATION
        
        if data.startswith("gen_history:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # Navigate through generation history
            parts = data.split(":")
            if len(parts) < 3:
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            try:
                current_gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            direction = parts[2]  # prev or next
            
            history = get_user_generations_history(user_id, limit=100)
            if not history:
                try:
                    await query.answer("‚ùå –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Find current generation index
            current_index = -1
            for i, gen in enumerate(history):
                if gen.get('id') == current_gen_id:
                    current_index = i
                    break
            
            if current_index == -1:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Navigate
            if direction == 'prev' and current_index < len(history) - 1:
                new_index = current_index + 1
            elif direction == 'next' and current_index > 0:
                new_index = current_index - 1
            else:
                try:
                    await query.answer("‚ö†Ô∏è –≠—Ç–æ –ø–µ—Ä–≤–∞—è/–ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            gen = history[new_index]
            from datetime import datetime
            
            timestamp = gen.get('timestamp', 0)
            if timestamp:
                date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
            else:
                date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
            
            model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
            result_urls = gen.get('result_urls', [])
            price = gen.get('price', 0)
            is_free = gen.get('is_free', False)
            
            if user_lang == 'ru':
                history_text = (
                    f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>–í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b> {len(history)}\n"
                    f"üìç <b>–ü–æ–∫–∞–∑–∞–Ω–∞:</b> {new_index + 1} –∏–∑ {len(history)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n\n"
                    f"üìÖ <b>–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:</b> {date_str}\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                    f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                    f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>–ß—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                    f"‚Ä¢ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏\n"
                    f"‚Ä¢ –ü–µ—Ä–µ–π—Ç–∏ –∫ –¥—Ä—É–≥–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n\n"
                    f"üîÑ <b>–ù–∞–≤–∏–≥–∞—Ü–∏—è:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ"
                )
            else:
                history_text = (
                    f"üìö <b>My Generations</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>Total generations:</b> {len(history)}\n"
                    f"üìç <b>Showing:</b> {new_index + 1} of {len(history)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>Generation #{gen.get('id', 1)}</b>\n\n"
                    f"üìÖ <b>Created:</b> {date_str}\n"
                    f"ü§ñ <b>Model:</b> {model_name}\n"
                    f"üí∞ <b>Cost:</b> {'üéÅ Free' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                    f"üì¶ <b>Results:</b> {len(result_urls)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>What you can do:</b>\n"
                    f"‚Ä¢ View generation result\n"
                    f"‚Ä¢ Repeat generation with same parameters\n"
                    f"‚Ä¢ Navigate to another generation\n\n"
                    f"üîÑ <b>Navigation:</b> Use buttons below"
                )
            
            logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved generation history view to user {user_id}")
            
            keyboard = []
            
            # Navigation buttons
            keyboard.append([
                InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚ñ∂Ô∏è", callback_data=f"gen_history:{gen.get('id', 1)}:next")
            ])
            
            # Action buttons
            if result_urls:
                keyboard.append([
                    InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                ])
            
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            await query.edit_message_text(
                history_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle model card display (model:<model_id>)
        if data.startswith("model:") or data.startswith("modelk:"):
            try:
                await query.answer()
            except:
                pass
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            user_lang = get_user_language(user_id)
            
            try:
                from app.helpers.models_menu_handlers import handle_model_callback
                success = await handle_model_callback(query, user_id, user_lang, data)
                
                if success:
                    return SELECTING_MODEL
                else:
                    return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in handle_model_callback: {e}", exc_info=True)
                if user_lang == 'ru':
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–∏", show_alert=True)
                else:
                    await query.answer("‚ùå Error loading model", show_alert=True)
                return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥ (–µ—Å–ª–∏ –Ω–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª)
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1] if len(parts) > 1 else None
            if not model_id:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑—Ä–µ—à–∏—Ç—å —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import resolve_model_id_from_callback
                model_id = resolve_model_id_from_callback(data)
            
            if not model_id:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import build_model_card_text
                card_text, keyboard_markup = build_model_card_text(catalog_model, 0, user_lang)
                try:
                    await query.edit_message_text(
                        card_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing model card: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            model = get_model_by_id(model_id)
            
            if not model:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–æ–¥–µ–ª—å –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            try:
                from kie_models import normalize_model_for_api
                normalized = normalize_model_for_api(model)
            except:
                normalized = model
            
            user_lang = get_user_language(user_id)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –º–æ–¥–µ–ª–∏
            title = normalized.get('title') or normalized.get('name') or model_id
            emoji = normalized.get('emoji', '')
            gen_type = normalized.get('generation_type', 'unknown')
            help_text = normalized.get('help') or normalized.get('description', '')
            input_schema = normalized.get('input_schema') or normalized.get('input_params', {})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏
            if user_lang == 'ru':
                model_info_text = (
                    f"{emoji} <b>{title}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìã <b>–¢–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {gen_type.replace('_', '-')}\n\n"
                    f"‚ÑπÔ∏è <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{help_text}\n\n"
                )
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö (–±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Å—Ö–µ–º—ã)
                if input_schema:
                    required_params = [k for k, v in input_schema.items() if v.get('required', False)]
                    optional_params = [k for k, v in input_schema.items() if not v.get('required', False)]
                    
                    model_info_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    model_info_text += "‚öôÔ∏è <b>–û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                    if required_params:
                        model_info_text += f"‚Ä¢ –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ: {', '.join(required_params[:5])}"
                        if len(required_params) > 5:
                            model_info_text += f" –∏ –µ—â–µ {len(required_params) - 5}"
                        model_info_text += "\n"
                    if optional_params:
                        model_info_text += f"‚Ä¢ –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ: {', '.join(optional_params[:5])}"
                        if len(optional_params) > 5:
                            model_info_text += f" –∏ –µ—â–µ {len(optional_params) - 5}"
                        model_info_text += "\n"
                    model_info_text += "\n"
                
                model_info_text += (
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üí° <b>–°–æ–≤–µ—Ç:</b> –ü–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—à–∞–≥–æ–≤–æ.\n\n"
                    "üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b> –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ!"
                )
            else:
                model_info_text = (
                    f"{emoji} <b>{title}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìã <b>Generation type:</b> {gen_type.replace('_', '-')}\n\n"
                    f"‚ÑπÔ∏è <b>Description:</b>\n{help_text}\n\n"
                )
                
                # Add parameter info (without technical schema)
                if input_schema:
                    required_params = [k for k, v in input_schema.items() if v.get('required', False)]
                    optional_params = [k for k, v in input_schema.items() if not v.get('required', False)]
                    
                    model_info_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    model_info_text += "‚öôÔ∏è <b>Main parameters:</b>\n"
                    if required_params:
                        model_info_text += f"‚Ä¢ Required: {', '.join(required_params[:5])}"
                        if len(required_params) > 5:
                            model_info_text += f" and {len(required_params) - 5} more"
                        model_info_text += "\n"
                    if optional_params:
                        model_info_text += f"‚Ä¢ Optional: {', '.join(optional_params[:5])}"
                        if len(optional_params) > 5:
                            model_info_text += f" and {len(optional_params) - 5} more"
                        model_info_text += "\n"
                    model_info_text += "\n"
                
                model_info_text += (
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üí° <b>Tip:</b> After starting generation, you'll be able to configure all parameters step by step.\n\n"
                    "üöÄ <b>Ready to start?</b> Click the button below!"
                )
            
            logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved model card to user {user_id} for model {model_id}")
            
            # –ö–Ω–æ–ø–∫–∏
            if user_lang == 'ru':
                keyboard = [
                    [InlineKeyboardButton("‚úÖ –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é", callback_data=f"start:{model_id}")],
                    [InlineKeyboardButton("‚ÑπÔ∏è –ü—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞", callback_data=f"example:{model_id}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
            else:
                keyboard = [
                    [InlineKeyboardButton("‚úÖ Start generation", callback_data=f"start:{model_id}")],
                    [InlineKeyboardButton("‚ÑπÔ∏è Example request", callback_data=f"example:{model_id}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_to_menu")]
                ]
            
            await query.edit_message_text(
                text=model_info_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle start generation from model card (start:<model_id>)
        if data.startswith("start:"):
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1]
            # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ select_model –¥–ª—è –Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            query.data = f"select_model:{model_id}"
            # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–∞–∫ select_model
            data = query.data
        
        # Handle example request (example:<model_id>)
        if data.startswith("example:"):
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1]
            model = get_model_by_id(model_id)
            
            if not model:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–æ–¥–µ–ª—å
            try:
                from kie_models import normalize_model_for_api
                normalized = normalize_model_for_api(model)
            except:
                normalized = model
            
            user_lang = get_user_language(user_id)
            input_schema = normalized.get('input_schema') or normalized.get('input_params', {})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞
            example_text = f"üìù <b>–ü—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è {normalized.get('title', model_id)}</b>\n\n"
            example_text += f"<b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
            
            import json
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–∏–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ö–µ–º—ã
            example_params = {}
            for param_name, param_type in input_schema.items():
                if param_type == 'string':
                    if 'prompt' in param_name.lower():
                        example_params[param_name] = "–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"
                    elif 'url' in param_name.lower():
                        example_params[param_name] = "https://example.com/image.jpg"
                    else:
                        example_params[param_name] = "–ø—Ä–∏–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏—è"
                elif param_type == 'array':
                    example_params[param_name] = ["https://example.com/image1.jpg"]
                else:
                    example_params[param_name] = "–ø—Ä–∏–º–µ—Ä"
            
            example_text += f"<code>{json.dumps(example_params, indent=2, ensure_ascii=False)}</code>\n\n"
            example_text += f"üí° <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>\n{normalized.get('help', '–°–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –º–æ–¥–µ–ª–∏')}"
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é", callback_data=f"start:{model_id}")],
                [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª–∏", callback_data=f"model:{model_id}")]
            ]
            
            await query.edit_message_text(
                text=example_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle model: callback - shows model card with "Start" button (canonical format for tests)
        if data.startswith("model:") or data.startswith("modelk:"):
            try:
                await query.answer()
            except:
                pass
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            user_lang = get_user_language(user_id)
            
            try:
                from app.helpers.models_menu_handlers import handle_model_callback
                success = await handle_model_callback(query, user_id, user_lang, data)
                
                if success:
                    return SELECTING_MODEL
                else:
                    return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in handle_model_callback (second handler): {e}", exc_info=True)
                # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
                pass
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1] if len(parts) > 1 else None
            if not model_id:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑—Ä–µ—à–∏—Ç—å —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import resolve_model_id_from_callback
                model_id = resolve_model_id_from_callback(data)
            
            if not model_id:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default=f"‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            logger.info(f"Model card requested: model_id={model_id}, user_id={user_id}")
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import build_model_card_text
                card_text, keyboard_markup = build_model_card_text(catalog_model, 0, user_lang)
                try:
                    await query.edit_message_text(
                        card_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing model card: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            # Get model from registry
            model_info = get_model_by_id_from_registry(model_id)
            if not model_info:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default=f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # Check if model is coming soon
            if model_info.get('coming_soon', False):
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                error_msg = t('error_model_unavailable', lang=user_lang) or "–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"
                try:
                    await query.edit_message_text(
                        error_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message for coming_soon model: {edit_error}")
                    try:
                        await query.message.reply_text(error_msg, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except:
                        await query.answer(error_msg, show_alert=True)
                return ConversationHandler.END
            
            # Show model card with info and "Start" button
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            user_lang = get_user_language(user_id)
            
            # Calculate price
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}
            elif model_id in ["seedream/4.5-text-to-image", "seedream/4.5-edit"]:
                default_params = {"quality": "basic"}
            elif model_id == "topaz/image-upscale":
                default_params = {"upscale_factor": "1"}
            
            is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
            min_price = calculate_price_rub(model_id, default_params, is_admin_check, user_id)
            price_text = get_model_price_text(model_id, default_params, is_admin_check, user_id)
            
            # Format model card
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            model_category = model_info.get('category', '–û–±—â–µ–µ')
            
            model_info_text = (
                f"{model_emoji} <b>{model_name}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if model_category:
                model_info_text += f"üìÅ <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {model_category}\n"
            
            if model_desc:
                model_info_text += f"\nüìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{model_desc}\n\n"
            
            model_info_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            model_info_text += f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_text}\n\n"
            
            # Build keyboard with "Start" button
            keyboard = [
                [InlineKeyboardButton("üöÄ –°—Ç–∞—Ä—Ç", callback_data=f"select_model:{model_id}")],
                [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            # Try to edit message, fallback to reply if edit fails
            try:
                await query.edit_message_text(
                    model_info_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as edit_error:
                logger.warning(f"Could not edit message in model: handler: {edit_error}, sending new message")
                try:
                    await query.message.reply_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    try:
                        await query.message.delete()
                    except:
                        pass
                except Exception as send_error:
                    logger.error(f"Could not send new message in model: handler: {send_error}", exc_info=True)
                    await query.answer(t('error_try_start', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start"), show_alert=True)
            
            return ConversationHandler.END
        
        # Handle select_model: callback - starts generation flow directly (legacy, still supported)
        # Also handles start: callback (redirects to select_model:)
        if data.startswith("select_model:") or data.startswith("sel:"):
            # Handle short format sel: -> select_model:
            if data.startswith("sel:"):
                parts = data.split(":", 1)
                if len(parts) >= 2:
                    model_id = parts[1]
                    # Try to find full model_id by prefix (for backward compatibility)
                    # In most cases, sel: prefix means it was truncated, so we need to search
                    models = get_models_sync()
                    matching_models = [m for m in models if m.get('id', '').startswith(model_id)]
                    if matching_models:
                        model_id = matching_models[0].get('id')
                        data = f"select_model:{model_id}"
                    else:
                        data = f"select_model:{model_id}"
            
            # üî• MAXIMUM LOGGING: select_model entry
            logger.info(f"üî•üî•üî• SELECT_MODEL START: user_id={user_id}, data={data}")
            
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
                logger.info(f"‚úÖ Query answered for select_model: user_id={user_id}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Failed to answer query: {e}")
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                logger.error(f"‚ùå Invalid select_model format: data={data}, user_id={user_id}")
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            model_id = parts[1]
            logger.info(f"üî•üî•üî• SELECT_MODEL: Parsed model_id={model_id}, user_id={user_id}")
            
            # Get model from registry
            model_info = get_model_by_id_from_registry(model_id)
            logger.info(f"üî•üî•üî• SELECT_MODEL: Model lookup result: found={bool(model_info)}, model_name={model_info.get('name', 'N/A') if model_info else 'N/A'}, user_id={user_id}")
            
            if not model_info:
                logger.error(f"‚ùå‚ùå‚ùå MODEL NOT FOUND: model_id={model_id}, user_id={user_id}")
                try:
                    await query.edit_message_text(f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                except:
                    try:
                        await query.message.reply_text(f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                    except:
                        pass
                return ConversationHandler.END
            
            # Check if model is coming soon - –ù–ï –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –º–µ–Ω—é
            if model_info.get('coming_soon', False):
                user_lang = get_user_language(user_id)
                # –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º "COMING SOON" - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –º–µ–Ω—é
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    t('error_model_unavailable', lang=user_lang) or "–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Check user balance and calculate available generations
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            
            # Calculate price for default parameters (minimum price)
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}  # Cheapest option
            elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
                default_params = {"quality": "basic"}  # Basic quality (same price, but for consistency)
            elif model_id == "topaz/image-upscale":
                default_params = {"upscale_factor": "1"}  # Cheapest option (1x = ‚â§2K)
            
            # IMPORTANT: Use get_is_admin() if user_id is available to respect admin_user_mode
            is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
            min_price = calculate_price_rub(model_id, default_params, is_admin_check, user_id)
            price_text = get_model_price_text(model_id, default_params, is_admin_check, user_id)
            
            # Check for free generations for z-image
            is_free_available = is_free_generation_available(user_id, model_id)
            remaining_free = get_user_free_generations_remaining(user_id) if model_id == FREE_MODEL_ID else 0
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif is_free_available:
                # For z-image with free generations, show free count
                available_count = f"üéÅ {remaining_free} –±–µ—Å–ø–ª–∞—Ç–Ω–æ –≤ –¥–µ–Ω—å"
            elif user_balance >= min_price:
                available_count = int(user_balance / min_price)
            else:
                available_count = 0
            
            # Show model info with premium formatting
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            model_category = model_info.get('category', '–û–±—â–µ–µ')
            
            # Check if new user for hints
            is_new = is_new_user(user_id)
            
            # Premium formatted model info (optimized for mobile - shorter lines)
            model_info_text = (
                f"‚ú® <b>–ü–†–ï–ú–ò–£–ú –ú–û–î–ï–õ–¨</b> ‚ú®\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"{model_emoji} <b>{model_name}</b>\n"
                f"üìÅ {model_category}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n"
                f"<i>{model_desc}</i>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            # Format price text properly (optimize for mobile display)
            import re
            
            # For hailuo models with multiple resolutions, show formatted version
            if model_id == "hailuo/02-image-to-video-standard" or model_id == "hailuo/02-image-to-video-pro":
                # Remove emoji and HTML, but keep the structure
                price_display_clean = price_text.replace("üí∞", "").strip()
                price_display_clean = re.sub(r'<b>(.*?)</b>', r'\1', price_display_clean)
                # Replace (512P: with (–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 512p: to make it clearer
                price_display_clean = price_display_clean.replace("512P:", "üì∫ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 512p:")
                price_display_clean = price_display_clean.replace("768P:", "üì∫ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 768p:")
                price_display_clean = price_display_clean.replace(" | ", "\n")
                price_display_clean = price_display_clean.replace("‚ÇΩ/6—Å", "‚ÇΩ (6—Å)").replace("‚ÇΩ/10—Å", "‚ÇΩ (10—Å)")
                model_info_text += f"\n{price_display_clean}\n"
            else:
                # For other models, use simple format
                price_display = price_text
                if price_text.startswith("üí∞"):
                    price_display = price_text.replace("üí∞", "").strip()
                # Remove HTML tags if present but keep the content
                price_display = re.sub(r'<b>(.*?)</b>', r'\1', price_display)
                price_display = price_display.strip()
                
                # Shorten price display for mobile
                if len(price_display) > 50:
                    # Extract just the number and currency
                    price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_display)
                    if price_match:
                        price_display = f"{price_match.group(1)} ‚ÇΩ"
                
                model_info_text += f"üí∞ <b>–¶–µ–Ω–∞:</b> {price_display}\n"
            
            # Add hint for new users
            if is_new and model_id == FREE_MODEL_ID:
                model_info_text += (
                    f"\nüí° <b>–û—Ç–ª–∏—á–Ω–æ –¥–ª—è –Ω–∞—á–∞–ª–∞!</b>\n"
                    f"–≠—Ç–∞ –º–æ–¥–µ–ª—å –±–µ—Å–ø–ª–∞—Ç–Ω–∞ –¥–ª—è –ø–µ—Ä–≤—ã—Ö {FREE_GENERATIONS_PER_DAY} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ –¥–µ–Ω—å.\n"
                    f"–ü—Ä–æ—Å—Ç–æ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å, –∏ –Ω–∞–∂–º–∏—Ç–µ \"–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\"!\n\n"
                )
            
            # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            if is_admin:
                model_info_text += (
                    f"‚úÖ <b>–î–æ—Å—Ç—É–ø:</b> <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n"
                    f"üëë <b>–°—Ç–∞—Ç—É—Å:</b> –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä\n\n"
                )
            else:
                # –î–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –∏ –±–∞–ª–∞–Ω—Å
                if is_free_available:
                    model_info_text += (
                        f"üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å\n"
                    )
                    if user_balance >= min_price:
                        paid_count = int(user_balance / min_price)
                        model_info_text += f"üí≥ <b>–ü–ª–∞—Ç–Ω—ã—Ö:</b> {paid_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                    model_info_text += f"üíµ <b>–ë–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n\n"
                elif available_count > 0:
                    model_info_text += (
                        f"‚úÖ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {available_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                        f"üíµ <b>–ë–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n\n"
                    )
                else:
                    # Not enough balance - show warning
                    model_info_text += (
                        f"\n‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"üíµ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {format_price_rub(min_price, is_admin)} ‚ÇΩ\n\n"
                        f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                    )
                    
                    keyboard = [
                        [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                        [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                    ]
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
            
            # Check balance before starting generation (but allow free generations)
            if not is_admin and not is_free_available and user_balance < min_price:
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                
                needed = min_price - user_balance
                needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
                remaining_free = get_user_free_generations_remaining(user_id)
                
                if user_lang == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º:</b> {price_text} ‚ÇΩ\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image ({remaining_free} –¥–æ—Å—Ç—É–ø–Ω–æ)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å—ã\n\n"
                        f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient Funds for Generation</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>Your balance:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üíµ <b>Minimum required:</b> {price_text} ‚ÇΩ\n"
                        f"‚ùå <b>Need:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>What to do:</b>\n"
                        f"‚Ä¢ Top up balance via button below\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ Use free Z-Image generations ({remaining_free} available)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ Invite a friend and get bonuses\n\n"
                        f"üîÑ After topping up, try generation again."
                    )
                
                await query.edit_message_text(
                    insufficient_msg,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Store selected model
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
                logger.info(f"üî•üî•üî• SELECT_MODEL: Created new session for user_id={user_id}")
            user_sessions[user_id]['model_id'] = model_id
            user_sessions[user_id]['model_info'] = model_info
            logger.info(f"üî•üî•üî• SELECT_MODEL: Stored model in session: model_id={model_id}, user_id={user_id}, session_keys={list(user_sessions[user_id].keys())}")
            
            # Get input parameters from YAML schema (registry)
            from kie_input_adapter import get_schema
            schema = get_schema(model_id)
            if schema:
                input_params = schema
                logger.info(f"‚úÖ SELECT_MODEL: Using YAML schema: count={len(input_params)}, keys={list(input_params.keys())}, user_id={user_id}")
            else:
                # Fallback to model_info input_params if YAML schema not found
                input_params = model_info.get('input_params', {})
                logger.warning(f"‚ö†Ô∏è SELECT_MODEL: YAML schema not found, using fallback: count={len(input_params)}, keys={list(input_params.keys())}, user_id={user_id}")
            
            if not input_params:
                # If no params defined, ask for simple text input
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['params'] = {}
                user_sessions[user_id]['waiting_for'] = 'text'
                return INPUTTING_PARAMS
            
            # Store session data
            user_sessions[user_id]['params'] = {}
            user_sessions[user_id]['properties'] = input_params
            # Get required parameters from schema (required=True)
            user_sessions[user_id]['required'] = [p for p, info in input_params.items() if info.get('required', False)]
            user_sessions[user_id]['current_param'] = None
            
            # Determine parameter order: image/video/audio input ‚Üí prompt/text ‚Üí optional
            # Priority: media inputs first, then prompt/text, then optional
            param_order = []
            media_params = []  # image_input, video_input, audio_input, image_urls, etc.
            text_params = []   # prompt, text, etc.
            other_required = []  # other required params
            optional_params = []  # optional params
            
            for param_name, param_info in input_params.items():
                is_required = param_info.get('required', False)
                param_type = param_info.get('type', 'string')
                param_name_lower = param_name.lower()
                
                # Media inputs first
                if any(keyword in param_name_lower for keyword in ['image', 'video', 'audio', 'url']):
                    if is_required:
                        media_params.append(param_name)
                    else:
                        optional_params.append(param_name)
                # Text/prompt params second
                elif any(keyword in param_name_lower for keyword in ['prompt', 'text']):
                    if is_required:
                        text_params.append(param_name)
                    else:
                        optional_params.append(param_name)
                # Other required params
                elif is_required:
                    other_required.append(param_name)
                # Optional params last
                else:
                    optional_params.append(param_name)
            
            # Build final order: media ‚Üí text ‚Üí other required ‚Üí optional
            param_order = media_params + text_params + other_required + optional_params
            user_sessions[user_id]['param_order'] = param_order
            logger.info(f"‚úÖ SELECT_MODEL: Parameter order determined: {param_order}, user_id={user_id}")
            
            # Start with first required parameter (or first in order if no required)
            # Priority: media inputs first, then prompt/text, then optional
            # Special case: nano-banana-pro starts with image_input first
            if model_id == "nano-banana-pro" and 'image_input' in input_params and input_params['image_input'].get('required', False):
                # Start with image_input first for nano-banana-pro
                has_image_input = True
                image_param_name = 'image_input'
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                try:
                    await query.edit_message_text(
                        f"{model_info_text}\n\n"
                        f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
                        f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    # If edit fails, try to send new message
                    logger.warning(f"Could not edit message for nano-banana-pro: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            f"{model_info_text}\n\n"
                            f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                            f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except Exception as send_error:
                        logger.error(f"Could not send new message for nano-banana-pro: {send_error}", exc_info=True)
                        await query.answer(t('error_try_start', lang=user_lang), show_alert=True)
                        return ConversationHandler.END
                user_sessions[user_id]['current_param'] = 'image_input'
                user_sessions[user_id]['waiting_for'] = 'image_input'
                if 'image_input' not in user_sessions[user_id]:
                    user_sessions[user_id]['image_input'] = []  # Initialize as array
                return INPUTTING_PARAMS
            
            # Special case: sora-2-pro-image-to-video starts with image_urls first
            if model_id == "sora-2-pro-image-to-video" and 'image_urls' in input_params and input_params['image_urls'].get('required', False):
                # Start with image_urls first for sora-2-pro-image-to-video
                has_image_input = True
                image_param_name = 'image_urls'
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                try:
                    await query.edit_message_text(
                        f"{model_info_text}\n\n"
                        f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫–∞–∫ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –≤–∏–¥–µ–æ.\n\n"
                        f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    # If edit fails, try to send new message
                    logger.warning(f"Could not edit message for sora-2-pro-image-to-video: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            f"{model_info_text}\n\n"
                            f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                            f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫–∞–∫ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –≤–∏–¥–µ–æ.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except Exception as send_error:
                        logger.error(f"Could not send new message for sora-2-pro-image-to-video: {send_error}", exc_info=True)
                        await query.answer(t('error_try_start', lang=user_lang), show_alert=True)
                        return ConversationHandler.END
                user_sessions[user_id]['current_param'] = 'image_urls'
                user_sessions[user_id]['waiting_for'] = 'image_urls'
                if 'image_urls' not in user_sessions[user_id]:
                    user_sessions[user_id]['image_urls'] = []  # Initialize as array
                return INPUTTING_PARAMS
            
            # Start with prompt parameter first (if exists) - default behavior
            # Or start with audio_url if no prompt and audio_url is required
            if 'prompt' in input_params:
                # Check if model supports image input (image_input or image_urls)
                # BUT: z-image does NOT support image input (text-to-image only)
                # AND: text-to-video models do NOT require image input (text-to-video only)
                is_text_to_video = "text-to-video" in model_id.lower()
                has_image_input = (model_id != "z-image" and 
                                 not is_text_to_video and
                                 ('image_input' in input_params or 'image_urls' in input_params))
                has_audio_input = 'audio_url' in input_params or 'audio_input' in input_params
                
                prompt_text = (
                    f"{model_info_text}"
                )
                
                # Determine if this is a video or audio model
                is_video = is_video_model(model_id)
                is_audio = is_audio_model(model_id)
                
                if has_image_input:
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                            f"üí° –ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\n\n"
                            f"üí° –ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"
                        )
                elif has_audio_input:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</b>\n\n"
                        f"–î–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –ø—Ä–æ–º–ø—Ç –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"üí° –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –≤—ã —Å–º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª"
                    )
                else:
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                        )
                    elif is_audio:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:"
                        )
                
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                await query.edit_message_text(
                    prompt_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'prompt'
                user_sessions[user_id]['waiting_for'] = 'prompt'
                user_sessions[user_id]['has_image_input'] = has_image_input
                user_sessions[user_id]['has_audio_input'] = has_audio_input
            elif 'audio_url' in input_params and input_params['audio_url'].get('required', False):
                # If no prompt but audio_url is required, start with audio_url
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"üìù <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª</b>\n\n"
                    f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏.\n\n"
                    f"–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG\n"
                    f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'audio_url'
                user_sessions[user_id]['waiting_for'] = 'audio_url'
            elif ('image_input' in input_params and input_params['image_input'].get('required', False)) or \
                 ('image_urls' in input_params and input_params['image_urls'].get('required', False)):
                # If no prompt but image_input or image_urls is required, start with image
                param_name = 'image_input' if 'image_input' in input_params else 'image_urls'
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                    f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.\n\n"
                    f"üí° –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                    f"üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = param_name
                user_sessions[user_id]['waiting_for'] = param_name  # Use actual parameter name
                # CRITICAL: Initialize image_input/image_urls array for image-only models
                if param_name not in user_sessions[user_id]:
                    user_sessions[user_id][param_name] = []
                logger.info(f"üî•üî•üî• SET waiting_for={param_name} for model {model_id}, user {user_id}, initialized {param_name} array")
            else:
                # If no prompt, start with first required parameter
                await start_next_parameter(update, context, user_id)
            
            logger.info(f"üî•üî•üî• SELECT_MODEL: RETURNING INPUTTING_PARAMS for user {user_id}, model {model_id}, waiting_for={user_sessions[user_id].get('waiting_for', 'None')}")
            return INPUTTING_PARAMS
        
        # Handle confirm_generate as fallback (in case state didn't switch properly)
        if data == "confirm_generate":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            logger.info(f"confirm_generate callback received in button_callback (fallback)")
            # Call confirm_generation function directly
            # üî¥ API CALL: confirm_generation –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å KIE API
            try:
                await confirm_generation(update, context)
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå ERROR in confirm_generation fallback: {e}", exc_info=True)
                try:
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                    await query.answer(error_msg, show_alert=True)
                except Exception:
                    pass
                return ConversationHandler.END
    
    # If we get here and no handler matched, log and return END
    except Exception as e:
        logger.error(f"Error in button_callback for data '{data}': {e}", exc_info=True)
        try:
            await query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start", show_alert=True)
        except:
            pass
        return ConversationHandler.END
    
    # üî¥ FALLBACK - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö callback_data
    # –≠—Ç–æ –∑–∞—â–∏—Ç–∞ –æ—Ç —Å–±–æ–µ–≤ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è—Ö - –µ—Å–ª–∏ –∫–∞–∫–∞—è-—Ç–æ –∫–Ω–æ–ø–∫–∞ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞,
    # –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∏—Ç –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
    # –í–ê–ñ–ù–û: –≠—Ç–æ—Ç –∫–æ–¥ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã—à–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
    
    logger.warning(f"‚ö†Ô∏è Unhandled callback_data: '{data}' from user {user_id}")
    
    # –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ–º —á—Ç–æ –¥–µ–ª–∞—Ç—å
    try:
        user_lang = get_user_language(user_id) if user_id else 'ru'
        error_msg = t('error_button_outdated', lang=user_lang) if 'error_button_outdated' in TRANSLATIONS.get(user_lang, {}) else (
            "–ö–Ω–æ–ø–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ /start" if user_lang == 'ru' else "Button outdated, open /start"
        )
        await query.answer(error_msg, show_alert=True)
    except Exception:
        pass
    return ConversationHandler.END


async def start_next_parameter(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int):
    """Start input for next parameter."""
    if user_id not in user_sessions:
        logger.error(f"User {user_id} session not found in start_next_parameter")
        return None
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    params = session.get('params', {})
    required = session.get('required', [])
    
    # For elevenlabs/speech-to-text, also show optional parameters
    model_id = session.get('model_id', '')
    all_params_to_check = required.copy()
    if model_id == "elevenlabs/speech-to-text":
        # Add optional parameters that should be shown to user
        for param_name in ['language_code', 'tag_audio_events', 'diarize']:
            if param_name in properties and param_name not in all_params_to_check:
                all_params_to_check.append(param_name)
    
    # For models with resolution/aspect_ratio that affect price, always show them
    # even if optional, so user can choose
    resolution_aspect_models = [
        "nano-banana-pro",  # resolution affects price
        "sora-2-text-to-video",  # aspect_ratio is required but may be missing from required list
        "sora-2-image-to-video",  # aspect_ratio may be required
    ]
    if model_id in resolution_aspect_models:
        # Add resolution/aspect_ratio to check list if they exist in properties
        for param_name in ['resolution', 'aspect_ratio']:
            if param_name in properties and param_name not in all_params_to_check:
                # Check if it's in required list or if it affects price
                param_info = properties.get(param_name, {})
                if param_info.get('required', False) or param_name == 'resolution':
                    all_params_to_check.append(param_name)
    
    # Handle mask_input and reference_image_input as special image parameters (before regular parameters)
    for special_param in ['mask_input', 'reference_image_input']:
        if special_param in all_params_to_check and special_param not in params:
            param_info = properties.get(special_param, {})
            if param_info.get('required', False):
                # This is a required image parameter
                session['current_param'] = special_param
                session['waiting_for'] = special_param
                if special_param not in session:
                    session[special_param] = []  # Initialize as array
                
                # Get chat_id from update
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                param_desc = param_info.get('description', '')
                if special_param == 'mask_input':
                    prompt_text = (
                        f"üé≠ <b>–®–∞–≥: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É</b>\n\n"
                        f"{param_desc}\n\n"
                        f"üí° –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                        f"üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB"
                    )
                elif special_param == 'reference_image_input':
                    prompt_text = (
                        f"üñºÔ∏è <b>–®–∞–≥: –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        f"{param_desc}\n\n"
                        f"üí° –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                        f"üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB"
                    )
                else:
                    prompt_text = (
                        f"üì∑ <b>–®–∞–≥: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        f"{param_desc}\n\n"
                        f"üí° –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                        f"üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB"
                    )
                
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=prompt_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
    
    # Find next unset parameter (skip prompt, image_input, image_urls, audio_url, audio_input, mask_input, reference_image_input as they're handled separately)
    # BUT: for nano-banana-pro, we want: image_input -> prompt -> aspect_ratio -> resolution
    # For sora-2-text-to-video: prompt -> aspect_ratio
    for param_name in all_params_to_check:
        # Skip special parameters that are handled separately
        if param_name in ['image_input', 'image_urls', 'audio_url', 'audio_input', 'mask_input', 'reference_image_input']:
            continue
        
        # For nano-banana-pro: handle prompt after image_input, then aspect_ratio, then resolution
        if model_id == "nano-banana-pro":
            if param_name == 'prompt':
                # Only ask for prompt if image_input is already set
                if 'image_input' not in params or not params.get('image_input'):
                    continue  # Skip prompt until image_input is set
            elif param_name == 'aspect_ratio':
                # Only ask for aspect_ratio if prompt is already set
                if 'prompt' not in params or not params.get('prompt'):
                    continue  # Skip aspect_ratio until prompt is set
            elif param_name == 'resolution':
                # Only ask for resolution if aspect_ratio is already set (or if it doesn't exist)
                if 'aspect_ratio' in properties and 'aspect_ratio' not in params:
                    continue  # Skip resolution until aspect_ratio is set (if it exists)
        
        # For sora-2-text-to-video: handle aspect_ratio after prompt
        if model_id == "sora-2-text-to-video":
            if param_name == 'aspect_ratio':
                # Only ask for aspect_ratio if prompt is already set
                if 'prompt' not in params or not params.get('prompt'):
                    continue  # Skip aspect_ratio until prompt is set
        
        # Skip prompt if it's not handled by special cases above
        if param_name == 'prompt':
            continue
        
        if param_name not in params:
            param_info = properties.get(param_name, {})
            param_type = param_info.get('type', 'string')
            enum_values = param_info.get('enum')
            
            session['current_param'] = param_name
            
            # Handle boolean parameters
            if param_type == 'boolean':
                default_value = param_info.get('default', False)
                is_optional = not param_info.get('required', False)
                
                keyboard = [
                    [
                        InlineKeyboardButton("‚úÖ –î–∞ (true)", callback_data=f"set_param:{param_name}:true"),
                        InlineKeyboardButton("‚ùå –ù–µ—Ç (false)", callback_data=f"set_param:{param_name}:false")
                    ]
                ]
                
                # For optional parameters, add "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å" button
                user_lang = get_user_language(user_id)
                if is_optional:
                    skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (default)"
                    keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{str(default_value).lower()}")])
                
                keyboard.append([
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ])
                keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
                
                param_desc = param_info.get('description', '')
                default_text = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {'–î–∞' if default_value else '–ù–µ—Ç'}" if is_optional else ""
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"üìù <b>–í—ã–±–µ—Ä–∏—Ç–µ {param_name}:</b>\n\n{param_desc}{default_text}",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['waiting_for'] = param_name
                return INPUTTING_PARAMS
            # If parameter has enum values, show buttons
            elif enum_values:
                logger.info(f"üî• start_next_parameter: {param_name} has enum values, showing buttons, user_id={user_id}")
                keyboard = []
                # Create buttons in rows of 2
                for i in range(0, len(enum_values), 2):
                    row = []
                    row.append(InlineKeyboardButton(
                        enum_values[i],
                        callback_data=f"set_param:{param_name}:{enum_values[i]}"
                    ))
                    if i + 1 < len(enum_values):
                        row.append(InlineKeyboardButton(
                            enum_values[i + 1],
                            callback_data=f"set_param:{param_name}:{enum_values[i + 1]}"
                        ))
                    keyboard.append(row)
                
                # For optional enum parameters with default, add "Use default" button
                is_optional = not param_info.get('required', False)
                default_value = param_info.get('default')
                if is_optional and default_value and default_value in enum_values:
                    user_lang = get_user_language(user_id)
                    default_text = f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ({default_value})" if user_lang == 'ru' else f"‚è≠Ô∏è Use default ({default_value})"
                    keyboard.append([InlineKeyboardButton(default_text, callback_data=f"set_param:{param_name}:{default_value}")])
                
                user_lang = get_user_language(user_id)
                keyboard.append([
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ])
                keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
                
                param_desc = param_info.get('description', '')
                default_info = ""
                if default_value and default_value in enum_values:
                    default_info = f"\n\nüí° –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>{default_value}</b>" if user_lang == 'ru' else f"\n\nüí° Default: <b>{default_value}</b>"
                
                # Get chat_id from update
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                logger.info(f"üî• start_next_parameter: sending message for {param_name} to chat_id={chat_id}, user_id={user_id}")
                
                # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
                try:
                    from optimization_ux import get_parameter_hint
                    hint = get_parameter_hint(param_name, user_lang)
                    if hint:
                        param_desc = f"{param_desc}\n\nüí° <i>{hint}</i>" if param_desc else f"üí° <i>{hint}</i>"
                except ImportError:
                    pass  # –ú–æ–¥—É–ª—å –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω
                
                # –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è enum –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                param_display_name = param_name.replace('_', ' ').title()
                message_text = (
                    f"üìù <b>–í—ã–±–µ—Ä–∏—Ç–µ {param_display_name.lower()}:</b>\n\n"
                    f"{param_desc}{default_info}\n\n"
                    f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ\n"
                    f"‚Ä¢ –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"
                )
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['waiting_for'] = param_name
                session['current_param'] = param_name
                logger.info(f"üî• start_next_parameter: set waiting_for={param_name}, returning INPUTTING_PARAMS, user_id={user_id}")
                return INPUTTING_PARAMS
            else:
                # Text input
                param_desc = param_info.get('description', '')
                max_length = param_info.get('max_length')
                max_text = f"\n\n–ú–∞–∫—Å–∏–º—É–º {max_length} —Å–∏–º–≤–æ–ª–æ–≤." if max_length else ""
                is_optional = not param_info.get('required', False)
                default_value = param_info.get('default')
                
                # Get chat_id from update
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                keyboard = []
                # For optional text parameters, add skip button with default value info
                if is_optional:
                    if default_value:
                        # Special handling for language_code - show quick select buttons
                        if param_name == 'language_code' and default_value == 'ru':
                            keyboard.append([
                                InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π (ru)", callback_data=f"set_param:{param_name}:ru"),
                                InlineKeyboardButton("üá∫üá∏ English (en)", callback_data=f"set_param:{param_name}:en")
                            ])
                            keyboard.append([
                                InlineKeyboardButton("üá©üá™ Deutsch (de)", callback_data=f"set_param:{param_name}:de"),
                                InlineKeyboardButton("üá´üá∑ Fran√ßais (fr)", callback_data=f"set_param:{param_name}:fr")
                            ])
                            keyboard.append([InlineKeyboardButton("‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (ru)", callback_data=f"set_param:{param_name}:ru")])
                            keyboard.append([InlineKeyboardButton("‚úèÔ∏è –í–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–π –∫–æ–¥", callback_data=f"set_param:{param_name}:custom")])
                        else:
                            default_text = f" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value})" if default_value else ""
                            keyboard.append([InlineKeyboardButton(f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é{default_text}", callback_data=f"set_param:{param_name}:{default_value}")])
                    else:
                        user_lang = get_user_language(user_id)
                        skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (optional)"
                        keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:")])
                user_lang = get_user_language(user_id)
                keyboard.append([
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ])
                keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
                
                default_info = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value}" if default_value and is_optional else ""
                optional_text = "\n\n(–≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)" if is_optional else ""
                
                # –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –±–æ–ª–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–º–∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏
                param_display_name = param_name.replace('_', ' ').title()
                message_text = (
                    f"üìù <b>–í–≤–µ–¥–∏—Ç–µ {param_display_name.lower()}:</b>\n\n"
                    f"{param_desc}{max_text}{default_info}{optional_text}\n\n"
                    f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                    f"‚Ä¢ –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É \"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\" –Ω–∏–∂–µ"
                )
                
                # If language_code with quick select, modify message
                if param_name == 'language_code' and default_value == 'ru':
                    message_text = (
                        f"üåç <b>–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∞—É–¥–∏–æ:</b>\n\n"
                        f"{param_desc}\n\n"
                        f"–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>–†—É—Å—Å–∫–∏–π (ru)</b>\n\n"
                        f"–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ —è–∑—ã–∫–∞ –≤—Ä—É—á–Ω—É—é."
                    )
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                
                # If custom input requested, set waiting state
                if param_name == 'language_code' and default_value == 'ru':
                    # Don't set waiting_for yet - wait for button or text input
                    session['language_code_custom'] = False
                else:
                    session['waiting_for'] = param_name
                return INPUTTING_PARAMS
    
    # All parameters collected
    return None


async def input_parameters(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle parameter input."""
    import time
    start_time = time.time()
    user_id = update.effective_user.id
    
    # ==================== NO-SILENCE GUARD: Track outgoing actions ====================
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
    guard = get_no_silence_guard()
    update_id = update.update_id
    # ==================== END NO-SILENCE GUARD ====================
    
    # CRITICAL: Log function entry IMMEDIATELY
    logger.info(f"üö®üö®üö® INPUT_PARAMETERS FUNCTION CALLED: user_id={user_id}, update_type={type(update).__name__}")
    
    # üî• MAXIMUM LOGGING: Log ALL input_parameters calls
    has_photo = bool(update.message and update.message.photo)
    has_text = bool(update.message and update.message.text)
    has_audio = bool(update.message and (update.message.audio or update.message.voice))
    has_document = bool(update.message and update.message.document)
    logger.info(f"üî•üî•üî• INPUT_PARAMETERS ENTRY: user_id={user_id}, has_photo={has_photo}, has_text={has_text}, has_audio={has_audio}, has_document={has_document}, update_type={type(update).__name__}")
    
    # CRITICAL: Log photo details if photo is present
    if has_photo and update.message and update.message.photo:
        photo_count = len(update.message.photo) if update.message.photo else 0
        photo_file_id = update.message.photo[-1].file_id if update.message.photo else 'None'
        logger.info(f"üî•üî•üî• PHOTO DETECTED: user_id={user_id}, photo_count={photo_count}, file_id={photo_file_id}")
    
    if update.message:
        logger.info(f"üî•üî•üî• INPUT_PARAMETERS MESSAGE: message_id={update.message.message_id}, chat_id={update.message.chat_id}, date={update.message.date}, from_user_id={update.message.from_user.id if update.message.from_user else 'None'}")
        if has_photo:
            photo_count = len(update.message.photo) if update.message.photo else 0
            logger.info(f"üî•üî•üî• INPUT_PARAMETERS PHOTO: photo_count={photo_count}, file_id={update.message.photo[-1].file_id if update.message.photo else 'None'}, file_size={update.message.photo[-1].file_size if update.message.photo and update.message.photo[-1].file_size else 'Unknown'}")
    
    if user_id not in user_sessions:
        logger.error(f"‚ùå‚ùå‚ùå CRITICAL ERROR: User {user_id} not in user_sessions in input_parameters!")
        logger.error(f"   This means session was lost. User needs to select model again.")
        logger.error(f"   Available sessions: {list(user_sessions.keys())[:10]}")
        logger.error(f"   Total sessions: {len(user_sessions)}")
        if update.message:
            if has_photo:
                # Photo sent but no session - try to help user
                await update.message.reply_text(
                    "‚ùå <b>–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</b>\n\n"
                    "–ü–æ—Ö–æ–∂–µ, —Å–µ—Å—Å–∏—è –±—ã–ª–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                    "1. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ /start\n"
                    "2. –ó–∞—Ç–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n\n"
                    "–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
            else:
                await update.message.reply_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    model_id = session.get('model_id', 'Unknown')
    waiting_for = session.get('waiting_for', 'None')
    properties = session.get('properties', {})
    params = session.get('params', {})
    has_image_input = 'image_input' in properties
    has_image_urls = 'image_urls' in properties
    logger.info(f"üî•üî•üî• INPUT_PARAMETERS SESSION: user_id={user_id}, model_id={model_id}, waiting_for={waiting_for}, has_image_input={has_image_input}, has_image_urls={has_image_urls}")
    
    # CRITICAL: Define models_only_image at function level so it's available everywhere
    models_only_image = [
        "recraft/remove-background",
        "recraft/crisp-upscale",
        "topaz/image-upscale",
        "ideogram/v3-reframe"
    ]
    logger.info(f"üî•üî•üî• INPUT_PARAMETERS SESSION KEYS: {list(session.keys())[:15]}")
    logger.info(f"üî•üî•üî• INPUT_PARAMETERS PARAMS: keys={list(params.keys())}, values={[(k, type(v).__name__, len(v) if isinstance(v, (list, dict)) else 'N/A') for k, v in params.items()][:5]}")
    
    # CRITICAL: If photo is sent but session doesn't have waiting_for set, log warning
    if has_photo and not waiting_for:
        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PHOTO SENT BUT waiting_for is None! user_id={user_id}, model_id={model_id}, properties={list(properties.keys())}, session_keys={list(session.keys())[:10]}")
    
    # Handle admin OCR test
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'admin_test_ocr':
        if update.message.photo:
            photo = update.message.photo[-1]
            loading_msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
            
            try:
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Test OCR - extract text
                try:
                    image = Image.open(BytesIO(image_data))
                    try:
                        extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
                    except Exception as e:
                        logger.warning(f"Error with rus+eng, trying eng only: {e}")
                        try:
                            extracted_text = pytesseract.image_to_string(image, lang='eng')
                        except Exception as e2:
                            logger.warning(f"Error with eng, trying default: {e2}")
                            extracted_text = pytesseract.image_to_string(image)
                except Exception as e:
                    error_msg = str(e)
                    if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower():
                        raise Exception("Tesseract OCR –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ PATH.")
                    else:
                        raise Exception(f"–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: {error_msg}")
                
                extracted_text_lower = extracted_text.lower()
                
                # Find amounts in text (improved patterns)
                amount_patterns = [
                    # With currency symbols
                    r'(\d+[.,]\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+[.,]\d+)',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+)',
                    # Near payment keywords
                    r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]+(\d+[.,]?\d*)',
                    r'(\d+[.,]?\d*)\s*(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)',
                    # Misrecognized currency (B instead of –†, 2 instead of –†)
                    r'(\d+)\s*[B2]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†B2]',
                    # Standalone numbers (filtered later)
                    r'\b(\d{2,6})\b',
                ]
                
                found_amounts = []
                for pattern in amount_patterns:
                    matches = re.findall(pattern, extracted_text, re.IGNORECASE)
                    for match in matches:
                        try:
                            amount = float(match.replace(',', '.'))
                            # Filter reasonable amounts (10-100000 rubles)
                            if 10 <= amount <= 100000:
                                found_amounts.append(amount)
                        except:
                            continue
                
                # Check for payment keywords
                payment_keywords = [
                    '–ø–µ—Ä–µ–≤–æ–¥', '–æ–ø–ª–∞—Ç–∞', '–ø–ª–∞—Ç–µ–∂', '—Å–ø–±', '—Å–±–ø', 'payment', 'transfer',
                    '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', '—É—Å–ø–µ—à–Ω–æ', 'success', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', '—Å—É–º–º–∞', '–∏—Ç–æ–≥–æ',
                    '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '—Å—Ç–∞—Ç—É—Å', 'status', '–∫–æ–º–∏—Å—Å–∏—è', 'commission'
                ]
                has_keywords = any(keyword in extracted_text_lower for keyword in payment_keywords)
                
                # Prepare result
                result_text = "üß™ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞ OCR:</b>\n\n"
                
                result_text += f"üìù <b>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (–ø–µ—Ä–≤—ã–µ 300 —Å–∏–º–≤–æ–ª–æ–≤):</b>\n"
                result_text += f"<code>{extracted_text[:300].replace('<', '&lt;').replace('>', '&gt;')}</code>\n\n"
                
                if found_amounts:
                    result_text += f"üí∞ <b>–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å—É–º–º—ã:</b>\n"
                    for amt in sorted(set(found_amounts), reverse=True)[:5]:
                        result_text += f"  ‚Ä¢ {amt:.2f} ‚ÇΩ\n"
                    result_text += "\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–°—É–º–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                
                if has_keywords:
                    result_text += "‚úÖ <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                
                result_text += f"\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                result_text += f"  ‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {len(extracted_text)}\n"
                result_text += f"  ‚Ä¢ –°—É–º–º –Ω–∞–π–¥–µ–Ω–æ: {len(found_amounts)}\n"
                result_text += f"  ‚Ä¢ –ö–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤: {'–î–∞' if has_keywords else '–ù–µ—Ç'}\n"
                
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –¢–µ—Å—Ç –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    result_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in admin OCR test: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                error_msg = str(e)
                help_text = ""
                if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower() or "tesseract" in error_msg.lower():
                    help_text = (
                        "\n\nüí° <b>–†–µ—à–µ–Ω–∏–µ:</b>\n"
                        "1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ Tesseract —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\n"
                        "2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å: C:\\Program Files\\Tesseract-OCR\\tesseract.exe\n"
                        "3. –ò–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ Tesseract –≤ PATH —Å–∏—Å—Ç–µ–º—ã\n"
                        "4. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏"
                    )
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ OCR:</b>\n\n{error_msg}{help_text}\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ADMIN_TEST_OCR
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return ADMIN_TEST_OCR
    
    # Handle broadcast message
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'broadcast_message':
        import time
        from datetime import datetime
        
        # Get message content
        message_text = None
        message_photo = None
        
        if update.message.text:
            message_text = update.message.text
        elif update.message.caption:
            message_text = update.message.caption
        
        if update.message.photo:
            message_photo = update.message.photo[-1]
        
        if not message_text and not message_photo:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_BROADCAST_MESSAGE
        
        # Get all users
        all_users = get_all_users()
        total_users = len(all_users)
        
        if total_users == 0:
            await update.message.reply_text(
                "‚ùå <b>–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–í –±–∞–∑–µ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
                parse_mode='HTML'
            )
            if user_id in user_sessions:
                del user_sessions[user_id]['waiting_for']
            return ConversationHandler.END
        
        # Create broadcast record
        broadcast_data = {
            'id': len(get_broadcasts()) + 1,
            'message': message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]',
            'created_at': int(time.time()),
            'created_by': user_id,
            'total_users': total_users,
            'sent': 0,
            'delivered': 0,
            'failed': 0,
            'user_ids': []
        }
        
        broadcast_id = save_broadcast(broadcast_data)
        
        # Confirm and start sending
        await update.message.reply_text(
            f"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
            f"üë• <b>–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
            f"üìù <b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b> {message_text[:50] + '...' if message_text and len(message_text) > 50 else message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]'}\n\n"
            f"‚è≥ –ù–∞—á–∏–Ω–∞—é –æ—Ç–ø—Ä–∞–≤–∫—É...",
            parse_mode='HTML'
        )
        
        # Clear waiting state
        if user_id in user_sessions:
            del user_sessions[user_id]['waiting_for']
        
        # Start broadcast in background
        asyncio.create_task(send_broadcast(context, broadcast_id, all_users, message_text, message_photo))
        
        return ConversationHandler.END
    
    # Handle currency rate input
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'currency_rate':
        if not update.message.text:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã.\n\n"
                "–ù–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> –∏–ª–∏ <code>95.5</code>\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
        
        try:
            # Parse currency rate
            rate_text = update.message.text.strip().replace(',', '.')
            new_rate = float(rate_text)
            
            if new_rate <= 0:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                    "–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return WAITING_CURRENCY_RATE
            
            # Save currency rate
            if set_usd_to_rub_rate(new_rate):
                old_rate = get_usd_to_rub_rate()
                await update.message.reply_text(
                    f"‚úÖ <b>–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω!</b>\n\n"
                    f"üìä <b>–ù–æ–≤—ã–π –∫—É—Ä—Å:</b>\n"
                    f"1 USD = {new_rate:.2f} RUB\n\n"
                    f"üí° –í—Å–µ —Ü–µ–Ω—ã –±—É–¥—É—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ.",
                    parse_mode='HTML'
                )
                
                # Clear waiting state
                if user_id in user_sessions:
                    del user_sessions[user_id]['waiting_for']
                
                return ConversationHandler.END
            else:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—É—Ä—Å–∞</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫—É—Ä—Å –≤–∞–ª—é—Ç—ã.\n\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return WAITING_CURRENCY_RATE
                
        except ValueError:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–∞.\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> –∏–ª–∏ <code>95.5</code>\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
        except Exception as e:
            logger.error(f"Error setting currency rate: {e}")
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
    
    # Handle payment screenshot
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'payment_screenshot':
        if update.message.photo:
            # User sent payment screenshot
            if user_id not in user_sessions:
                await update.message.reply_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            photo = update.message.photo[-1]
            screenshot_file_id = photo.file_id
            
            session = user_sessions[user_id]
            amount = session.get('topup_amount', 0)
            
            # Download and analyze screenshot (if OCR available)
            if OCR_AVAILABLE and PIL_AVAILABLE:
                loading_msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–∫—Ä–∏–Ω—à–æ—Ç...")
            else:
                loading_msg = await update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –ø–ª–∞—Ç–µ–∂...")
            
            try:
                # Check for duplicate screenshot
                if check_duplicate_payment(screenshot_file_id):
                    await update.message.reply_text(
                        f"‚ö†Ô∏è <b>–≠—Ç–æ—Ç —Å–∫—Ä–∏–Ω—à–æ—Ç —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω</b>\n\n"
                        f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞.\n\n"
                        f"–ï—Å–ª–∏ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —ç—Ç–æ –Ω–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                        parse_mode='HTML'
                    )
                    return WAITING_PAYMENT_SCREENSHOT
                
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Get expected phone from .env
                expected_phone = os.getenv('PAYMENT_PHONE', '')
                
                # Analyze screenshot (only if OCR available)
                analysis_msg = None
                if OCR_AVAILABLE and PIL_AVAILABLE:
                    # üî¥ API CALL: OCR API - analyze_payment_screenshot
                    try:
                        analysis = await analyze_payment_screenshot(image_data, amount, expected_phone if expected_phone else None)
                    except Exception as e:
                        logger.error(f"‚ùå‚ùå‚ùå OCR API ERROR in analyze_payment_screenshot: {e}", exc_info=True)
                        # If OCR fails, allow payment without check
                        analysis = {
                            'valid': True,  # Allow without OCR check
                            'message': '‚ÑπÔ∏è OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
                        }
                    
                    # Delete loading message
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                    
                    # Check if screenshot is valid - STRICT CHECK (default False)
                    if not analysis.get('valid', False):
                        support_info = get_support_contact()
                        await update.message.reply_text(
                            f"‚ùå <b>–°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ –ø—Ä–æ—à–µ–ª –ø—Ä–æ–≤–µ—Ä–∫—É</b>\n\n"
                            f"{analysis.get('message', '')}\n\n"
                            f"üòî <b>–ò–∑–≤–∏–Ω–∏—Ç–µ!</b> –ï—Å–ª–∏ –Ω–∞—à–∞ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª–∞ –≤–∞—à—É –æ–ø–ª–∞—Ç—É, –Ω–∞–ø–∏—à–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É - –æ–Ω –ø–æ—Å—Ç–∞—Ä–∞–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ –Ω–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å.\n\n"
                            f"{support_info}",
                            parse_mode='HTML'
                        )
                        return WAITING_PAYMENT_SCREENSHOT
                    
                    # Show analysis results
                    analysis_msg = await update.message.reply_text(
                        f"üîç <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏:</b>\n\n"
                        f"{analysis.get('message', '')}\n\n"
                        f"‚è≥ –ù–∞—á–∏—Å–ª—è—é –±–∞–ª–∞–Ω—Å...",
                        parse_mode='HTML'
                    )
                else:
                    # OCR not available - skip analysis and credit balance directly
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                
                # Add payment and auto-credit balance
                payment = add_payment(user_id, amount, screenshot_file_id)
                new_balance = await get_user_balance_async(user_id)
                balance_str = f"{new_balance:.2f}".rstrip('0').rstrip('.')
                
                # Delete analysis message (if exists)
                if analysis_msg:
                    try:
                        await analysis_msg.delete()
                    except:
                        pass
                
                # Clean up session
                del user_sessions[user_id]
                
                # Create keyboard with main menu button
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                user_lang = get_user_language(user_id)
                
                if user_lang == 'ru':
                    payment_success_msg = (
                        f"‚úÖ <b>–û–ü–õ–ê–¢–ê –ü–û–õ–£–ß–ï–ù–ê!</b> ‚úÖ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üíµ <b>–°—É–º–º–∞:</b> {amount:.2f} ‚ÇΩ\n"
                        f"üí∞ <b>–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üéâ <b>–û—Ç–ª–∏—á–Ω–æ! –ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω!</b>\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                        f"‚Ä¢ –ù–∞—á–Ω–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å\n"
                        f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª—é–±—É—é –º–æ–¥–µ–ª—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞\n"
                        f"‚Ä¢ –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –ø—Ä–µ–º–∏—É–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏!\n\n"
                        f"‚ú® <b>–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–≤–µ—Ä–∏–µ!</b>"
                    )
                else:
                    payment_success_msg = (
                        f"‚úÖ <b>PAYMENT RECEIVED!</b> ‚úÖ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üíµ <b>Amount:</b> {amount:.2f} ‚ÇΩ\n"
                        f"üí∞ <b>New balance:</b> {balance_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üéâ <b>Great! Balance topped up!</b>\n\n"
                        f"üí° <b>What's next:</b>\n"
                        f"‚Ä¢ Start content generation right now\n"
                        f"‚Ä¢ Use any model from the catalog\n"
                        f"‚Ä¢ Enjoy premium features!\n\n"
                        f"‚ú® <b>Thank you for your trust!</b>"
                    )
                
                await update.message.reply_text(
                    payment_success_msg,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
                
            except Exception as e:
                logger.error(f"Error processing payment screenshot: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞</b>\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –µ—â–µ —Ä–∞–∑.\n"
                    f"–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return WAITING_PAYMENT_SCREENSHOT
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return WAITING_PAYMENT_SCREENSHOT
    
    # Handle custom topup amount input
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'topup_amount_input':
        try:
            amount = float(update.message.text.replace(',', '.'))
            user_lang = get_user_language(user_id)
            
            if amount < 50:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Minimum top-up amount: 50 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            if amount > 50000:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50000 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Maximum top-up amount: 50000 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–í–´–ë–ï–†–ò –°–ü–û–°–û–ë –û–ü–õ–ê–¢–´:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>CHOOSE PAYMENT METHOD:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            # For English users - only Telegram Stars, no SBP
            if user_lang == 'en':
                keyboard = [
                    [InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}")],
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
            else:
                # For Russian users - both options
                keyboard = [
                    [
                        InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}"),
                        InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")
                    ],
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
            
            await update.message.reply_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        except ValueError:
            user_lang = get_user_language(user_id)
            if user_lang == 'ru':
                await update.message.reply_text(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1500)\n\n"
                    "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
                )
            else:
                await update.message.reply_text(
                    "‚ùå Please enter a number (e.g., 1500)\n\n"
                    "Or press /cancel to cancel."
                )
            return SELECTING_AMOUNT
    
    if user_id not in user_sessions:
        logger.warning(f"Session not found for user {user_id} in input_parameters")
        user_lang = get_user_language(user_id)
        error_msg = t('error_session_empty', lang=user_lang) if user_lang else "‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start"
        await update.message.reply_text(error_msg)
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    
    # CRITICAL: Log session state for debugging
    logger.info(f"Session state: user_id={user_id}, model_id={session.get('model_id', 'Unknown')}, waiting_for={session.get('waiting_for', 'None')}, has_properties={bool(properties)}")
    
    # Handle audio input (for audio_url or audio_input)
    waiting_for_audio = session.get('waiting_for') in ['audio_url', 'audio_input']
    if (update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith('audio/'))) and waiting_for_audio:
        # Get audio file
        audio_file = None
        if update.message.audio:
            audio_file = update.message.audio
        elif update.message.voice:
            audio_file = update.message.voice
        elif update.message.document:
            audio_file = update.message.document
        
        if not audio_file:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            return INPUTTING_PARAMS
        
        file = await context.bot.get_file(audio_file.file_id)
        
        # Download audio from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ...")
            
            # Download audio
            try:
                audio_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"Error downloading audio file from Telegram: {e}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 200MB as per API)
            if len(audio_data) > 200 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(audio_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ê—É–¥–∏–æ-—Ñ–∞–π–ª –ø—É—Å—Ç–æ–π.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Downloaded audio: {len(audio_data)} bytes")
            
            # Determine file extension
            file_extension = "mp3"
            if update.message.audio:
                if update.message.audio.mime_type:
                    if "wav" in update.message.audio.mime_type:
                        file_extension = "wav"
                    elif "ogg" in update.message.audio.mime_type:
                        file_extension = "ogg"
                    elif "aac" in update.message.audio.mime_type:
                        file_extension = "aac"
                    elif "mp4" in update.message.audio.mime_type:
                        file_extension = "m4a"
            elif update.message.document and update.message.document.mime_type:
                if "wav" in update.message.document.mime_type:
                    file_extension = "wav"
                elif "ogg" in update.message.document.mime_type:
                    file_extension = "ogg"
                elif "aac" in update.message.document.mime_type:
                    file_extension = "aac"
                elif "mp4" in update.message.document.mime_type:
                    file_extension = "m4a"
            
            # Upload to public hosting
            filename = f"audio_{user_id}_{audio_file.file_id[:8]}.{file_extension}"
            public_url = await upload_image_to_hosting(audio_data, filename=filename)
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Successfully uploaded audio to: {public_url}")
            
            # Set audio_url parameter
            audio_param_name = session.get('waiting_for', 'audio_url')
            if 'params' not in session:
                session['params'] = {}
            session['params'][audio_param_name] = public_url
            session[audio_param_name] = public_url  # Also store in session for consistency
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Confirm audio was set
            await update.message.reply_text(
                f"‚úÖ <b>–ê—É–¥–∏–æ-—Ñ–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω!</b>\n\n"
                f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...",
                parse_mode='HTML'
            )
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    await update.message.reply_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after audio input: {e}", exc_info=True)
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
            
        except Exception as e:
            logger.error(f"Error processing audio: {e}", exc_info=True)
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
    
    # Handle image input (for image_input, image_urls, mask_input, reference_image_input or 'image')
    waiting_for = session.get('waiting_for')
    waiting_for_image = waiting_for in ['image_input', 'image_urls', 'image', 'mask_input', 'reference_image_input']
    
    # CRITICAL: Log for debugging
    model_id = session.get('model_id', 'Unknown')
    properties = session.get('properties', {})
    logger.info(f"üîçüîçüîç Image input check: user_id={user_id}, waiting_for={waiting_for}, waiting_for_image={waiting_for_image}, has_photo={bool(update.message.photo)}, model_id={model_id}, has_image_input={bool('image_input' in properties)}, has_image_urls={bool('image_urls' in properties)}, session_keys={list(session.keys())[:10]}")
    
    # CRITICAL: If photo is sent and model requires image, but waiting_for is not set, auto-fix immediately
    if update.message.photo and not waiting_for_image:
        # Check if model requires image_input or image_urls
        if 'image_input' in properties or 'image_urls' in properties:
            # Determine which parameter name to use
            if 'image_input' in properties:
                image_param_name = 'image_input'
            elif 'image_urls' in properties:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
            
            # Check if this parameter is required
            param_info = properties.get(image_param_name, {})
            is_required = param_info.get('required', False)
            
            # Models that definitely require image first
            models_require_image = [
                "recraft/remove-background",
                "recraft/crisp-upscale",
                "ideogram/v3-reframe",
                "topaz/image-upscale",
                "nano-banana-pro"
            ]
            
            # Auto-fix if model requires image or is in the list
            if model_id in models_require_image or is_required:
                logger.warning(f"üîß AUTO-FIX: Photo sent for {model_id} but waiting_for={waiting_for}, fixing session immediately...")
                session['waiting_for'] = image_param_name
                session['current_param'] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                waiting_for_image = True
                waiting_for = image_param_name
                logger.info(f"‚úÖ‚úÖ‚úÖ AUTO-FIX COMPLETE: waiting_for={image_param_name}, model={model_id}, continuing image processing...")
    
    # If photo sent but not waiting for image, try to auto-fix session
    if update.message.photo and not waiting_for_image:
        model_id = session.get('model_id', 'Unknown')
        user_lang = get_user_language(user_id)
        
        # Check if model requires image_input
        properties = session.get('properties', {})
        has_image_param = 'image_input' in properties or 'image_urls' in properties
        
        # CRITICAL: Auto-fix session for models that require image_input
        # This handles cases where photo is sent but session state is lost or incorrect
        if has_image_param:
            # Check which parameter name to use
            if 'image_input' in properties:
                image_param_name = 'image_input'
            elif 'image_urls' in properties:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
            
            # Auto-fix for models that require image (nano-banana-pro, recraft models, ideogram, topaz, etc.)
            models_require_image_first = [
                "nano-banana-pro",
                "recraft/remove-background",
                "recraft/crisp-upscale",
                "ideogram/v3-reframe",
                "topaz/image-upscale",
                "recraft/remove-background"  # Explicitly include this
            ]
            if model_id in models_require_image_first or \
               (properties.get(image_param_name, {}).get('required', False)):
                logger.warning(f"‚ö†Ô∏è Photo sent for {model_id} but waiting_for={waiting_for}, fixing session...")
                session['waiting_for'] = image_param_name
                session['current_param'] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                # Update local variables to continue processing
                waiting_for_image = True
                waiting_for = image_param_name
                logger.info(f"‚úÖ‚úÖ‚úÖ Session fixed: waiting_for={image_param_name}, model={model_id}, continuing image processing...")
                # Continue to process the image below
            else:
                # Photo sent but not expected - show helpful message
                if user_lang == 'en':
                    error_msg = (
                        "‚ö†Ô∏è <b>Image not expected now</b>\n\n"
                        f"Current step: {waiting_for or 'none'}\n\n"
                        "Please follow the instructions or use /cancel to start over."
                    )
                else:
                    error_msg = (
                        "‚ö†Ô∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–µ–π—á–∞—Å</b>\n\n"
                        f"–¢–µ–∫—É—â–∏–π —à–∞–≥: {waiting_for or '–Ω–µ—Ç'}\n\n"
                        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –Ω–∞—á–∞–ª–∞ –∑–∞–Ω–æ–≤–æ."
                    )
                await update.message.reply_text(error_msg, parse_mode='HTML')
                return INPUTTING_PARAMS
        else:
            # Photo sent but not expected - show helpful message
            if user_lang == 'en':
                error_msg = (
                    "‚ö†Ô∏è <b>Image not expected now</b>\n\n"
                    f"Current step: {waiting_for or 'none'}\n\n"
                    "Please follow the instructions or use /cancel to start over."
                )
            else:
                error_msg = (
                    "‚ö†Ô∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–µ–π—á–∞—Å</b>\n\n"
                    f"–¢–µ–∫—É—â–∏–π —à–∞–≥: {waiting_for or '–Ω–µ—Ç'}\n\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –Ω–∞—á–∞–ª–∞ –∑–∞–Ω–æ–≤–æ."
                )
            await update.message.reply_text(error_msg, parse_mode='HTML')
            return INPUTTING_PARAMS
    
    # Process image if photo is sent and we're waiting for image
    if update.message.photo and waiting_for_image:
        logger.info(f"‚úÖ‚úÖ‚úÖ Processing image for user {user_id}, waiting_for={waiting_for}, model={session.get('model_id', 'Unknown')}, image_param_name will be determined from waiting_for")
        photo = update.message.photo[-1]  # Get largest photo
        file = await context.bot.get_file(photo.file_id)
        
        # Download image from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞...")
            
            # Download image
            try:
                image_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå ERROR DOWNLOADING IMAGE: user_id={user_id}, error={str(e)}, error_type={type(e).__name__}, file_id={photo.file_id if 'photo' in locals() else 'Unknown'}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 30MB as per KIE API)
            if len(image_data) > 30 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 30 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(image_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"üî•üî•üî• IMAGE DOWNLOADED: size={len(image_data)} bytes, user_id={user_id}, file_id={photo.file_id[:8]}")
            
            # Upload to public hosting
            logger.info(f"üî•üî•üî• UPLOADING TO HOSTING: user_id={user_id}, filename=image_{user_id}_{photo.file_id[:8]}.jpg")
            # üî¥ API CALL: File Upload API - upload_image_to_hosting
            try:
                public_url = await upload_image_to_hosting(image_data, filename=f"image_{user_id}_{photo.file_id[:8]}.jpg")
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå FILE UPLOAD API ERROR in upload_image_to_hosting (image): {e}", exc_info=True)
                user_lang = get_user_language(user_id) if user_id else 'ru'
                error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                await update.message.reply_text(
                    f"‚ùå <b>{error_msg}</b>\n\n"
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                logger.error(f"‚ùå‚ùå‚ùå IMAGE UPLOAD FAILED: user_id={user_id}, model_id={session.get('model_id', 'Unknown')}, file_size={len(image_data)} bytes, upload_image_to_hosting returned None")
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"üî•üî•üî• IMAGE UPLOADED TO HOSTING: public_url={public_url}, user_id={user_id}, file_size={len(image_data)} bytes, model_id={session.get('model_id', 'Unknown')}")
            
            # Add to image_input array
            # Determine which parameter name to use
            waiting_for = session.get('waiting_for', 'image_input')
            logger.info(f"üî•üî•üî• IMAGE PROCESSING: waiting_for={waiting_for}, user_id={user_id}, model_id={session.get('model_id', 'Unknown')}")
            # Normalize: if waiting_for is 'image', use the actual parameter name from properties
            if waiting_for == 'image':
                properties = session.get('properties', {})
                if 'image_input' in properties:
                    image_param_name = 'image_input'
                elif 'image_urls' in properties:
                    image_param_name = 'image_urls'
                else:
                    image_param_name = 'image_input'  # Default fallback
            else:
                image_param_name = waiting_for  # image_input or image_urls
            if image_param_name not in session:
                session[image_param_name] = []
            session[image_param_name].append(public_url)
            logger.info(f"üî•üî•üî• IMAGE ADDED TO SESSION: param={image_param_name}, count={len(session[image_param_name])}, model={session.get('model_id', 'Unknown')}, user_id={user_id}, urls={session[image_param_name][:2]}")
            
        except Exception as e:
            logger.error(f"‚ùå‚ùå‚ùå ERROR PROCESSING IMAGE: user_id={user_id}, error={str(e)}, error_type={type(e).__name__}", exc_info=True)
            if user_id in user_sessions:
                session_error = user_sessions[user_id]
                logger.error(f"‚ùå‚ùå‚ùå ERROR CONTEXT: model_id={session_error.get('model_id', 'Unknown')}, waiting_for={session_error.get('waiting_for', 'None')}, session_keys={list(session_error.keys())[:10]}")
            else:
                logger.error(f"‚ùå‚ùå‚ùå ERROR CONTEXT: No session found for user_id={user_id}")
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
        
        # Determine image parameter name (normalize 'image' to actual param name)
        waiting_for = session.get('waiting_for', 'image_input')
        if waiting_for == 'image':
            properties_check = session.get('properties', {})
            if 'image_input' in properties_check:
                image_param_name = 'image_input'
            elif 'image_urls' in properties_check:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
        else:
            image_param_name = waiting_for
        
        image_count = len(session.get(image_param_name, []))
        
        # Check if model requires only 1 image (max_items = 1)
        properties = session.get('properties', {})
        param_info = properties.get(image_param_name, {})
        max_items = param_info.get('max_items', 8)  # Default to 8 if not specified
        
        model_id = session.get('model_id', 'Unknown')
        
        # CRITICAL: For models that only require image (no prompt), force max_items=1
        # This ensures they always show the button immediately after image upload
        models_only_image = [
            "recraft/remove-background",
            "recraft/crisp-upscale",
            "topaz/image-upscale",
            "ideogram/v3-reframe"
        ]
        if model_id in models_only_image:
            max_items = 1  # Force to 1 for these models
            logger.info(f"üîç Model {model_id} is image-only, forcing max_items=1")
        
        logger.info(f"üîç Image processing: model={model_id}, image_param_name={image_param_name}, max_items={max_items}, image_count={image_count}, session_keys={list(session.keys())}")
        
        # If max_items is 1, immediately move to next parameter (or show button for image-only models)
        if max_items == 1:
            user_lang = get_user_language(user_id)
            if user_lang == 'en':
                success_msg = "‚úÖ Image uploaded!\n\nContinuing..."
            else:
                success_msg = "‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!\n\n–ü—Ä–æ–¥–æ–ª–∂–∞—é..."
            await update.message.reply_text(success_msg)
            
            if 'params' not in session:
                session['params'] = {}
            
            # Store image_input as array (API expects array)
            # CRITICAL: Ensure image_input is properly stored in params
            if image_param_name not in session:
                logger.error(f"ERROR: {image_param_name} not in session after upload!")
                session[image_param_name] = []
            
            # CRITICAL: Store image_input as array (API expects array)
            # Ensure we have the image data before storing
            if image_param_name not in session or not session[image_param_name]:
                logger.error(f"CRITICAL ERROR: {image_param_name} not in session or empty after upload!")
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Store in params
            if isinstance(session[image_param_name], list):
                session['params'][image_param_name] = session[image_param_name].copy()  # Use copy to avoid reference issues
            else:
                session['params'][image_param_name] = [session[image_param_name]]
            
            # CRITICAL: Double-check that params contains the image
            if image_param_name not in session.get('params', {}) or not session.get('params', {}).get(image_param_name):
                logger.error(f"ERROR: {image_param_name} not properly stored in params! Fixing...")
                if image_param_name in session and session[image_param_name]:
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                else:
                    logger.error(f"CRITICAL: Cannot fix - {image_param_name} not in session!")
                    await update.message.reply_text(
                        "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
            
            # TRIPLE-CHECK: Verify the image is actually in params
            if not session.get('params', {}).get(image_param_name):
                logger.error(f"CRITICAL: {image_param_name} still not in params after all fixes!")
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"üî•üî•üî• IMAGE VERIFIED IN PARAMS: param={image_param_name}, count={len(session['params'][image_param_name])}, user_id={user_id}, model_id={model_id}, urls={session['params'][image_param_name][:1]}")
            
            session['waiting_for'] = None
            session['current_param'] = None
            logger.info(f"üî•üî•üî• SESSION UPDATED: waiting_for=None, current_param=None, user_id={user_id}, model_id={model_id}")
            
            # CRITICAL: For models without prompt (like recraft/remove-background),
            # check if all required parameters are collected
            model_id = session.get('model_id', 'Unknown')
            required = session.get('required', [])
            properties = session.get('properties', {})
            
            logger.info(f"CRITICAL CHECK for {model_id}: required={required}, params_keys={list(session.get('params', {}).keys())}, image_param_name={image_param_name}, session[{image_param_name}]={bool(session.get(image_param_name))}")
            
            # CRITICAL: Check if all required parameters are in params
            # For models like recraft/remove-background that only require image_input
            all_required_collected = True
            
            # CRITICAL: First, ensure image_input/image_urls that was just uploaded is in params
            # This MUST be done before checking required parameters
            if image_param_name not in session.get('params', {}) or not session.get('params', {}).get(image_param_name):
                # This should not happen, but double-check and fix
                logger.warning(f"Image parameter {image_param_name} not in params after upload! Adding it...")
                if image_param_name in session and session[image_param_name]:
                    if 'params' not in session:
                        session['params'] = {}
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                    logger.info(f"‚úÖ Fixed: {image_param_name} added to params")
                else:
                    logger.error(f"CRITICAL: {image_param_name} not in session either!")
            
            # CRITICAL: For models that only require image (no prompt), skip the required check
            # and rely on the models_only_image check below
            models_only_image = [
                "recraft/remove-background",
                "recraft/crisp-upscale",
                "topaz/image-upscale",
                "ideogram/v3-reframe"
            ]
            
            # Only check required parameters if this is NOT a model that only requires image
            if model_id not in models_only_image:
                # Check all required parameters
                for req_param in required:
                    if req_param not in session.get('params', {}) or not session.get('params', {}).get(req_param):
                        # Special case: image parameters that were just uploaded
                        if req_param == image_param_name:
                            # Should already be in params, but check session
                            if req_param in session and session[req_param]:
                                # Add it to params if missing
                                if 'params' not in session:
                                    session['params'] = {}
                                if isinstance(session[req_param], list):
                                    session['params'][req_param] = session[req_param].copy()
                                else:
                                    session['params'][req_param] = [session[req_param]]
                                logger.info(f"‚úÖ Fixed: {req_param} added to params from session")
                                continue
                        all_required_collected = False
                        logger.warning(f"Required parameter {req_param} not collected for {model_id}")
                        break
            else:
                # For models_only_image, we'll check in the special section below
                logger.info(f"Model {model_id} is in models_only_image, skipping standard required check")
            
            # Also explicitly check if image_input/image_urls are required and collected
            if 'image_input' in properties and properties['image_input'].get('required', False):
                if 'image_input' not in session.get('params', {}) or not session.get('params', {}).get('image_input'):
                    # Check if it's in session but not in params
                    if 'image_input' in session and session['image_input']:
                        if 'params' not in session:
                            session['params'] = {}
                        if isinstance(session['image_input'], list):
                            session['params']['image_input'] = session['image_input']
                        else:
                            session['params']['image_input'] = [session['image_input']]
                    else:
                        all_required_collected = False
                        logger.warning(f"Required image_input not collected for {model_id}")
            
            if 'image_urls' in properties and properties['image_urls'].get('required', False):
                if 'image_urls' not in session.get('params', {}) or not session.get('params', {}).get('image_urls'):
                    # Check if it's in session but not in params
                    if 'image_urls' in session and session['image_urls']:
                        if 'params' not in session:
                            session['params'] = {}
                        if isinstance(session['image_urls'], list):
                            session['params']['image_urls'] = session['image_urls']
                        else:
                            session['params']['image_urls'] = [session['image_urls']]
                    else:
                        all_required_collected = False
                        logger.warning(f"Required image_urls not collected for {model_id}")
            
            logger.info(f"After image upload for {model_id}: all_required_collected={all_required_collected}, required={required}, params={list(session.get('params', {}).keys())}, session_image_input={bool(session.get('image_input'))}, session_image_urls={bool(session.get('image_urls'))}")
            
            # CRITICAL: Final check - if image is in params, force all_required_collected=True for image-only models
            # This is a safety net to ensure button is shown
            if model_id in models_only_image:
                params_final_check = session.get('params', {})
                if image_param_name in params_final_check and params_final_check.get(image_param_name):
                    image_list = params_final_check.get(image_param_name)
                    if isinstance(image_list, list) and len(image_list) > 0:
                        logger.info(f"‚úÖ‚úÖ‚úÖ FINAL CHECK: {model_id} has {image_param_name} with {len(image_list)} item(s) in params. FORCING all_required_collected=True.")
                        all_required_collected = True
                    elif isinstance(image_list, str) and image_list:
                        logger.info(f"‚úÖ‚úÖ‚úÖ FINAL CHECK: {model_id} has {image_param_name} as string in params. FORCING all_required_collected=True.")
                        all_required_collected = True
            
            logger.info(f"üîçüîçüîç FINAL STATE: all_required_collected={all_required_collected}, model={model_id}, will_show_button={all_required_collected}")
            
            # CRITICAL: Special handling for models that only require image_input (no prompt)
            # These models should immediately show confirmation after image upload
            # NOTE: models_only_image list is defined above, but we check it again here for clarity
            if model_id in models_only_image:
                logger.info(f"üîçüîçüîç CRITICAL: {model_id} is in models_only_image list! Checking image...")
                # For these models, if image_input is in params, we're done
                params_check = session.get('params', {})
                image_in_params = image_param_name in params_check and params_check.get(image_param_name) and len(params_check.get(image_param_name, [])) > 0
                
                # Also check if it's in session (fallback)
                image_in_session = image_param_name in session and session.get(image_param_name) and len(session.get(image_param_name, [])) > 0
                
                logger.info(f"üîç {model_id} check: image_in_params={image_in_params}, image_in_session={image_in_session}, params_keys={list(params_check.keys())}, session_has_{image_param_name}={image_param_name in session}, session_value={session.get(image_param_name)}")
                
                if image_in_params:
                    logger.info(f"‚úÖ‚úÖ‚úÖ Model {model_id} only requires {image_param_name}, which is collected in params. FORCING all_required_collected=True.")
                    all_required_collected = True
                elif image_in_session:
                    # Image is in session but not in params - fix it
                    logger.warning(f"‚ö†Ô∏è {image_param_name} in session but not in params for {model_id}. Fixing...")
                    if 'params' not in session:
                        session['params'] = {}
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                    logger.info(f"‚úÖ‚úÖ‚úÖ Fixed: {image_param_name} now in params. FORCING all_required_collected=True.")
                    all_required_collected = True
                else:
                    logger.error(f"‚ùå‚ùå‚ùå CRITICAL ERROR: {model_id} requires {image_param_name} but it's not in params or session!")
                    logger.error(f"   params keys: {list(params_check.keys())}")
                    logger.error(f"   params[{image_param_name}]: {params_check.get(image_param_name)}")
                    logger.error(f"   session keys: {list(session.keys())}")
                    logger.error(f"   session[{image_param_name}]: {session.get(image_param_name)}")
                    # Even if not found, try to set all_required_collected based on what we have
                    # This is a last resort - the image should have been uploaded
                    if image_param_name in session and session[image_param_name]:
                        logger.warning(f"‚ö†Ô∏è Last resort: Found {image_param_name} in session, forcing to params...")
                        if 'params' not in session:
                            session['params'] = {}
                        if isinstance(session[image_param_name], list):
                            session['params'][image_param_name] = session[image_param_name].copy()
                        else:
                            session['params'][image_param_name] = [session[image_param_name]]
                        all_required_collected = True
                        logger.info(f"‚úÖ‚úÖ‚úÖ Last resort fix successful, all_required_collected=True")
                    else:
                        all_required_collected = False
            
            # CRITICAL: For image-only models, FORCE all_required_collected=True if image is uploaded
            # This is the ABSOLUTE FINAL check before showing button
            if model_id in models_only_image:
                params_final = session.get('params', {})
                if image_param_name in params_final and params_final.get(image_param_name):
                    image_data_final = params_final.get(image_param_name)
                    if (isinstance(image_data_final, list) and len(image_data_final) > 0) or \
                       (isinstance(image_data_final, str) and image_data_final):
                        logger.info(f"üö®üö®üö® ABSOLUTE FINAL CHECK: {model_id} has image, FORCING all_required_collected=True")
                        all_required_collected = True
                    else:
                        logger.error(f"‚ùå Image data is empty for {model_id}: {image_data_final}")
                elif image_param_name in session and session.get(image_param_name):
                    # Last resort - image is in session but not in params
                    logger.warning(f"‚ö†Ô∏è Image in session but not in params for {model_id}, fixing...")
                    if 'params' not in session:
                        session['params'] = {}
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                    all_required_collected = True
                    logger.info(f"‚úÖ‚úÖ‚úÖ Last resort fix: all_required_collected=True for {model_id}")
                else:
                    logger.error(f"‚ùå‚ùå‚ùå CRITICAL: {model_id} has no image in params or session!")
            
            logger.info(f"üéØüéØüéØ BEFORE BUTTON CHECK: all_required_collected={all_required_collected}, model={model_id}, params_keys={list(session.get('params', {}).keys())}")
            
            # ABSOLUTE FINAL CHECK: For image-only models, if image exists, FORCE all_required_collected=True
            # This is the last chance to show the button
            if not all_required_collected and model_id in models_only_image:
                final_params_check = session.get('params', {})
                final_session_check = session.get(image_param_name, [])
                if (image_param_name in final_params_check and final_params_check.get(image_param_name)) or \
                   (final_session_check and (isinstance(final_session_check, list) and len(final_session_check) > 0 or isinstance(final_session_check, str) and final_session_check)):
                    logger.warning(f"üö®üö®üö® ABSOLUTE FINAL: {model_id} has image, FORCING all_required_collected=True RIGHT BEFORE BUTTON CHECK")
                    all_required_collected = True
                    # Ensure image is in params
                    if image_param_name not in final_params_check or not final_params_check.get(image_param_name):
                        if 'params' not in session:
                            session['params'] = {}
                        if isinstance(final_session_check, list):
                            session['params'][image_param_name] = final_session_check.copy()
                        else:
                            session['params'][image_param_name] = [final_session_check] if final_session_check else []
            
            logger.info(f"üéØüéØüéØ AFTER FINAL CHECK: all_required_collected={all_required_collected}, model={model_id}")
            
            # If all required parameters collected, show "Generate" button with price
            if all_required_collected:
                model_name = session.get('model_info', {}).get('name', 'Unknown')
                params = session.get('params', {})
                user_lang = get_user_language(user_id)
                is_admin_user = get_is_admin(user_id)
                
                logger.info(f"‚úÖ All parameters collected for {model_id}, showing generate button with price. Params: {list(params.keys())}")
                
                # CRITICAL: Log models_only_image check
                logger.info(f"üîçüîçüîç Checking auto-start: model_id={model_id}, models_only_image={models_only_image}, is_in_list={model_id in models_only_image}")
                
                # CRITICAL: For image-only models, automatically start generation instead of showing button
                if model_id in models_only_image:
                    logger.info(f"üöÄüöÄüöÄ AUTO-STARTING generation for {model_id} (image-only model)")
                    
                    # Show "Generation started" message
                    if user_lang == 'en':
                        start_msg = (
                            f"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
                            f"‚ïë  üöÄ GENERATION STARTED! üöÄ         ‚ïë\n"
                            f"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                            f"‚úÖ <b>Processing your request</b>\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> <code>{model_name}</code>\n"
                            f"‚è±Ô∏è <b>Expected time:</b> 10-60 seconds\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                            f"üí° <b>What's happening:</b>\n"
                            f"‚Ä¢ AI is analyzing your request\n"
                            f"‚Ä¢ Content generation in progress\n"
                            f"‚Ä¢ Usually takes 10-60 seconds\n\n"
                            f"‚ú® <b>Result will appear automatically!</b>"
                        )
                    else:
                        start_msg = (
                            f"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
                            f"‚ïë  üöÄ –ì–ï–ù–ï–†–ê–¶–ò–Ø –ù–ê–ß–ê–õ–ê–°–¨! üöÄ         ‚ïë\n"
                            f"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                            f"‚úÖ <b>–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å</b>\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> <code>{model_name}</code>\n"
                            f"‚è±Ô∏è <b>–û–∂–∏–¥–∞–µ–º–æ–µ –≤—Ä–µ–º—è:</b> 10-60 —Å–µ–∫—É–Ω–¥\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                            f"üí° <b>–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:</b>\n"
                            f"‚Ä¢ –ù–µ–π—Ä–æ—Å–µ—Ç—å –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å\n"
                            f"‚Ä¢ –ò–¥–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n"
                            f"‚Ä¢ –û–±—ã—á–Ω–æ 10-60 —Å–µ–∫—É–Ω–¥\n\n"
                            f"‚ú® <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!</b>"
                        )
                    
                    try:
                        if update.message:
                            status_msg = await update.message.reply_text(start_msg, parse_mode='HTML')
                        elif update.callback_query:
                            try:
                                await update.callback_query.edit_message_text(start_msg, parse_mode='HTML')
                                status_msg = update.callback_query.message
                            except Exception as edit_error:
                                logger.warning(f"Could not edit message: {edit_error}, sending new")
                                status_msg = await update.callback_query.message.reply_text(start_msg, parse_mode='HTML')
                        else:
                            status_msg = await context.bot.send_message(chat_id=user_id, text=start_msg, parse_mode='HTML')
                        
                        # CRITICAL: Ensure session exists before calling confirm_generation
                        if user_id not in user_sessions:
                            logger.error(f"‚ùå‚ùå‚ùå CRITICAL: Session lost before confirm_generation! user_id={user_id}, model_id={model_id}")
                            raise Exception(f"Session lost for user {user_id}")
                        
                        # Verify session has required data
                        session_check = user_sessions[user_id]
                        if 'model_id' not in session_check or 'params' not in session_check:
                            logger.error(f"‚ùå‚ùå‚ùå CRITICAL: Session incomplete! user_id={user_id}, session_keys={list(session_check.keys())}")
                            raise Exception(f"Session incomplete for user {user_id}")
                        
                        logger.info(f"‚úÖ‚úÖ‚úÖ Session verified before confirm_generation: user_id={user_id}, model_id={session_check.get('model_id')}, params_keys={list(session_check.get('params', {}).keys())}")
                        
                        # CRITICAL: Save session copy to restore if lost
                        session_backup = session_check.copy()
                        logger.info(f"üíæüíæüíæ Session backup created: user_id={user_id}, backup_keys={list(session_backup.keys())}")
                        
                        # CRITICAL: Store backup in context.user_data for confirm_generation to access
                        if not hasattr(context, 'user_data'):
                            context.user_data = {}
                        context.user_data['session_backup'] = session_backup.copy()
                        context.user_data['session_backup_user_id'] = user_id
                        logger.info(f"üíæüíæüíæ Session backup stored in context.user_data for user_id={user_id}")
                        
                        # Create mock callback query to call confirm_generation
                        class MockUser:
                            def __init__(self, user_id):
                                self.id = user_id
                        
                        class MockMessage:
                            def __init__(self, status_msg):
                                self.chat_id = status_msg.chat.id if hasattr(status_msg, 'chat') and hasattr(status_msg.chat, 'id') else user_id
                                self.message_id = status_msg.message_id if hasattr(status_msg, 'message_id') else None
                        
                        class MockCallbackQuery:
                            def __init__(self, user_id, status_msg, context):
                                self.from_user = MockUser(user_id)
                                self.message = MockMessage(status_msg)
                                self.data = "confirm_generate"
                                self.id = f"auto_{user_id}_{int(time.time())}"
                                self._status_msg = status_msg
                                self._context = context
                                self._user_id = user_id
                            
                            async def answer(self, text=None, show_alert=False):
                                pass
                            
                            async def edit_message_text(self, text, parse_mode='HTML', reply_markup=None):
                                """Mock edit_message_text that uses status_msg.edit_text or context.bot"""
                                try:
                                    if hasattr(self._status_msg, 'edit_text'):
                                        await self._status_msg.edit_text(text, parse_mode=parse_mode, reply_markup=reply_markup)
                                    elif hasattr(self._status_msg, 'message_id') and hasattr(self._status_msg, 'chat'):
                                        await self._context.bot.edit_message_text(
                                            chat_id=self._status_msg.chat.id,
                                            message_id=self._status_msg.message_id,
                                            text=text,
                                            parse_mode=parse_mode,
                                            reply_markup=reply_markup
                                        )
                                    else:
                                        # Fallback: send new message
                                        await self._context.bot.send_message(
                                            chat_id=self._user_id,
                                            text=text,
                                            parse_mode=parse_mode,
                                            reply_markup=reply_markup
                                        )
                                except Exception as e:
                                    logger.warning(f"MockCallbackQuery.edit_message_text failed: {e}, trying send_message")
                                    await self._context.bot.send_message(
                                        chat_id=self._user_id,
                                        text=text,
                                        parse_mode=parse_mode,
                                        reply_markup=reply_markup
                                    )
                        
                        # CRITICAL: Create effective_user that matches the real user
                        class MockEffectiveUser:
                            def __init__(self, user_id):
                                self.id = user_id
                        
                        mock_query = MockCallbackQuery(user_id, status_msg, context)
                        mock_effective_user = MockEffectiveUser(user_id)
                        
                        mock_update = type('obj', (object,), {
                            'callback_query': mock_query,
                            'effective_user': mock_effective_user,
                            'message': None
                        })()
                        
                        # Auto-start generation
                        logger.info(f"üöÄüöÄüöÄ Calling confirm_generation for {model_id}, user_id={user_id}")
                        logger.info(f"üöÄüöÄüöÄ Mock update: effective_user.id={mock_update.effective_user.id}, callback_query.data={mock_update.callback_query.data}")
                        
                        # CRITICAL: Double-check session exists right before calling
                        if user_id not in user_sessions:
                            logger.error(f"‚ùå‚ùå‚ùå Session lost RIGHT BEFORE confirm_generation! Restoring from backup...")
                            user_sessions[user_id] = session_backup.copy()
                            logger.info(f"‚úÖ‚úÖ‚úÖ Session restored from backup: user_id={user_id}")
                        
                        try:
                            logger.info(f"üöÄüöÄüöÄ About to call confirm_generation: user_id={user_id}, model_id={model_id}, session_exists={user_id in user_sessions}")
                            result = await confirm_generation(mock_update, context)
                            logger.info(f"üöÄüöÄüöÄ confirm_generation returned: {result} for {model_id}")
                            # CRITICAL: If confirm_generation succeeded, return immediately - don't show button
                            logger.info(f"‚úÖ‚úÖ‚úÖ Auto-start succeeded, NOT showing button for {model_id}")
                            return result
                        except Exception as confirm_error:
                            logger.error(f"‚ùå‚ùå‚ùå Error in confirm_generation: {confirm_error}", exc_info=True)
                            logger.error(f"‚ùå‚ùå‚ùå Error type: {type(confirm_error).__name__}, error message: {str(confirm_error)}")
                            # CRITICAL: Check if task was already created before error
                            # If task_id exists in session, task was created and we should NOT show button
                            if user_id in user_sessions:
                                session_check = user_sessions[user_id]
                                if 'task_id' in session_check:
                                    task_id = session_check.get('task_id')
                                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Task {task_id} was already created before error, NOT showing button to prevent duplicate")
                                    # Task was created, don't show button - just return
                                    return ConversationHandler.END
                            # Restore session if it was lost
                            if user_id not in user_sessions:
                                logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Session lost during confirm_generation, restoring from backup...")
                                user_sessions[user_id] = session_backup.copy()
                            # Don't raise - fall through to show button only if task was NOT created
                            logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Falling through to show button due to confirm_generation error (task was NOT created)")
                    except Exception as auto_start_error:
                        logger.error(f"‚ùå‚ùå‚ùå CRITICAL Error auto-starting generation for {model_id}: {auto_start_error}", exc_info=True)
                        logger.error(f"‚ùå‚ùå‚ùå Error type: {type(auto_start_error).__name__}, error message: {str(auto_start_error)}")
                        logger.error(f"‚ùå‚ùå‚ùå Error traceback: {traceback.format_exc()}")
                        # Fall through to show button as fallback
                        error_fallback_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø—É—Å–∫–∞</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—Ä—É—á–Ω—É—é."
                        try:
                            if update.message:
                                await update.message.reply_text(error_fallback_msg, parse_mode='HTML')
                            elif update.callback_query:
                                await update.callback_query.message.reply_text(error_fallback_msg, parse_mode='HTML')
                            else:
                                await context.bot.send_message(chat_id=user_id, text=error_fallback_msg, parse_mode='HTML')
                        except Exception as msg_error:
                            logger.error(f"‚ùå‚ùå‚ùå Could not send error message: {msg_error}")
                        # Continue to show button as fallback
                
                # Calculate price
                is_free = is_free_generation_available(user_id, model_id)
                price = calculate_price_rub(model_id, params, is_admin_user)
                if is_free:
                    price = 0.0
                
                # Format price string
                price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                
                # Format params text
                params_text = ""
                for k, v in params.items():
                    if isinstance(v, list):
                        params_text += f"  ‚Ä¢ {k}: {len(v)} image(s)\n"
                    else:
                        display_val = str(v)[:50] + '...' if len(str(v)) > 50 else str(v)
                        params_text += f"  ‚Ä¢ {k}: {display_val}\n"
                
                # Prepare price info
                if is_free:
                    remaining = get_user_free_generations_remaining(user_id)
                    if user_lang == 'en':
                        price_info = f"\n\nüéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day"
                    else:
                        price_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                else:
                    if user_lang == 'en':
                        price_info = f"\n\nüí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                    else:
                        price_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                
                # Show message with "Generate" button and price
                if user_lang == 'en':
                    message_text = (
                        f"‚úÖ <b>Ready to generate!</b>\n\n"
                        f"Model: <b>{model_name}</b>\n"
                        f"Parameters:\n{params_text}{price_info}\n\n"
                        f"Click the button below to start generation."
                    )
                    button_text = "üöÄ Start Generation"
                else:
                    message_text = (
                        f"‚úÖ <b>–ì–æ—Ç–æ–≤–æ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏!</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{price_info}\n\n"
                        f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                    )
                    button_text = "üöÄ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é"
                
                keyboard = [
                    [InlineKeyboardButton(button_text, callback_data="confirm_generate")],
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                try:
                    # Check if we have update.message (for photo/text input) or query (for callback)
                    if update.message:
                        await update.message.reply_text(
                            message_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    elif update.callback_query:
                        # If called from callback, edit the message
                        try:
                            await update.callback_query.edit_message_text(
                                message_text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                        except Exception as edit_error:
                            logger.warning(f"Could not edit message, sending new: {edit_error}")
                            await update.callback_query.message.reply_text(
                                message_text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                    else:
                        # Fallback: send message to user
                        await context.bot.send_message(
                            chat_id=user_id,
                            text=message_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    elapsed = time.time() - start_time
                    logger.info(f"üî•üî•üî• BUTTON SHOWN SUCCESS: model_id={model_id}, price={price_str} ‚ÇΩ, user_id={user_id}, elapsed={elapsed:.3f}s")
                    logger.info(f"üî•üî•üî• STATE TRANSITION: INPUTTING_PARAMS -> CONFIRMING_GENERATION for user {user_id}, model {model_id}")
                    return CONFIRMING_GENERATION
                except Exception as e:
                    logger.error(f"‚ùå Error showing generate button: {e}", exc_info=True)
                    error_msg = "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                    try:
                        if update.message:
                            await update.message.reply_text(error_msg, parse_mode='HTML')
                        elif update.callback_query:
                            await update.callback_query.message.reply_text(error_msg, parse_mode='HTML')
                        else:
                            await context.bot.send_message(chat_id=user_id, text=error_msg, parse_mode='HTML')
                    except:
                        pass
                    return INPUTTING_PARAMS
            
            # CRITICAL: If all_required_collected is still False but this is an image-only model with image uploaded,
            # FORCE show the button anyway - this is a safety net
            if not all_required_collected and model_id in models_only_image:
                params_safety = session.get('params', {})
                if image_param_name in params_safety and params_safety.get(image_param_name):
                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è SAFETY NET: all_required_collected=False but {model_id} has image, FORCING button show")
                    all_required_collected = True
                    # Jump directly to showing button (code below will handle it)
                elif image_param_name in session and session.get(image_param_name):
                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è SAFETY NET: Moving image from session to params for {model_id}")
                    if 'params' not in session:
                        session['params'] = {}
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                    all_required_collected = True
            
            # Move to next parameter if not all collected (only if button wasn't shown above)
            if not all_required_collected:
                try:
                    next_param_result = await start_next_parameter(update, context, user_id)
                    logger.info(f"start_next_parameter returned: {next_param_result} for model {model_id}")
                    if next_param_result:
                        return next_param_result
                    else:
                        # All parameters collected, show confirmation
                        model_name = session.get('model_info', {}).get('name', 'Unknown')
                        params = session.get('params', {})
                        logger.info(f"All parameters collected for {model_id}, params: {list(params.keys())}")
                        params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                        
                        user_lang = get_user_language(user_id)
                        keyboard = [
                            [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                            [
                                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                            ],
                            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                        ]
                        
                        # Calculate price for confirmation
                        is_free = is_free_generation_available(user_id, model_id)
                        price = calculate_price_rub(model_id, params, is_admin_user)
                        if is_free:
                            price = 0.0
                        price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                        
                        # Prepare price info
                        if is_free:
                            remaining = get_user_free_generations_remaining(user_id)
                            price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                        else:
                            price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                        
                        if user_lang == 'en':
                            price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str} ‚ÇΩ"
                            confirm_text = (
                                f"üìã <b>Generation Confirmation</b>\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"ü§ñ <b>Model:</b> {model_name}\n\n"
                                f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"{price_info_en}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"üí° <b>What's next:</b>\n"
                                f"‚Ä¢ Generation will start after confirmation\n"
                                f"‚Ä¢ Result will come automatically\n"
                                f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                                f"üöÄ <b>Ready to start?</b>"
                            )
                        else:
                            confirm_text = (
                                f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                                f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"{price_info}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                                f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                                f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                                f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                                f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                            )
                        
                        # Check if we have update.message or need to use context.bot
                        try:
                            if update.message:
                                await update.message.reply_text(
                                    confirm_text,
                                    reply_markup=InlineKeyboardMarkup(keyboard),
                                    parse_mode='HTML'
                                )
                            elif update.callback_query:
                                try:
                                    await update.callback_query.edit_message_text(
                                        confirm_text,
                                        reply_markup=InlineKeyboardMarkup(keyboard),
                                        parse_mode='HTML'
                                    )
                                except Exception as edit_error:
                                    logger.warning(f"Could not edit message, sending new: {edit_error}")
                                    await update.callback_query.message.reply_text(
                                        confirm_text,
                                        reply_markup=InlineKeyboardMarkup(keyboard),
                                        parse_mode='HTML'
                                    )
                            else:
                                await context.bot.send_message(
                                    chat_id=user_id,
                                    text=confirm_text,
                                    reply_markup=InlineKeyboardMarkup(keyboard),
                                    parse_mode='HTML'
                                )
                            logger.info(f"‚úÖ‚úÖ‚úÖ Confirmation button shown for {model_id}, returning CONFIRMING_GENERATION")
                            return CONFIRMING_GENERATION
                        except Exception as send_error:
                            logger.error(f"‚ùå Error showing confirmation button: {send_error}", exc_info=True)
                            return INPUTTING_PARAMS
                except Exception as e:
                    logger.error(f"Error after image input: {e}", exc_info=True)
                    await update.message.reply_text(
                        f"‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                        f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É.\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel.",
                        parse_mode='HTML'
                    )
        elif image_count < min(max_items, 8):
            keyboard = [
                [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data="add_image")],
                [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="image_done")]
            ]
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ: {image_count}/{max_items}\n\n"
                f"–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–î–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º—É–º ({max_items} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π). –ü—Ä–æ–¥–æ–ª–∂–∞—é..."
            )
            if 'params' not in session:
                session['params'] = {}
            session['params'][image_param_name] = session[image_param_name]
            session['waiting_for'] = None
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await guard.check_and_ensure_response(update, context)
            except Exception as e:
                logger.error(f"Error after image input: {e}")
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                await update.message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                    parse_mode='HTML'
                )
                track_outgoing_action(update_id)
        
        return INPUTTING_PARAMS
    
    # Handle text input
    if not update.message.text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        return INPUTTING_PARAMS

    text = update.message.text.strip()
    
    # Handle /cancel command
    if text.lower() in ['/cancel', '–æ—Ç–º–µ–Ω–∞', 'cancel']:
        user_lang = get_user_language(user_id)
        if user_id in user_sessions:
            del user_sessions[user_id]
        keyboard = [[InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]]
        await update.message.reply_text(
            t('msg_operation_cancelled', lang=user_lang),
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    # ==================== TASK 1: –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –∫–∞–∂–¥—ã–π –≤–≤–æ–¥ ====================
    # –°—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥—É–º–∞–ª, —á—Ç–æ –±–æ—Ç –∑–∞–≤–∏—Å
    try:
        await update.message.reply_text("‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...", parse_mode='HTML')
        # NO-SILENCE GUARD: Track outgoing action
        track_outgoing_action(update_id)
    except Exception as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: {e}")
    
    # ==================== TASK 1: Try/except –≤–æ–∫—Ä—É–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ ====================
    try:
        # If waiting for text input (prompt or other text parameter)
        waiting_for = session.get('waiting_for')
        if waiting_for:
            current_param = session.get('current_param', waiting_for)
            param_info = properties.get(current_param, {})
            max_length = param_info.get('max_length')
            
            # Validate max length
            if max_length and len(text) > max_length:
                await update.message.reply_text(
                    f"‚ùå –¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. {max_length} —Å–∏–º–≤–æ–ª–æ–≤). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                )
                return INPUTTING_PARAMS
        
            # For language_code, convert common language names to codes
            if current_param == 'language_code':
                lang_lower = text.lower()
                lang_map = {
                    '—Ä—É—Å—Å–∫–∏–π': 'ru',
                    'russian': 'ru',
                    '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π': 'en',
                    'english': 'en',
                    'eng': 'en',
                    '–Ω–µ–º–µ—Ü–∫–∏–π': 'de',
                    'german': 'de',
                    '—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π': 'fr',
                    'french': 'fr',
                    '–∏—Å–ø–∞–Ω—Å–∫–∏–π': 'es',
                    'spanish': 'es',
                    '–∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π': 'it',
                    'italian': 'it',
                    '–∫–∏—Ç–∞–π—Å–∫–∏–π': 'zh',
                    'chinese': 'zh',
                    '—è–ø–æ–Ω—Å–∫–∏–π': 'ja',
                    'japanese': 'ja',
                    '–∫–æ—Ä–µ–π—Å–∫–∏–π': 'ko',
                    'korean': 'ko'
                }
                if lang_lower in lang_map:
                    text = lang_map[lang_lower]
                # If it's already a code (2-3 letters), convert to lowercase
                elif len(text) <= 5 and text.replace('-', '').replace('_', '').isalpha():
                    text = text.lower()
            
            # For video_url in sora-watermark-remover, validate URL format
            model_id = session.get('model_id', '')
            if current_param == 'video_url' and model_id == 'sora-watermark-remover':
                # Validate URL format (should contain sora.chatgpt.com)
                if 'sora.chatgpt.com' not in text:
                    await update.message.reply_text(
                        f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                        f"URL –≤–∏–¥–µ–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç OpenAI Sora 2 (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å sora.chatgpt.com).\n\n"
                        f"–ü—Ä–∏–º–µ—Ä: https://sora.chatgpt.com/p/s_...\n\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
                
                # Additional validation: check if URL starts with http:// or https://
                if not (text.startswith('http://') or text.startswith('https://')):
                    await update.message.reply_text(
                        f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                        f"URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://\n\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
            
            # Set parameter value
            if 'params' not in session:
                session['params'] = {}
            session['params'][current_param] = text
            session['waiting_for'] = None
            session['current_param'] = None
            session['language_code_custom'] = False
            
            # Confirm parameter was set (–ö–†–ò–¢–ò–ß–ù–û: —ç—Ç–æ –≤—Ç–æ—Ä–æ–π –æ—Ç–≤–µ—Ç –ø–æ—Å–ª–µ "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
            display_value = text[:100] + '...' if len(text) > 100 else text
            await update.message.reply_text(
                f"‚úÖ <b>{current_param}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n\n"
                f"–ó–Ω–∞—á–µ–Ω–∏–µ: {display_value}",
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –≤—Ç–æ—Ä–æ–π –æ—Ç–≤–µ—Ç
            
            # If prompt was entered and model supports image input, offer to add image
            # Or if prompt was entered and model supports audio input, offer to add audio
            if current_param == 'prompt':
                model_info = session.get('model_info', {})
                model_id = session.get('model_id', '')
                input_params = model_info.get('input_params', {})
            
            # IMPORTANT: z-image does NOT support image input (text-to-image only)
            if model_id == "z-image":
                # For z-image, skip image input and go to next parameter
                session['has_image_input'] = False
            
                # IMPORTANT: z-image does NOT support image input (text-to-image only)
                # Skip image input check for z-image - it's text-to-image only
                if model_id == "z-image":
                    # z-image is text-to-image only, skip image input step completely
                    session['waiting_for'] = None
                    session['has_image_input'] = False  # Ensure flag is set correctly
                    
                    # Check for audio_url requirement (unlikely for z-image, but check anyway)
                    if 'audio_url' in input_params or 'audio_input' in input_params:
                        audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
                        audio_required = input_params.get(audio_param_name, {}).get('required', False)
                        
                        if audio_required:
                            # Audio is required
                            keyboard = [
                                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                            ]
                            await update.message.reply_text(
                                "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏</b>\n\n"
                                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                            session['waiting_for'] = audio_param_name
                            session['current_param'] = audio_param_name
                            return INPUTTING_PARAMS
                    
                    # Continue to next parameter (aspect_ratio for z-image)
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        # –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –Ω–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º fallback
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ NO-SILENCE GUARD
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error in start_next_parameter for z-image: {e}", exc_info=True)
                        await update.message.reply_text(
                            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                    return INPUTTING_PARAMS
                
                # Check for audio_url requirement (for non-z-image models)
                if 'audio_url' in input_params or 'audio_input' in input_params:
                    audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
                    audio_required = input_params.get(audio_param_name, {}).get('required', False)
                    
                    if audio_required:
                        # Audio is required
                        keyboard = [
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                        ]
                        await update.message.reply_text(
                            "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                            "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = audio_param_name
                        session['current_param'] = audio_param_name
                        return INPUTTING_PARAMS
                    else:
                        # Audio is optional - show buttons
                        keyboard = [
                            [InlineKeyboardButton("üé§ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", callback_data="add_audio")],
                            [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_audio")],
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                        ]
                        await update.message.reply_text(
                            "üé§ <b>–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = None  # Will be set when user clicks button or sends audio
                        return INPUTTING_PARAMS
                
                if session.get('has_image_input'):
                    image_required = False
                    if 'image_urls' in input_params:
                        image_required = input_params['image_urls'].get('required', False)
                    elif 'image_input' in input_params:
                        image_required = input_params['image_input'].get('required', False)
                    
                    if image_required:
                        # Image is required - show button without skip option
                        keyboard = [
                            [InlineKeyboardButton("üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")]
                        ]
                        await update.message.reply_text(
                            "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        # Determine which parameter name to use (image_input or image_urls)
                        if 'image_urls' in input_params:
                            image_param_name = 'image_urls'
                        else:
                            image_param_name = 'image_input'
                        session['waiting_for'] = image_param_name
                        session['current_param'] = image_param_name
                        return INPUTTING_PARAMS
                    else:
                        # Image is optional - show button with skip option
                        # Note: z-image is already handled above (line 7672), so it won't reach here
                        keyboard = [
                            [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")],
                            [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_image")]
                        ]
                        await update.message.reply_text(
                            "üì∑ <b>–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ?</b>\n\n"
                            "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                            "–ò–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = None
                        return INPUTTING_PARAMS
                
                # Check if there are more parameters
                required = session.get('required', [])
                params = session.get('params', {})
                properties = session.get('properties', {})
                model_info = session.get('model_info', {})
                input_params = model_info.get('input_params', {})
                
                # CRITICAL: Apply default values BEFORE checking missing parameters
                # This ensures parameters with default values are automatically applied
                for param_name, param_info in input_params.items():
                    if param_name not in params:
                        default_value = param_info.get('default')
                        if default_value is not None:
                            params[param_name] = default_value
                            logger.info(f"‚úÖ Applied default value for {param_name}={default_value} for {model_id}")
                
                # Don't exclude image_input/image_urls/audio_url/audio_input from missing if they're required but not yet provided
                # Only exclude them if they're already in params (uploaded)
                excluded_params = ['prompt']  # Always exclude prompt as it's already processed
                # Only exclude image/audio params if they're already set in params
                if 'image_input' in params or (session.get('image_input') and len(session.get('image_input', [])) > 0):
                    excluded_params.append('image_input')
                if 'image_urls' in params or (session.get('image_urls') and len(session.get('image_urls', [])) > 0):
                    excluded_params.append('image_urls')
                if 'mask_input' in params or (session.get('mask_input') and len(session.get('mask_input', [])) > 0):
                    excluded_params.append('mask_input')
                if 'reference_image_input' in params or (session.get('reference_image_input') and len(session.get('reference_image_input', [])) > 0):
                    excluded_params.append('reference_image_input')
                if 'audio_url' in params or session.get('audio_url'):
                    excluded_params.append('audio_url')
                if 'audio_input' in params or session.get('audio_input'):
                    excluded_params.append('audio_input')
                missing = [p for p in required if p not in params and p not in excluded_params]
                
                # CRITICAL: Ensure image_input/image_urls/mask_input/reference_image_input are considered missing if required and not in params
                # Also check if they're in session but not in params (auto-fix)
                for image_param in ['image_input', 'image_urls', 'mask_input', 'reference_image_input']:
                    if image_param in input_params and input_params[image_param].get('required', False):
                        if image_param not in params:
                            # Check if it's in session but not in params (auto-fix)
                            if image_param in session and session.get(image_param):
                                logger.info(f"‚ö†Ô∏è {image_param} in session but not in params for {model_id}. Auto-fixing...")
                                if isinstance(session[image_param], list):
                                    session['params'][image_param] = session[image_param].copy()
                                else:
                                    session['params'][image_param] = [session[image_param]]
                                logger.info(f"‚úÖ Fixed: {image_param} added to params")
                            else:
                                # Truly missing
                                if image_param not in excluded_params:
                                    missing.append(image_param)
                                    logger.warning(f"‚ö†Ô∏è Required {image_param} missing for {model_id}")
                        else:
                            # Already in params, verify it's not empty
                            if not params.get(image_param):
                                logger.warning(f"‚ö†Ô∏è {image_param} in params but empty for {model_id}")
                                if image_param not in excluded_params:
                                    missing.append(image_param)
                
                # For elevenlabs/speech-to-text, also check optional parameters
                model_id = session.get('model_id', '')
                if model_id == "elevenlabs/speech-to-text":
                    # Check optional parameters that haven't been set yet
                    for opt_param in ['language_code', 'tag_audio_events', 'diarize']:
                        if opt_param in properties and opt_param not in params:
                            missing.append(opt_param)
                
                if missing:
                    # Move to next parameter
                    try:
                        # Small delay to show confirmation
                        await asyncio.sleep(0.5)
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        # –ï—Å–ª–∏ –Ω–µ—Ç - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º fallback —á–µ—Ä–µ–∑ NO-SILENCE GUARD
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error starting next parameter: {e}", exc_info=True)
                        await update.message.reply_text(
                            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                        return INPUTTING_PARAMS
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    model_id = session.get('model_id', '')
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –∏–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
                    is_admin_user = get_is_admin(user_id)
                    is_free = is_free_generation_available(user_id, model_id)
                    free_info = ""
                    if is_free:
                        remaining = get_user_free_generations_remaining(user_id)
                        free_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n"
                        free_info += f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É
                        price = calculate_price_rub(model_id, params, is_admin_user)
                        price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                        if is_admin_user:
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: {price_str} ‚ÇΩ)"
                        else:
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    await update.message.reply_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{free_info}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞ –≤ input_parameters: {e}", exc_info=True)
        # –û—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–Ω—è—Ç–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
        try:
            user_lang = get_user_language(user_id)
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            await update.message.reply_text(
                f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–≤–æ–¥–∞</b>\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                f"‚Ä¢ –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
                f"‚Ä¢ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ —Å –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–∏\n"
                f"‚Ä¢ –û—Ç–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
        except Exception as reply_error:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ: {reply_error}", exc_info=True)
        track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ
        return ConversationHandler.END
    
    # ==================== TASK 1: FALLBACK –¥–ª—è waiting_for == None ====================
    # –ï—Å–ª–∏ waiting_for –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –Ω–æ –ø—Ä–∏—à—ë–ª —Ç–µ–∫—Å—Ç - –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–Ω—è—Ç—å, —á—Ç–æ –¥–µ–ª–∞—Ç—å
    if not waiting_for:
        try:
            # –°—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥—É–º–∞–ª, —á—Ç–æ –±–æ—Ç –∑–∞–≤–∏—Å
            await update.message.reply_text(
                "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...",
                parse_mode='HTML'
            )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –º–æ–¥–µ–ª–∏ prompt –≤ properties/input_params
            model_id = session.get('model_id')
            model_info = session.get('model_info', {})
            properties = session.get('properties', {})
            input_params = model_info.get('input_params', {})
            params = session.get('params', {})
            
            # –ï—Å–ª–∏ —É –º–æ–¥–µ–ª–∏ –µ—Å—Ç—å prompt –≤ input_params –∏ prompt –µ—â—ë –Ω–µ –≤ session['params']
            if 'prompt' in input_params and 'prompt' not in params:
                # –¢—Ä–∞–∫—Ç—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ prompt –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–∞–π–ø–ª–∞–π–Ω
                logger.info(f"üîß AUTO-FIX: Text received but waiting_for=None, treating as prompt for model {model_id}")
                
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º prompt
                if 'params' not in session:
                    session['params'] = {}
                session['params']['prompt'] = text
                session['waiting_for'] = None
                session['current_param'] = None
                
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–∞–π–ø–ª–∞–π–Ω –∫–∞–∫ –æ–±—ã—á–Ω–æ
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –µ—â—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                required = session.get('required', [])
                missing = [p for p in required if p not in params and p != 'prompt']
                
                if missing:
                    # –ï—Å—Ç—å –µ—â—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error starting next parameter after auto-fix prompt: {e}", exc_info=True)
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                        await update.message.reply_text(
                            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                        return INPUTTING_PARAMS
                else:
                    # –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–±—Ä–∞–Ω—ã - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                    try:
                        model_name = model_info.get('name', 'Unknown')
                        params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                        
                        is_admin_user = get_is_admin(user_id)
                        is_free = is_free_generation_available(user_id, model_id)
                        free_info = ""
                        if is_free:
                            remaining = get_user_free_generations_remaining(user_id)
                            free_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n"
                            free_info += f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                        else:
                            price = calculate_price_rub(model_id, params, is_admin_user)
                            price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
                        
                        user_lang = get_user_language(user_id)
                        keyboard = [
                            [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                            [
                                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                            ],
                            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                        ]
                        
                        await update.message.reply_text(
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                            f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{free_info}\n\n"
                            f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        return CONFIRMING_GENERATION
                    except Exception as e:
                        logger.error(f"Error showing confirmation after auto-fix prompt: {e}", exc_info=True)
            
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å - –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–Ω—è—Ç–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
            user_lang = get_user_language(user_id)
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            
            await update.message.reply_text(
                "‚ùå <b>–Ø –Ω–µ –∂–¥—É —Ç–µ–∫—Å—Ç —Å–µ–π—á–∞—Å</b>\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n"
                "‚Ä¢ –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è\n"
                "‚Ä¢ –ò–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º fallback –æ—Ç–≤–µ—Ç
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ fallback –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞: {e}", exc_info=True)
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            try:
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                ]
                await update.message.reply_text(
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ
            except:
                pass
            return ConversationHandler.END
    
    # ==================== NO-SILENCE GUARD: –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê ====================
    # –ï—Å–ª–∏ –º—ã –¥–æ—à–ª–∏ —Å—é–¥–∞ –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è - —ç—Ç–æ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì
    # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º fallback
    try:
        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è NO-SILENCE VIOLATION: input_parameters reached end without response for user {user_id}, waiting_for={waiting_for}")
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ NO-SILENCE GUARD
        await guard.check_and_ensure_response(update, context)
    except Exception as e:
        logger.error(f"‚ùå CRITICAL: Failed to check NO-SILENCE in input_parameters: {e}", exc_info=True)
        # –ï—Å–ª–∏ –¥–∞–∂–µ check_and_ensure_response —É–ø–∞–ª - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data="back_to_menu")]
            ]
            await update.message.reply_text(
                "‚ö†Ô∏è <b>–Ø –Ω–µ —Å–º–æ–≥ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∞—à –≤–≤–æ–¥.</b>\n\n"
                "–í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)
        except Exception as e2:
            logger.error(f"‚ùå CRITICAL: Failed to send NO-SILENCE fallback in input_parameters: {e2}", exc_info=True)
    # ==================== END NO-SILENCE GUARD ====================
    
    return INPUTTING_PARAMS


async def start_generation_directly(
    user_id: int,
    model_id: str,
    params: dict,
    model_info: dict,
    status_message,
    context: ContextTypes.DEFAULT_TYPE
):
    """Start generation directly without callback query. Used for auto-start after photo upload."""
    logger.info(f"üöÄ start_generation_directly called for user {user_id}, model {model_id}")
    
    is_admin_user = get_is_admin(user_id)
    
    # Check if user is blocked
    if not is_admin_user and is_user_blocked(user_id):
        await status_message.edit_text(
            "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    # Apply default values for parameters that are not set
    input_params = model_info.get('input_params', {})
    for param_name, param_info in input_params.items():
        if param_name not in params:
            default_value = param_info.get('default')
            if default_value is not None:
                params[param_name] = default_value
    
    # Convert string boolean values to actual booleans
    for param_name, param_value in params.items():
        if param_name in input_params:
            param_info = input_params[param_name]
            if param_info.get('type') == 'boolean':
                if isinstance(param_value, str):
                    if param_value.lower() == 'true':
                        params[param_name] = True
                    elif param_value.lower() == 'false':
                        params[param_name] = False
    
    # üî¥ –í–ê–õ–ò–î–ê–¶–ò–Ø –ü–ê–†–ê–ú–ï–¢–†–û–í: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–º–µ—é—Ç –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    user_lang = get_user_language(user_id) if user_id else 'ru'
    validation_errors = []
    
    for param_name, param_value in params.items():
        if param_name in input_params:
            param_info = input_params[param_name]
            param_type = param_info.get('type', 'string')
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è enum –∑–Ω–∞—á–µ–Ω–∏–π
            enum_values = param_info.get('enum')
            if enum_values:
                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
                param_value_str = str(param_value)
                if param_value_str not in enum_values:
                    # –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ enum –∑–Ω–∞—á–µ–Ω–∏–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º default –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω—è–µ–º
                    default_value = param_info.get('default')
                    if default_value and default_value in enum_values:
                        params[param_name] = default_value
                        logger.warning(f"Invalid enum value for {param_name}: {param_value_str}, using default: {default_value}")
                    else:
                        validation_errors.append(
                            f"‚ùå <b>–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ {param_name}</b>\n\n"
                            f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(enum_values)}\n"
                            f"–í–≤–µ–¥–µ–Ω–æ: {param_value_str}"
                        )
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (max_length)
            if param_type == 'string' and isinstance(param_value, str):
                max_length = param_info.get('max_length')
                if max_length and len(param_value) > max_length:
                    validation_errors.append(
                        f"‚ùå <b>–ü—Ä–µ–≤—ã—à–µ–Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ {param_name}</b>\n\n"
                        f"–ú–∞–∫—Å–∏–º—É–º: {max_length} —Å–∏–º–≤–æ–ª–æ–≤\n"
                        f"–í–≤–µ–¥–µ–Ω–æ: {len(param_value)} —Å–∏–º–≤–æ–ª–æ–≤"
                    )
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è –º–∞—Å—Å–∏–≤–æ–≤ (min_items/max_items)
            if param_type == 'array' and isinstance(param_value, list):
                min_items = param_info.get('min_items')
                max_items = param_info.get('max_items')
                if min_items is not None and len(param_value) < min_items:
                    validation_errors.append(
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ {param_name}</b>\n\n"
                        f"–ú–∏–Ω–∏–º—É–º: {min_items} —ç–ª–µ–º–µ–Ω—Ç–æ–≤\n"
                        f"–í–≤–µ–¥–µ–Ω–æ: {len(param_value)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
                    )
                if max_items is not None and len(param_value) > max_items:
                    validation_errors.append(
                        f"‚ùå <b>–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ {param_name}</b>\n\n"
                        f"–ú–∞–∫—Å–∏–º—É–º: {max_items} —ç–ª–µ–º–µ–Ω—Ç–æ–≤\n"
                        f"–í–≤–µ–¥–µ–Ω–æ: {len(param_value)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
                    )
    
    # –ï—Å–ª–∏ –µ—Å—Ç—å –æ—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if validation_errors:
        error_text = "\n\n".join(validation_errors)
        await status_message.edit_text(
            f"‚ùå <b>–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</b>\n\n{error_text}\n\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    # Check if this is a free generation
    is_free = is_free_generation_available(user_id, model_id)
    
    # Calculate price
    price = calculate_price_rub(model_id, params, is_admin_user)
    if is_free:
        price = 0.0
    
    # Check balance/limit before generation
    if not is_admin_user:
        if not is_free:
            user_balance = await get_user_balance_async(user_id)
            if user_balance < price:
                price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                balance_str = f"{user_balance:.2f}".rstrip('0').rstrip('.')
                user_lang_check = get_user_language(user_id)
                needed = price - user_balance
                needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
                
                if user_lang_check == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
                        f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image\n\n"
                        f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient Funds</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí∞ <b>Required:</b> {price_str} ‚ÇΩ\n"
                        f"üí≥ <b>Your balance:</b> {balance_str} ‚ÇΩ\n"
                        f"‚ùå <b>Need:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>What to do:</b>\n"
                        f"‚Ä¢ Top up balance via main menu\n"
                        f"‚Ä¢ Use free Z-Image generations\n\n"
                        f"üîÑ After topping up, try generation again."
                    )
                
                await status_message.edit_text(
                    insufficient_msg,
                    parse_mode='HTML'
                )
                return ConversationHandler.END
    elif user_id != ADMIN_ID:
        remaining = get_admin_remaining(user_id)
        if remaining < price:
            await status_message.edit_text(
                f"‚ùå <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç</b>\n\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞.",
                parse_mode='HTML'
            )
            return ConversationHandler.END
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    user_lang = get_user_language(user_id) if user_id else 'ru'
    model_name = model_info.get('name', model_id)
    notification_text = (
        "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
        "‚ïë  üöÄ –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–ê–ü–£–©–ï–ù–ê! üöÄ        ‚ïë\n"
        "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚úÖ <b>–í–∞—à –∑–∞–ø—Ä–æ—Å –ø—Ä–∏–Ω—è—Ç –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> <code>{model_name}</code>\n"
        f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> <b>{price:.2f} ‚ÇΩ</b>\n"
        f"‚è±Ô∏è <b>–û–∂–∏–¥–∞–µ–º–æ–µ –≤—Ä–µ–º—è:</b> 10-60 —Å–µ–∫—É–Ω–¥\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üí° <b>–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:</b>\n"
        "‚Ä¢ –ù–µ–π—Ä–æ—Å–µ—Ç—å –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å\n"
        "‚Ä¢ –ò–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n"
        "‚Ä¢ –û–±—ã—á–Ω–æ 10-60 —Å–µ–∫—É–Ω–¥\n\n"
        "‚ú® <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!</b>"
    ) if user_lang == 'ru' else (
        "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
        "‚ïë  üöÄ GENERATION STARTED! üöÄ        ‚ïë\n"
        "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚úÖ <b>Your request is accepted and processing</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"ü§ñ <b>Model:</b> <code>{model_name}</code>\n"
        f"üí∞ <b>Cost:</b> <b>{price:.2f} ‚ÇΩ</b>\n"
        f"‚è±Ô∏è <b>Expected time:</b> 10-60 seconds\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üí° <b>What's happening:</b>\n"
        "‚Ä¢ AI is analyzing your request\n"
        "‚Ä¢ Content creation in progress\n"
        "‚Ä¢ Usually 10-60 seconds\n\n"
        "‚ú® <b>Result will appear automatically!</b>"
    )
    await status_message.edit_text(notification_text, parse_mode='HTML')
    
    # Prepare params for API
    api_params = params.copy()
    
    # üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ü–†–ê–í–ò–õ–û: –í–°–ï –º–æ–¥–µ–ª–∏ –î–û–õ–ñ–ù–´ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API Endpoints —Å—Ç—Ä–æ–≥–æ –ø–æ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    # üìö –ò–°–¢–û–ß–ù–ò–ö–ò:
    # - https://docs.kie.ai/ - Comprehensive API Documentation
    # - https://docs.kie.ai/market - Market Documentation (–≤—Å–µ –º–æ–¥–µ–ª–∏: Image, Video, Audio)
    # - https://kie.ai/ru - –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞
    # –ù–ò–ö–ê–ö–ò–• –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API Endpoints!
    # –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    
    # CRITICAL: KIE API compliance - recraft/remove-background requires input.image (string URL)
    # Documentation: https://docs.kie.ai/market/recraft/remove-background
    # API expects: {"model": "recraft/remove-background", "input": {"image": "https://..."}}
    if model_id == "recraft/remove-background" and 'image_input' in api_params:
        image_input = api_params.pop('image_input')
        if isinstance(image_input, list) and len(image_input) > 0:
            api_params['image'] = image_input[0]  # Take first URL from array
        elif isinstance(image_input, str):
            api_params['image'] = image_input  # Use string URL directly
    elif model_id == "recraft/crisp-upscale" and 'image_input' in api_params:
        image_input = api_params.pop('image_input')
        if isinstance(image_input, list) and len(image_input) > 0:
            api_params['image'] = image_input[0]
        elif isinstance(image_input, str):
            api_params['image'] = image_input
    elif model_id == "ideogram/v3-reframe" and 'image_input' in api_params:
        image_input = api_params.pop('image_input')
        if isinstance(image_input, list) and len(image_input) > 0:
            api_params['image_url'] = image_input[0]
        elif isinstance(image_input, str):
            api_params['image_url'] = image_input
    elif model_id == "topaz/image-upscale" and 'image_input' in api_params:
        image_input = api_params.pop('image_input')
        if isinstance(image_input, list) and len(image_input) > 0:
            api_params['image_url'] = image_input[0]
        elif isinstance(image_input, str):
            api_params['image_url'] = image_input
    
    # Check maximum concurrent generations
    async with active_generations_lock:
        user_active_count = sum(1 for (uid, _) in active_generations.keys() if uid == user_id)
        if user_active_count >= MAX_CONCURRENT_GENERATIONS_PER_USER:
            await status_message.edit_text(
                f"‚ö†Ô∏è <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                f"–£ –≤–∞—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω–æ {user_active_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n"
                f"–ú–∞–∫—Å–∏–º—É–º: {MAX_CONCURRENT_GENERATIONS_PER_USER}.",
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # üî¥ –ü–†–û–í–ï–†–ö–ê –ù–ê –î–£–ë–õ–ò –ó–ê–î–ê–ß: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å —Ç–∞–∫–∏–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        # –°–æ–∑–¥–∞–µ–º —Ö–µ—à –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥—É–±–ª–µ–π
        import hashlib
        import json
        params_hash = hashlib.md5(
            json.dumps({
                'model_id': model_id,
                'params': sorted(api_params.items()) if isinstance(api_params, dict) else str(api_params)
            }, sort_keys=True).encode('utf-8')
        ).hexdigest()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –¥—É–±–ª–∏
        for (uid, existing_task_id), existing_session in active_generations.items():
            if uid == user_id:
                existing_model = existing_session.get('model_id')
                existing_params = existing_session.get('params', {})
                existing_params_hash = hashlib.md5(
                    json.dumps({
                        'model_id': existing_model,
                        'params': sorted(existing_params.items()) if isinstance(existing_params, dict) else str(existing_params)
                    }, sort_keys=True).encode('utf-8')
                ).hexdigest()
                
                if existing_params_hash == params_hash:
                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è DUPLICATE TASK DETECTED: user {user_id}, model {model_id}, existing task_id={existing_task_id}")
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_msg = (
                        "‚ö†Ô∏è <b>–î—É–±–ª–∏—Ä—É—é—â–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                        f"–£ –≤–∞—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å —Ç–∞–∫–∏–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.\n"
                        f"Task ID: <code>{existing_task_id}</code>\n\n"
                        "–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                    ) if user_lang == 'ru' else (
                        "‚ö†Ô∏è <b>Duplicate generation</b>\n\n"
                        f"You already have a generation running with the same parameters.\n"
                        f"Task ID: <code>{existing_task_id}</code>\n\n"
                        "Please wait for the current generation to complete."
                    )
                    await status_message.edit_text(error_msg, parse_mode='HTML')
                    return ConversationHandler.END
    
    # DRY-RUN GUARD: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Ä–µ–∞–ª—å–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å
    dry_run = is_dry_run() or not allow_real_generation()
    
    if dry_run:
        logger.info(f"üîß DRY-RUN: Simulating generation for model {model_id}, user {user_id}")
        # –°–æ–∑–¥–∞–µ–º –º–æ–∫–æ–≤—ã–π task_id
        import hashlib
        task_id = f"dry_run_{hashlib.md5(f'{model_id}:{user_id}:{time.time()}'.encode()).hexdigest()[:12]}"
        
        # –ü–æ–ª—É—á–∞–µ–º gateway –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–æ–∫–æ–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        gateway = get_kie_gateway()
        
        # –°–æ–∑–¥–∞–µ–º –º–æ–∫–æ–≤—É—é –∑–∞–¥–∞—á—É —á–µ—Ä–µ–∑ gateway (–æ–Ω –≤–µ—Ä–Ω–µ—Ç –º–æ–∫–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç)
        try:
            result = await gateway.create_task(model_id, api_params)
            logger.info(f"üîß DRY-RUN: Mock task created: {result.get('taskId')}")
        except Exception as e:
            logger.error(f"‚ùå DRY-RUN: Error creating mock task: {e}")
            result = {'ok': True, 'taskId': task_id}
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–æ–∫–æ–≤—ã–π URL —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        is_video = any(kw in model_id.lower() for kw in ['video', 'sora', 'kling', 'wan', 'hailuo'])
        ext = '.mp4' if is_video else '.png'
        mock_url = f"https://example.com/mock/{model_id.replace('/', '_')}/{task_id}{ext}"
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–º–µ—Ç–∫–æ–π DRY-RUN
        user_lang = get_user_language(user_id) if user_id else 'ru'
        dry_run_text = "üîß DRY-RUN: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–∞" if user_lang == 'ru' else "üîß DRY-RUN: Generation simulated"
        
        if is_admin_user:
            message_text = (
                f"‚úÖ <b>{dry_run_text}</b>\n\n"
                f"Task ID: <code>{task_id}</code>\n"
                f"Model: <code>{model_id}</code>\n\n"
                f"üîó Mock URL: {mock_url}\n\n"
                f"‚ö†Ô∏è –ë–∞–ª–∞–Ω—Å –ù–ï —Å–ø–∏—Å–∞–Ω (DRY-RUN —Ä–µ–∂–∏–º)"
            )
        else:
            message_text = (
                f"‚úÖ <b>{dry_run_text}</b>\n\n"
                f"üîó –†–µ–∑—É–ª—å—Ç–∞—Ç: {mock_url}"
            )
        
        await status_message.edit_text(message_text, parse_mode='HTML')
        
        # –ù–ï —Å–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –≤ DRY-RUN
        # –ù–ï —Å–æ–∑–¥–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é, —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º
        logger.info(f"üîß DRY-RUN: Would deduct {price} from user {user_id} (NOT DEDUCTED)")
        if create_operation:
            try:
                # –°–æ–∑–¥–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é —Å –ø–æ–º–µ—Ç–∫–æ–π dry_run (–µ—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç)
                create_operation(user_id, "dry_run_generation", Decimal('0.00'), model_id, mock_url, None)
            except:
                pass
        
        return ConversationHandler.END
    
    # REAL GENERATION: –ò—Å–ø–æ–ª—å–∑—É–µ–º gateway
    gateway = get_kie_gateway()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ –≤ normalize_for_generation –≤—ã—à–µ
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ä–µ–∑ kie_validator –Ω–µ –Ω—É–∂–Ω–∞, —Ç.–∫. –æ–Ω–∞ –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –ø–æ YAML,
    # –∞ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω—ã –∫ API —Ñ–æ—Ä–º–∞—Ç—É
    
    # üî¥ –ö–†–ò–¢–ò–ß–ù–û: –°–ø–∏—Å–∞–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –î–û —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏ (–∞—Ç–æ–º–∞—Ä–Ω–æ)
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—É –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞ (official_usd * –∫—É—Ä—Å * 2)
    if not is_admin_user and not is_free:
        # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞
        from app.services.pricing_service import price_for_model_rub, get_model_price_info
        from app.config import get_settings
        
        settings = get_settings()
        mode_index = 0  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–≤—ã–π —Ä–µ–∂–∏–º
        price_rub_catalog = price_for_model_rub(model_id, mode_index, settings)
        
        if price_rub_catalog is None:
            logger.error(f"Price not found in catalog for model {model_id}, using calculated price")
            price_rub_catalog = price
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–µ
        price_info = get_model_price_info(model_id, mode_index, settings)
        if price_info:
            logger.info(
                f"PRICE_RUB={price_rub_catalog} OFFICIAL_USD={price_info['official_usd']:.4f} "
                f"MULT={price_info['price_multiplier']} RATE={price_info['usd_to_rub']} "
                f"MODEL={model_id} USER={user_id}"
            )
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
        user_balance_check = await get_user_balance_async(user_id)
        if user_balance_check < price_rub_catalog:
            price_str = f"{price_rub_catalog:.2f}".rstrip('0').rstrip('.')
            balance_str = f"{user_balance_check:.2f}".rstrip('0').rstrip('.')
            user_lang_check = get_user_language(user_id)
            needed = price_rub_catalog - user_balance_check
            needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
            
            if user_lang_check == 'ru':
                insufficient_msg = (
                    f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                    f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                    f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                )
            else:
                insufficient_msg = (
                    f"‚ùå <b>Insufficient funds</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí≥ <b>Your balance:</b> {balance_str} ‚ÇΩ\n"
                    f"üí∞ <b>Required:</b> {price_str} ‚ÇΩ\n"
                    f"‚ùå <b>Missing:</b> {needed_str} ‚ÇΩ\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° Top up balance to generate"
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang_check), callback_data="topup_balance")],
                [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang_check), callback_data="back_to_menu")]
            ]
            
            await status_message.edit_text(insufficient_msg, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
            return ConversationHandler.END
        
        # –°–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –î–û —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
        success = await subtract_user_balance_async(user_id, price_rub_catalog)
        if not success:
            logger.error(f"Failed to deduct balance for user {user_id}, amount {price_rub_catalog}")
            user_lang_check = get_user_language(user_id)
            error_msg = (
                f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞</b>\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
            ) if user_lang_check == 'ru' else (
                f"‚ùå <b>Balance deduction error</b>\n\n"
                f"Please try later or contact support."
            )
            await status_message.edit_text(error_msg, parse_mode='HTML')
            return ConversationHandler.END
        
        # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ —Å–ø–∏—Å–∞–Ω–∏–µ
        new_balance = await get_user_balance_async(user_id)
        logger.info(
            f"BALANCE VERIFIED: user_id={user_id} deducted={price_rub_catalog} "
            f"old_balance={user_balance_check:.2f} new_balance={new_balance:.2f} model={model_id}"
        )
        
        # –û–±–Ω–æ–≤–ª—è–µ–º price –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        price = price_rub_catalog
    
    # Create task
    # CRITICAL: Log exact API parameters being sent (for KIE API compliance)
    import json
    logger.info(f"event=kie.create_task_start model={model_id} user_id={user_id}")
    logger.debug(f"API Parameters: model={model_id}, input_keys={list(api_params.keys())}")
    
    # üî¥ API CALL: KIE API - create_task —á–µ—Ä–µ–∑ gateway
    try:
        import time
        start_time = time.time()
        
        # –ü–æ–ª—É—á–∞–µ–º callback URL –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
        callback_url = None
        try:
            from app.services.kie_input_builder import get_callback_url
            callback_url = get_callback_url()
        except:
            pass
        
        result = await gateway.create_task(model_id, api_params, callback_url=callback_url)
        elapsed = time.time() - start_time
        
        # –õ–æ–≥–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ—Ç–∫–ª–∏–∫–∞
        try:
            from optimization_helpers import log_api_response_time
            log_api_response_time(f"KIE API create_task (model={model_id})", elapsed)
        except ImportError:
            if elapsed > 2.0:
                logger.warning(f"‚è±Ô∏è create_task –∑–∞–Ω—è–ª–æ {elapsed:.2f}—Å (–º–µ–¥–ª–µ–Ω–Ω–æ)")
            else:
                logger.debug(f"‚è±Ô∏è create_task –∑–∞–Ω—è–ª–æ {elapsed:.2f}—Å")
        
        logger.info(f"üìã Task creation result: ok={result.get('ok')}, taskId={result.get('taskId')}, error={result.get('error')}")
    except Exception as e:
        logger.error(f"event=kie.create_task_exception model={model_id} error={str(e)}", exc_info=True)
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
            await status_message.edit_text(
                f"‚ùå <b>{error_msg}</b>\n\n"
                f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.",
                parse_mode='HTML'
            )
        except:
            pass
        return ConversationHandler.END
    
    if result.get('ok'):
        task_id = result.get('taskId')
        
        # Get session
        if user_id not in user_sessions:
            logger.error(f"Session not found for user {user_id}")
            await status_message.edit_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", parse_mode='HTML')
            return ConversationHandler.END
        
        session = user_sessions[user_id]
        generation_key = (user_id, task_id)
        
        # Store task data
        session['task_id'] = task_id
        session['poll_attempts'] = 0
        session['max_poll_attempts'] = 60
        session['is_free_generation'] = is_free
        session['model_id'] = model_id
        session['model_info'] = model_info
        session['params'] = api_params.copy()
        
        # Move to active_generations
        async with active_generations_lock:
            user_active_count_now = sum(1 for (uid, _) in active_generations.keys() if uid == user_id)
            if user_active_count_now >= MAX_CONCURRENT_GENERATIONS_PER_USER:
                await status_message.edit_text(
                    f"‚ö†Ô∏è <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            active_generations[generation_key] = session.copy()
            final_count = user_active_count_now + 1
        
        # Remove from user_sessions
        if user_id in user_sessions:
            del user_sessions[user_id]
        
        # Update status message
        if is_admin_user:
            message_text = (
                f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                f"Task ID: <code>{task_id}</code>\n\n"
                f"‚è≥ –û–∂–∏–¥–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...\n\n"
                f"üìä –ê–∫—Ç–∏–≤–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: {final_count}/{MAX_CONCURRENT_GENERATIONS_PER_USER}"
            )
        else:
            message_text = (
                f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                f"‚è≥ –û–∂–∏–¥–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏..."
            )
        
        await status_message.edit_text(message_text, parse_mode='HTML')
        
        # Start polling - create mock update for poll_task_status
        class MockUpdate:
            def __init__(self, user_id, message):
                self.effective_user = type('obj', (object,), {'id': user_id})()
                self.message = message
        
        mock_update = MockUpdate(user_id, status_message)
        logger.info(f"üöÄüöÄüöÄ Starting polling for task {task_id}, user {user_id}, model {model_id}")
        asyncio.create_task(poll_task_status(mock_update, context, task_id, user_id))
        logger.info(f"‚úÖ‚úÖ‚úÖ Polling task created for task {task_id}")
        
        # ‚ö†Ô∏è –í–ê–ñ–ù–û: –ë–∞–ª–∞–Ω—Å –ù–ï —Å–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –∑–¥–µ—Å—å!
        # –ë–∞–ª–∞–Ω—Å –±—É–¥–µ—Ç —Å–ø–∏—Å–∞–Ω —Ç–æ–ª—å–∫–æ –ü–û–°–õ–ï —É—Å–ø–µ—à–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ poll_task_status
        # –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–ª–∞—Ç–∏—Ç —Ç–æ–ª—å–∫–æ –∑–∞ —É—Å–ø–µ—à–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        logger.info(f"üí∞ Balance will be deducted after successful generation (task_id={task_id})")
        
        return ConversationHandler.END
    else:
        error = result.get('error', 'Unknown error')
        status_code = result.get('status')
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–Ω—è—Ç–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        try:
            from error_handler_providers import get_error_handler
            handler = get_error_handler()
            if status_code:
                user_message, error_details = handler.handle_api_error(
                    status_code=status_code,
                    response_data={"error": error},
                    request_details={
                        "model_id": model_id,
                        "params": api_params
                    }
                )
            else:
                user_message, error_details = handler.handle_task_creation_error(
                    model_id=model_id,
                    error=Exception(error),
                    request_params=api_params
                )
        except ImportError:
            user_message = (
                f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏</b>\n\n"
                f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error}\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
        
        await status_message.edit_text(user_message, parse_mode='HTML')
        return ConversationHandler.END


async def confirm_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Handle generation confirmation.
    
    ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ê–í–ò–õ–ê KIE AI - –ó–ê–§–ò–ö–°–ò–†–û–í–ê–ù–û –ù–ê–í–°–ï–ì–î–ê:
    
    üî¥ –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ü–†–ê–í–ò–õ–û #0 (–ì–õ–ê–í–ù–û–ï):
    –í–°–ï –º–æ–¥–µ–ª–∏ –î–û–õ–ñ–ù–´ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API Endpoints —Å—Ç—Ä–æ–≥–æ –ø–æ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏:
    https://docs.kie.ai/market - Market Documentation (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û!)
    https://docs.kie.ai/ - Comprehensive API Documentation
    https://kie.ai/ru - –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞
    –ù–ò–ö–ê–ö–ò–• –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API Endpoints!
    
    1. –í–°–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ —Å—Ç—Ä–æ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º KIE AI API
    2. –ù–ò–ß–ï–ì–û –æ—Ç —Å–µ–±—è –Ω–µ –ø—Ä–∏–¥—É–º—ã–≤–∞—Ç—å - —Ç–æ–ª—å–∫–æ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ KIE AI
    3. –í–°–ï –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ –±—ã—Ç—å –∑–∞–ø—Ä–æ—à–µ–Ω—ã —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    4. –í–°–ï –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ –±—ã—Ç—å –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω—ã –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
    5. –§–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å—Ç—Ä–æ–≥–æ –ø–æ –≤–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—ã–º —Ñ–∞–π–ª–∞–º (validate_*.py)
    6. –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ç–æ–ª—å–∫–æ —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º KIE API
    7. –ß–∏—Å–ª–∞ –æ–∫—Ä—É–≥–ª—è—é—Ç—Å—è —Å–æ–≥–ª–∞—Å–Ω–æ step (0.01 –¥–ª—è strength, 0.1 –¥–ª—è guidance_scale)
    8. output_format –≤ lowercase –¥–ª—è qwen –º–æ–¥–µ–ª–µ–π (png, jpeg)
    9. –ù–∏–∫–∞–∫–∏—Ö –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    10. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤ KIE API
    
    üìö –ò–°–¢–û–ß–ù–ò–ö–ò –ü–†–ê–í–ò–õ:
    - https://docs.kie.ai/market - Market Documentation (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û! Image/Video/Audio Models)
    - https://docs.kie.ai/ - Comprehensive API Documentation
    - https://kie.ai/ru - –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞
    - llms.txt: https://docs.kie.ai/llms.txt - –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    
    –°–º. KIE_AI_STRICT_RULES.md –∏ KIE_AI_API_ENDPOINTS_RULE.md –¥–ª—è –ø–æ–ª–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π.
    """
    import time
    start_time = time.time()
    query = update.callback_query
    user_id = update.effective_user.id
    logger.info(f"üî•üî•üî• CONFIRM_GENERATION ENTRY: user_id={user_id}, query_id={query.id if query else 'None'}, data={query.data if query else 'None'}")
    
    # Answer callback immediately if present
    if query:
        try:
            await query.answer()
        except Exception as e:
            logger.warning(f"Could not answer callback query: {e}")
    
    is_admin_user = get_is_admin(user_id)
    
    # Helper function to send/edit messages safely
    async def send_or_edit_message(text, parse_mode='HTML'):
        try:
            if query:
                try:
                    await query.edit_message_text(text, parse_mode=parse_mode)
                except Exception as edit_error:
                    logger.warning(f"Could not edit message: {edit_error}, sending new")
                    try:
                        await query.message.reply_text(text, parse_mode=parse_mode)
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message: {send_error}")
                        await context.bot.send_message(chat_id=user_id, text=text, parse_mode=parse_mode)
            else:
                await context.bot.send_message(chat_id=user_id, text=text, parse_mode=parse_mode)
        except Exception as e:
            logger.error(f"Error in send_or_edit_message: {e}", exc_info=True)
            try:
                await context.bot.send_message(chat_id=user_id, text=text, parse_mode=parse_mode)
            except:
                pass
    
    # Check if user is blocked
    if not is_admin_user and is_user_blocked(user_id):
        await send_or_edit_message(
            "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏."
        )
        return ConversationHandler.END
    
    if user_id not in user_sessions:
        logger.error(f"‚ùå‚ùå‚ùå CRITICAL: Session not found in confirm_generation! user_id={user_id}, available_sessions={list(user_sessions.keys())[:10]}")
        
        # CRITICAL: Try to restore from backup in context.user_data
        if hasattr(context, 'user_data') and context.user_data.get('session_backup_user_id') == user_id:
            session_backup = context.user_data.get('session_backup')
            if session_backup:
                logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Restoring session from context.user_data backup for user_id={user_id}")
                user_sessions[user_id] = session_backup.copy()
                logger.info(f"‚úÖ‚úÖ‚úÖ Session restored from context.user_data: user_id={user_id}, model_id={session_backup.get('model_id')}")
            else:
                await send_or_edit_message("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
                return ConversationHandler.END
        else:
            await send_or_edit_message("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
            return ConversationHandler.END
    
    session = user_sessions[user_id]
    logger.info(f"‚úÖ‚úÖ‚úÖ Session found in confirm_generation: user_id={user_id}, model_id={session.get('model_id')}, params_keys={list(session.get('params', {}).keys())}")
    
    # CRITICAL: Check if task_id already exists in session (prevent duplicate)
    if 'task_id' in session:
        task_id_existing = session.get('task_id')
        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Task {task_id_existing} already exists in session for user {user_id}, preventing duplicate")
        await send_or_edit_message(
            f"‚ö†Ô∏è <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞</b>\n\n"
            f"–ó–∞–¥–∞—á–∞ —É–∂–µ —Å–æ–∑–¥–∞–Ω–∞.\n"
            f"Task ID: <code>{task_id_existing}</code>",
            parse_mode='HTML'
        )
        return ConversationHandler.END
    model_id = session.get('model_id')
    params = session.get('params', {})
    model_info = session.get('model_info', {})
    
    # CRITICAL: Check if task already exists in active_generations to prevent duplicate
    async with active_generations_lock:
        user_active_generations = [(uid, tid) for (uid, tid) in active_generations.keys() if uid == user_id]
        if user_active_generations:
            # Check if there's a recent generation for this model (within last 10 seconds)
            import time
            current_time = time.time()
            for (uid, tid) in user_active_generations:
                gen_session = active_generations.get((uid, tid))
                if gen_session and gen_session.get('model_id') == model_id:
                    created_time = gen_session.get('created_at', current_time)
                    if current_time - created_time < 10:  # Within 10 seconds
                        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Duplicate generation detected! Task {tid} was created recently for user {user_id}, model {model_id}")
                        await send_or_edit_message(
                            f"‚ö†Ô∏è <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞</b>\n\n"
                            f"–ó–∞–¥–∞—á–∞ —É–∂–µ —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è.\n"
                            f"Task ID: <code>{tid}</code>",
                            parse_mode='HTML'
                        )
                        return ConversationHandler.END
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–µ—Ä –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    from kie_input_adapter import normalize_for_generation
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: –ø—Ä–∏–º–µ–Ω—è–µ–º –¥–µ—Ñ–æ–ª—Ç—ã, –≤–∞–ª–∏–¥–∏—Ä—É–µ–º, –∞–¥–∞–ø—Ç–∏—Ä—É–µ–º –∫ API
    api_params, validation_errors = normalize_for_generation(model_id, params)
    
    if validation_errors:
        # –û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        user_lang = get_user_language(user_id) if user_id else 'ru'
        error_text = (
            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</b>\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"{chr(10).join('‚Ä¢ ' + err for err in validation_errors[:5])}\n\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        ) if user_lang == 'ru' else (
            f"‚ùå <b>Parameter validation error</b>\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"{chr(10).join('‚Ä¢ ' + err for err in validation_errors[:5])}\n\n"
            f"Please check parameters and try again."
        )
        await send_or_edit_message(error_text)
        return ConversationHandler.END
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º api_params –≤–º–µ—Å—Ç–æ params
    params = api_params
    
    # üî¥ –ö–†–ò–¢–ò–ß–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º builder –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ —Ç–∏–ø—É –º–æ–¥–µ–ª–∏
    try:
        from app.kie_catalog import get_model
        from app.services.kie_input_builder import build_input, get_callback_url
        
        model_spec = get_model(model_id)
        if model_spec:
            # –°—Ç—Ä–æ–∏–º input —Å—Ç—Ä–æ–≥–æ –ø–æ —Ç–∏–ø—É –º–æ–¥–µ–ª–∏ (whitelist + –≤–∞–ª–∏–¥–∞—Ü–∏—è)
            mode_index = 0  # TODO: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å mode_index –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            built_input, build_error = build_input(model_spec, api_params, mode_index)
            
            if build_error:
                # –ú—è–≥–∫–∞—è –æ—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                user_lang = get_user_language(user_id) if user_id else 'ru'
                error_text = (
                    f"‚ùå <b>{build_error}</b>\n\n"
                    f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                ) if user_lang == 'ru' else (
                    f"‚ùå <b>{build_error}</b>\n\n"
                    f"Please check parameters and try again."
                )
                await send_or_edit_message(error_text)
                return ConversationHandler.END
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π input
            api_params = built_input
            logger.info(f"‚úÖ Input built from catalog: MODEL={model_id} TYPE={model_spec.type} KEYS={list(built_input.keys())}")
        else:
            logger.warning(f"‚ö†Ô∏è Model {model_id} not found in catalog, using original api_params")
    except Exception as e:
        logger.error(f"‚ùå Error building input from catalog: {e}", exc_info=True)
        # Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ api_params
        pass
    
    # Check if this is a free generation
    is_free = is_free_generation_available(user_id, model_id)
    
    # Calculate price (admins pay admin price, users pay user price)
    price = calculate_price_rub(model_id, params, is_admin_user)
    
    # For free generations, price is 0
    if is_free:
        price = 0.0
    
    # Check balance/limit before generation
    if not is_admin_user:
        # Regular user - check balance (unless free generation)
        if not is_free:
            user_balance = await get_user_balance_async(user_id)
            if user_balance < price:
                price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                balance_str = f"{user_balance:.2f}".rstrip('0').rstrip('.')
                remaining_free = get_user_free_generations_remaining(user_id)
                
                user_lang = get_user_language(user_id)
                needed = price - user_balance
                needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
                
                if user_lang == 'ru':
                    error_text = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    )
                    
                    if model_id == FREE_MODEL_ID and remaining_free > 0:
                        error_text += (
                            f"üéÅ <b>–ù–æ —É –≤–∞—Å –µ—Å—Ç—å {remaining_free} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!</b>\n\n"
                            f"üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ - –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."
                        )
                    else:
                        error_text += (
                            f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                            f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å¬ª\n"
                            f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image (5 –≤ –¥–µ–Ω—å)\n"
                            f"‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å—ã\n\n"
                            f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                        )
                else:
                    error_text = (
                        f"‚ùå <b>Insufficient Funds</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí∞ <b>Required:</b> {price_str} ‚ÇΩ\n"
                        f"üí≥ <b>Your balance:</b> {balance_str} ‚ÇΩ\n"
                        f"‚ùå <b>Need:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    )
                    
                    if model_id == FREE_MODEL_ID and remaining_free > 0:
                        error_text += (
                            f"üéÅ <b>But you have {remaining_free} free generations!</b>\n\n"
                            f"üí° Try again - free generation will be used automatically."
                        )
                    else:
                        error_text += (
                            f"üí° <b>What to do:</b>\n"
                            f"‚Ä¢ Top up balance via ¬´üí≥ Top Up Balance¬ª button\n"
                            f"‚Ä¢ Use free Z-Image generations (5 per day)\n"
                            f"‚Ä¢ Invite a friend and get bonuses\n\n"
                            f"üîÑ After topping up, try generation again."
                        )
                
                await send_or_edit_message(error_text)
                return ConversationHandler.END
    elif user_id != ADMIN_ID:
        # Limited admin - check limit
        remaining = get_admin_remaining(user_id)
        if remaining < price:
            price_str = f"{price:.2f}".rstrip('0').rstrip('.')
            remaining_str = f"{remaining:.2f}".rstrip('0').rstrip('.')
            limit = get_admin_limit(user_id)
            spent = get_admin_spent(user_id)
            await send_or_edit_message(
                f"‚ùå <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç</b>\n\n"
                f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                f"üí≥ <b>–õ–∏–º–∏—Ç:</b> {limit:.2f} ‚ÇΩ\n"
                f"üí∏ <b>–ü–æ—Ç—Ä–∞—á–µ–Ω–æ:</b> {spent:.2f} ‚ÇΩ\n"
                f"‚úÖ <b>–û—Å—Ç–∞–ª–æ—Å—å:</b> {remaining_str} ‚ÇΩ\n\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞."
            )
            return ConversationHandler.END
    
    model_name = model_info.get('name', model_id) if model_info else model_id
    user_lang = get_user_language(user_id) if user_id else 'ru'
    loading_msg = (
        "üîÑ <b>–°–æ–∑–¥–∞—é –∑–∞–¥–∞—á—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...</b>\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "‚è≥ <b>–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å</b>\n\n"
        "ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
        "üí° –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥..."
    ).format(model_name=model_name) if user_lang == 'ru' else (
        "üîÑ <b>Creating generation task...</b>\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "‚è≥ <b>Please wait, processing your request</b>\n\n"
        "ü§ñ <b>Model:</b> {model_name}\n\n"
        "üí° Usually takes a few seconds..."
    ).format(model_name=model_name)
    await send_or_edit_message(loading_msg)
    
    try:
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω—ã –∫ API —á–µ—Ä–µ–∑ normalize_for_generation –≤—ã—à–µ
        api_params = params  # params —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç API-—Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        
        # –°—Ç–∞—Ä—ã–π –∫–æ–¥ –º–∞–ø–ø–∏–Ω–≥–∞ —É–¥–∞–ª–µ–Ω - —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è kie_input_adapter
        # –í—Å–µ –º–∞–ø–ø–∏–Ω–≥–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ API_PARAM_MAPPINGS –≤ kie_input_adapter.py
        # –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–∞–∫–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –∞–¥–∞–ø—Ç–µ—Ä–µ - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–ª–æ–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —É–¥–∞–ª–µ–Ω—ã
        
        # For seedream/4.5-edit, validate and normalize parameters
        # NOTE: Price calculation - Currently fixed at 6.5 credits regardless of quality/aspect_ratio
        # If API pricing changes based on quality (basic=2K, high=4K), update calculate_price_rub() accordingly
        if model_id == "seedream/4.5-edit":
            # Validate prompt (required, max 3000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ seedream/4.5-edit."
                await send_or_edit_message(error_msg)
                logger.error(f"Missing required parameter prompt for seedream/4.5-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 3000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 3000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await send_or_edit_message(error_msg)
                logger.error(f"prompt too long for seedream/4.5-edit: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs)
            # Note: image_input is converted to image_urls earlier in the code
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ seedream/4.5-edit."
                await send_or_edit_message(error_msg)
                logger.error(f"Missing required parameter image_urls for seedream/4.5-edit")
                return ConversationHandler.END
            
            # Ensure image_urls is a list
            image_urls = api_params['image_urls']
            if not isinstance(image_urls, list):
                # Convert single URL to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_urls type for seedream/4.5-edit: {type(image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty
            if len(image_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º."
                await send_or_edit_message(error_msg)
                logger.error(f"Empty image_urls array for seedream/4.5-edit")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_urls[{i}] for seedream/4.5-edit: {url}")
                    return ConversationHandler.END
            
            api_params['image_urls'] = [url.strip() for url in image_urls]
            
            # Validate aspect_ratio (required, enum values)
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "2:3", "3:2", "21:9"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for seedream/4.5-edit: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate and normalize quality (required, enum values: basic/high)
            # NOTE: Quality affects output (basic=2K, high=4K) but currently doesn't affect price
            # If API pricing changes, update calculate_price_rub() to use params.get('quality')
            # API accepts "basic" or "high" (lowercase), but user might send "Basic" or "High"
            valid_qualities = ["basic", "high"]
            if 'quality' not in api_params or not api_params.get('quality'):
                # Use default if not set
                api_params['quality'] = "basic"
            else:
                quality = str(api_params['quality']).strip().lower()
                # Normalize: Basic/High -> basic/high (already lowercased above)
                if quality not in valid_qualities:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ quality.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: basic, high\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('quality')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid quality for seedream/4.5-edit: {api_params.get('quality')}")
                    return ConversationHandler.END
                api_params['quality'] = quality
        
        # For kling-2.6/image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on duration and sound parameters
        # 5s no-audio: 55 credits, 10s no-audio: 110 credits
        # 5s with audio: 110 credits, 10s with audio: 220 credits
        if model_id == "kling-2.6/image-to-video":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/image-to-video."
                await send_or_edit_message(error_msg)
                logger.error(f"Missing required parameter prompt for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await send_or_edit_message(error_msg)
                logger.error(f"prompt too long for kling-2.6/image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs)
            # Note: image_input is converted to image_urls earlier in the code
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/image-to-video."
                await send_or_edit_message(error_msg)
                logger.error(f"Missing required parameter image_urls for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            # Ensure image_urls is a list
            image_urls = api_params['image_urls']
            if not isinstance(image_urls, list):
                # Convert single URL to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_urls type for kling-2.6/image-to-video: {type(image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty
            if len(image_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º."
                await send_or_edit_message(error_msg)
                logger.error(f"Empty image_urls array for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_urls[{i}] for kling-2.6/image-to-video: {url}")
                    return ConversationHandler.END
            
            api_params['image_urls'] = [url.strip() for url in image_urls]
            
            # Validate sound (required, boolean)
            # NOTE: This parameter affects price - with sound costs more
            if 'sound' not in api_params:
                # Use default if not set
                api_params['sound'] = False
            else:
                sound = api_params.get('sound')
                # Normalize boolean: convert string "true"/"false" to boolean if needed
                if isinstance(sound, str):
                    sound_lower = sound.lower().strip()
                    if sound_lower in ['true', '1', 'yes', 'on']:
                        sound = True
                    elif sound_lower in ['false', '0', 'no', 'off', '']:
                        sound = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ sound.\n"
                            f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: true, false\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {sound}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid sound value for kling-2.6/image-to-video: {sound}")
                        return ConversationHandler.END
                elif not isinstance(sound, bool):
                    # Convert to boolean if it's a number
                    if isinstance(sound, (int, float)):
                        sound = bool(sound)
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä sound –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(sound).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid sound type for kling-2.6/image-to-video: {type(sound)}")
                        return ConversationHandler.END
                api_params['sound'] = sound
            
            # Validate duration (required, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' not in api_params or not api_params.get('duration'):
                # Use default if not set
                api_params['duration'] = "5"
            else:
                duration = str(api_params['duration']).strip()
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ duration.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_durations)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {duration}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling-2.6/image-to-video: {duration}")
                    return ConversationHandler.END
                api_params['duration'] = duration
        
        # For kling-2.6/text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on duration and sound parameters (same as image-to-video)
        # 5s no-audio: 55 credits, 10s no-audio: 110 credits
        # 5s with audio: 110 credits, 10s with audio: 220 credits
        # aspect_ratio does NOT affect price
        if model_id == "kling-2.6/text-to-video":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling-2.6/text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for kling-2.6/text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate sound (required, boolean)
            # NOTE: This parameter affects price - with sound costs more
            if 'sound' not in api_params:
                # Use default if not set
                api_params['sound'] = False
            else:
                sound = api_params.get('sound')
                # Normalize boolean: convert string "true"/"false" to boolean if needed
                if isinstance(sound, str):
                    sound_lower = sound.lower().strip()
                    if sound_lower in ['true', '1', 'yes', 'on']:
                        sound = True
                    elif sound_lower in ['false', '0', 'no', 'off', '']:
                        sound = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ sound.\n"
                            f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: true, false\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {sound}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid sound value for kling-2.6/text-to-video: {sound}")
                        return ConversationHandler.END
                elif not isinstance(sound, bool):
                    # Convert to boolean if it's a number
                    if isinstance(sound, (int, float)):
                        sound = bool(sound)
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä sound –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(sound).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid sound type for kling-2.6/text-to-video: {type(sound)}")
                        return ConversationHandler.END
                api_params['sound'] = sound
            
            # Validate aspect_ratio (required, enum values: "1:1", "16:9", "9:16")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "16:9", "9:16"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for kling-2.6/text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate duration (required, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' not in api_params or not api_params.get('duration'):
                # Use default if not set
                api_params['duration'] = "5"
            else:
                duration = str(api_params['duration']).strip()
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ duration.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_durations)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {duration}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling-2.6/text-to-video: {duration}")
                    return ConversationHandler.END
                api_params['duration'] = duration
        
        # For z-image, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 0.8 credits per image (doesn't depend on parameters)
        if model_id == "z-image":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ z-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for z-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for z-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values)
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for z-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
        
        # For flux-2/pro-image-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K: 5 credits, 2K: 7 credits
        if model_id == "flux-2/pro-image-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/pro-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/pro-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate input_urls (required, array of URLs, 1-8 images)
            # Note: image_input is converted to input_urls earlier in the code
            if 'input_urls' not in api_params or not api_params.get('input_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter input_urls for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            # Ensure input_urls is a list
            input_urls = api_params['input_urls']
            if not isinstance(input_urls, list):
                # Convert single URL to list
                if isinstance(input_urls, str):
                    input_urls = [input_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(input_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid input_urls type for flux-2/pro-image-to-image: {type(input_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty and has 1-8 items
            if len(input_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º. –¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty input_urls array for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            if len(input_urls) > 8:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(input_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many input_urls for flux-2/pro-image-to-image: {len(input_urls)}")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(input_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ input_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid input_urls[{i}] for flux-2/pro-image-to-image: {url}")
                    return ConversationHandler.END
            
            api_params['input_urls'] = [url.strip() for url in input_urls]
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for flux-2/pro-image-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 5 credits, 2K = 7 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for flux-2/pro-image-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/pro-text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter (same as image-to-image)
        # 1K: 5 credits, 2K: 7 credits
        if model_id == "flux-2/pro-text-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/pro-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/pro-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/pro-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            # Note: "auto" is available but requires input image (not applicable for text-to-image)
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for flux-2/pro-text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 5 credits, 2K = 7 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for flux-2/pro-text-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/flex-image-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K: 14 credits, 2K: 24 credits (higher than pro version)
        if model_id == "flux-2/flex-image-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/flex-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/flex-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate input_urls (required, array of URLs, 1-8 images)
            # Note: image_input is converted to input_urls earlier in the code
            if 'input_urls' not in api_params or not api_params.get('input_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter input_urls for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            # Ensure input_urls is a list
            input_urls = api_params['input_urls']
            if not isinstance(input_urls, list):
                # Convert single URL to list
                if isinstance(input_urls, str):
                    input_urls = [input_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(input_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid input_urls type for flux-2/flex-image-to-image: {type(input_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty and has 1-8 items
            if len(input_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º. –¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty input_urls array for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            if len(input_urls) > 8:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(input_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many input_urls for flux-2/flex-image-to-image: {len(input_urls)}")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(input_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ input_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid input_urls[{i}] for flux-2/flex-image-to-image: {url}")
                    return ConversationHandler.END
            
            api_params['input_urls'] = [url.strip() for url in input_urls]
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for flux-2/flex-image-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 14 credits, 2K = 24 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for flux-2/flex-image-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/flex-text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter (same as flex-image-to-image)
        # 1K: 14 credits, 2K: 24 credits (higher than pro version)
        if model_id == "flux-2/flex-text-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/flex-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/flex-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/flex-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            # Note: "auto" is available but requires input image (not applicable for text-to-image)
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for flux-2/flex-text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 14 credits, 2K = 24 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for flux-2/flex-text-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For nano-banana-pro, validate and normalize parameters
        # CRITICAL: KIE API expects "input.image_input" as array of URLs (up to 8 images)
        # Documentation: https://docs.kie.ai/market/google/pro-image-to-image
        # API expects: {"model": "nano-banana-pro", "input": {"prompt": "...", "image_input": ["url1", ...], ...}}
        # NOTE: image_input is kept as-is (array), NOT converted to another parameter name
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K/2K: 18 credits, 4K: 24 credits
        if model_id == "nano-banana-pro":
            # Validate prompt (required, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ nano-banana-pro."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for nano-banana-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for nano-banana-pro: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (optional, array of URLs, up to 8 images)
            # Note: image_input is kept as-is (not converted to another parameter name)
            if 'image_input' in api_params and api_params.get('image_input'):
                image_input = api_params['image_input']
                
                # Ensure image_input is a list
                if not isinstance(image_input, list):
                    # Convert single URL to list
                    if isinstance(image_input, str):
                        image_input = [image_input]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_input –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_input).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_input type for nano-banana-pro: {type(image_input)}")
                        return ConversationHandler.END
                
                # Validate that list has max 8 items
                if len(image_input) > 8:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_input —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_input)}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Too many image_input for nano-banana-pro: {len(image_input)}")
                    return ConversationHandler.END
                
                # Validate each URL is a string
                for i, url in enumerate(image_input):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_input –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_input[{i}] for nano-banana-pro: {url}")
                        return ConversationHandler.END
                
                api_params['image_input'] = [url.strip() for url in image_input]
            
            # Validate aspect_ratio (optional, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9", "21:9", "auto"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for nano-banana-pro: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            
            # Validate resolution (optional, enum values: "1K", "2K", or "4K")
            # NOTE: This parameter affects price - 1K/2K = 18 credits, 4K = 24 credits
            valid_resolutions = ["1K", "2K", "4K"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for nano-banana-pro: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "1K"
            
            # Validate output_format (optional, enum values: "png" or "jpg")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_output_formats = ["png", "jpg"]
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                # Normalize: PNG/JPG -> png/jpg
                if output_format not in valid_output_formats:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ output_format.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_output_formats)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('output_format')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for nano-banana-pro: {api_params.get('output_format')}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Use default if not set
                api_params['output_format'] = "png"
        
        # For bytedance/v1-pro-fast-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters
        # 480p, 5s: 10 credits (estimated), 480p, 10s: 20 credits (estimated)
        # 720p, 5s: 16 credits, 720p, 10s: 36 credits
        # 1080p, 5s: 36 credits, 1080p, 10s: 72 credits
        if model_id == "bytedance/v1-pro-fast-image-to-video":
            # Validate prompt (required, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-fast-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for bytedance/v1-pro-fast-image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-fast-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-pro-fast-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for bytedance/v1-pro-fast-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            # Note: API form shows "5s" and "10s", but enum uses "5" and "10"
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove 's' if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for bytedance/v1-pro-fast-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
        
        # For bytedance/v1-lite-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-lite-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-lite-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-lite-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum: "16:9", default: "16:9")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in ["16:9"]:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>16:9</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for bytedance/v1-lite-text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "16:9"
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for bytedance/v1-lite-text-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "480p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for bytedance/v1-lite-text-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid camera_fixed for bytedance/v1-lite-text-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-lite-text-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/v1-lite-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for bytedance/v1-lite-text-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/v1-lite-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-lite-text-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-lite-text-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For bytedance/v1-pro-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-pro-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-pro-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum: "16:9", default: "16:9")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in ["16:9"]:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>16:9</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for bytedance/v1-pro-text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "16:9"
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for bytedance/v1-pro-text-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for bytedance/v1-pro-text-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid camera_fixed for bytedance/v1-pro-text-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-pro-text-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/v1-pro-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for bytedance/v1-pro-text-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/v1-pro-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-pro-text-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-pro-text-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For bytedance/v1-lite-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-lite-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-lite-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for bytedance/v1-lite-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "480p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for bytedance/v1-lite-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid camera_fixed for bytedance/v1-lite-image-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-lite-image-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/v1-lite-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for bytedance/v1-lite-image-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/v1-lite-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-lite-image-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-lite-image-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid end_image_url format for bytedance/v1-lite-image-to-video: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
        
        # For bytedance/v1-pro-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-pro-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-pro-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for bytedance/v1-pro-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for bytedance/v1-pro-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid camera_fixed for bytedance/v1-pro-image-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-pro-image-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/v1-pro-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for bytedance/v1-pro-image-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/v1-pro-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-pro-image-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-pro-image-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For kling/v2-1-master-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "kling/v2-1-master-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-master-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-master-image-to-video.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-1-master-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter may affect price
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "seconds" or "s" suffix if present
                if duration.lower().endswith('seconds'):
                    duration = duration[:-7].strip()
                elif duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5 seconds</b> –∏–ª–∏ <b>10 seconds</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling/v2-1-master-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale type for kling/v2-1-master-image-to-video: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale value for kling/v2-1-master-image-to-video: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid cfg_scale for kling/v2-1-master-image-to-video: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For grok-imagine/image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/image-to-video":
            # Validate that either image_urls OR task_id is provided (but not both)
            has_image_urls = 'image_urls' in api_params and api_params.get('image_urls')
            has_task_id = 'task_id' in api_params and api_params.get('task_id')
            
            if not has_image_urls and not has_task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –ª–∏–±–æ <b>image_urls</b> (–≤–Ω–µ—à–Ω–∏–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è), "
                    "–ª–∏–±–æ <b>task_id</b> (ID –∑–∞–¥–∞—á–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok).\n\n"
                    "–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter: need either image_urls or task_id for grok-imagine/image-to-video")
                return ConversationHandler.END
            
            if has_image_urls and has_task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <b>image_urls</b> –∏ <b>task_id</b> –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤:\n"
                    "‚Ä¢ <b>image_urls</b> - –≤–Ω–µ—à–Ω–∏–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n"
                    "‚Ä¢ <b>task_id</b> + <b>index</b> - –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Cannot use both image_urls and task_id for grok-imagine/image-to-video")
                return ConversationHandler.END
            
            # Validate image_urls if provided (optional, array, max 1 image)
            if has_image_urls:
                # Remove task_id and index if image_urls is used
                if 'task_id' in api_params:
                    api_params.pop('task_id')
                if 'index' in api_params:
                    api_params.pop('index')
                
                image_urls = api_params['image_urls']
                
                # Ensure image_urls is a list
                if not isinstance(image_urls, list):
                    # Convert single URL to list
                    if isinstance(image_urls, str):
                        image_urls = [image_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_urls type for grok-imagine/image-to-video: {type(image_urls)}")
                        return ConversationHandler.END
                
                # Validate that list has max 1 item
                if len(image_urls) > 1:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Too many image_urls for grok-imagine/image-to-video: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate URL is a string
                if len(image_urls) > 0:
                    url = image_urls[0]
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–≠–ª–µ–º–µ–Ω—Ç –≤ image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π (URL)."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_urls[0] for grok-imagine/image-to-video: {url}")
                        return ConversationHandler.END
                    api_params['image_urls'] = [url.strip()]
            
            # Validate task_id if provided (optional, string)
            if has_task_id:
                # Remove image_urls if task_id is used
                if 'image_urls' in api_params:
                    api_params.pop('image_urls')
                
                task_id = str(api_params['task_id']).strip()
                if not task_id:
                    error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty task_id for grok-imagine/image-to-video")
                    return ConversationHandler.END
                api_params['task_id'] = task_id
                
                # Validate index if task_id is provided (optional, 0-5, 0-based)
                if 'index' in api_params and api_params.get('index') is not None:
                    try:
                        index = int(api_params['index'])
                        if index < 0 or index > 5:
                            error_msg = (
                                f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                                f"–ü–∞—Ä–∞–º–µ—Ç—Ä index –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 0 –¥–æ 5 (0-based).\n"
                                f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {index}"
                            )
                            await send_or_edit_message(error_msg)
                            logger.error(f"Invalid index for grok-imagine/image-to-video: {index}")
                            return ConversationHandler.END
                        api_params['index'] = index
                    except (ValueError, TypeError):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä index –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0 –¥–æ 5.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('index')}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid index type for grok-imagine/image-to-video: {api_params.get('index')}")
                        return ConversationHandler.END
                else:
                    # Use default if not set
                    api_params['index'] = 0
            
            # Validate prompt (optional, string)
            if 'prompt' in api_params and api_params.get('prompt'):
                prompt = str(api_params['prompt']).strip()
                api_params['prompt'] = prompt
            
            # Validate mode (optional, enum values: "fun", "normal", "spicy")
            # NOTE: Spicy mode is not supported when using external image_urls
            valid_modes = ["fun", "normal", "spicy"]
            if 'mode' in api_params and api_params.get('mode'):
                mode = str(api_params['mode']).strip().lower()
                if mode not in valid_modes:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ mode.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_modes)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('mode')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid mode for grok-imagine/image-to-video: {api_params.get('mode')}")
                    return ConversationHandler.END
                
                # Check if spicy mode is used with external image_urls (not allowed)
                if mode == "spicy" and has_image_urls:
                    logger.warning(f"Spicy mode used with image_urls for grok-imagine/image-to-video, switching to normal")
                    # Automatically switch to normal mode (spicy not supported with external images)
                    mode = "normal"
                
                api_params['mode'] = mode
            else:
                # Use default if not set
                api_params['mode'] = "normal"
        
        # For grok-imagine/text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for grok-imagine/text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for grok-imagine/text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum values: "2:3", "3:2", "1:1")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["2:3", "3:2", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for grok-imagine/text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate mode (optional, enum values: "fun", "normal", "spicy")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_modes = ["fun", "normal", "spicy"]
            if 'mode' in api_params and api_params.get('mode'):
                mode = str(api_params['mode']).strip().lower()
                if mode not in valid_modes:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ mode.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_modes)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('mode')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid mode for grok-imagine/text-to-video: {api_params.get('mode')}")
                    return ConversationHandler.END
                api_params['mode'] = mode
            else:
                # Use default if not set
                api_params['mode'] = "normal"
        
        # For grok-imagine/text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for grok-imagine/text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for grok-imagine/text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum values: "2:3", "3:2", "1:1")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["2:3", "3:2", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for grok-imagine/text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
        
        # For grok-imagine/upscale, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/upscale":
            # Validate task_id (required, string)
            # Note: task_id must be from a Kie AI-generated task (supports only Kie AI-generated taskid)
            if 'task_id' not in api_params or not api_params.get('task_id'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/upscale.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ taskid –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok –Ω–∞ Kie AI."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter task_id for grok-imagine/upscale")
                return ConversationHandler.END
            
            task_id = str(api_params['task_id']).strip()
            if not task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ taskid –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok –Ω–∞ Kie AI."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty task_id for grok-imagine/upscale")
                return ConversationHandler.END
            
            # Basic validation: task_id should not be empty and should look like a valid task ID
            # Note: Full validation would require checking if task_id exists in Kie AI system
            # For now, we just validate that it's a non-empty string
            api_params['task_id'] = task_id
        
        # For hailuo/2-3-image-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 768P ~5 credits/sec, 1080P ~9.5 credits/sec
        # IMPORTANT: 10-second videos are NOT supported for 1080P resolution
        if model_id == "hailuo/2-3-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-pro")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-pro")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/2-3-image-to-video-pro: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for hailuo/2-3-image-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "768P" or "1080P")
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["768P", "1080P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>768P</b> –∏–ª–∏ <b>1080P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for hailuo/2-3-image-to-video-pro: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate mutual exclusivity: 10-second videos are not supported for 1080p resolution
            duration = api_params.get('duration', '6')
            resolution = api_params.get('resolution', '768P')
            if duration == "10" and resolution == "1080P":
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "10-—Å–µ–∫—É–Ω–¥–Ω—ã–µ –≤–∏–¥–µ–æ <b>–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è</b> –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è <b>1080P</b>.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑:\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>768P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 10 —Å–µ–∫—É–Ω–¥\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>1080P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 6 —Å–µ–∫—É–Ω–¥"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid combination for hailuo/2-3-image-to-video-pro: duration=10, resolution=1080P")
                return ConversationHandler.END
        
        # For hailuo/2-3-image-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 768P ~5 credits/sec, 1080P ~7 credits/sec (standard version is cheaper than Pro)
        # IMPORTANT: 10-second videos are NOT supported for 1080P resolution
        if model_id == "hailuo/2-3-image-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-standard")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-standard")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/2-3-image-to-video-standard: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for hailuo/2-3-image-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "768P" or "1080P")
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["768P", "1080P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>768P</b> –∏–ª–∏ <b>1080P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for hailuo/2-3-image-to-video-standard: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate mutual exclusivity: 10-second videos are not supported for 1080p resolution
            duration = api_params.get('duration', '6')
            resolution = api_params.get('resolution', '768P')
            if duration == "10" and resolution == "1080P":
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "10-—Å–µ–∫—É–Ω–¥–Ω—ã–µ –≤–∏–¥–µ–æ <b>–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è</b> –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è <b>1080P</b>.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑:\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>768P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 10 —Å–µ–∫—É–Ω–¥\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>1080P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 6 —Å–µ–∫—É–Ω–¥"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid combination for hailuo/2-3-image-to-video-standard: duration=10, resolution=1080P")
                return ConversationHandler.END
        
        # For sora-2-pro-storyboard, validate and normalize parameters
        # NOTE: Price depends on n_frames (see calculate_price_rub())
        # Price calculation: 10s = 150 credits, 15-25s = 270 credits
        if model_id == "sora-2-pro-storyboard":
            # Validate shots (required, array of objects with Scene and duration)
            if 'shots' not in api_params or not api_params.get('shots'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-storyboard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –º–∞—Å—Å–∏–≤ —Å—Ü–µ–Ω —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∫–∞–∂–¥–æ–π —Å—Ü–µ–Ω—ã."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter shots for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            shots = api_params['shots']
            if not isinstance(shots, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º –æ–±—ä–µ–∫—Ç–æ–≤.\n\n"
                    "–ö–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å:\n"
                    "‚Ä¢ <b>Scene</b> (—Å—Ç—Ä–æ–∫–∞) - –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã\n"
                    "‚Ä¢ <b>duration</b> (—á–∏—Å–ª–æ) - –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid shots type for sora-2-pro-storyboard: {type(shots)}")
                return ConversationHandler.END
            
            if len(shots) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É —Å—Ü–µ–Ω—É —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty shots array for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            # Validate each shot object
            total_duration = 0.0
            validated_shots = []
            for i, shot in enumerate(shots, 1):
                if not isinstance(shot, dict):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º (—Å–ª–æ–≤–∞—Ä–µ–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(shot).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid shot #{i} type for sora-2-pro-storyboard: {type(shot)}")
                    return ConversationHandler.END
                
                # Validate Scene (required, string)
                if 'Scene' not in shot or not shot.get('Scene'):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>Scene</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing Scene in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                scene_text = str(shot['Scene']).strip()
                if not scene_text:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>Scene</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty Scene in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                # Validate duration (required, number)
                if 'duration' not in shot:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ü–µ–Ω—ã –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (—á–∏—Å–ª–æ)."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing duration in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                try:
                    duration = float(shot['duration'])
                    if duration <= 0:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {duration}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid duration in shot #{i} for sora-2-pro-storyboard: {duration}")
                        return ConversationHandler.END
                except (ValueError, TypeError):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {shot['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration type in shot #{i} for sora-2-pro-storyboard: {type(shot['duration'])}")
                    return ConversationHandler.END
                
                validated_shots.append({
                    "Scene": scene_text,
                    "duration": duration
                })
                total_duration += duration
            
            api_params['shots'] = validated_shots
            
            # Validate n_frames (required, string: "10", "15", or "25")
            if 'n_frames' not in api_params or not api_params.get('n_frames'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-storyboard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –æ–±—â—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–µ–æ: <b>10</b>, <b>15</b> –∏–ª–∏ <b>25</b> —Å–µ–∫—É–Ω–¥."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter n_frames for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            n_frames = str(api_params['n_frames']).strip()
            # Normalize by removing "s" suffix if present
            if n_frames.lower().endswith('s'):
                n_frames = n_frames[:-1].strip()
            
            if n_frames not in ["10", "15", "25"]:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b>, <b>15</b> –∏–ª–∏ <b>25</b> —Å–µ–∫—É–Ω–¥.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid n_frames for sora-2-pro-storyboard: {api_params['n_frames']}")
                return ConversationHandler.END
            api_params['n_frames'] = n_frames
            
            # Validate that total duration of shots matches n_frames (with small tolerance for floating point)
            n_frames_float = float(n_frames)
            if abs(total_duration - n_frames_float) > 0.1:  # Allow 0.1 second tolerance
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–°—É–º–º–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –≤—Å–µ—Ö —Å—Ü–µ–Ω (<b>{total_duration:.1f}—Å</b>) –¥–æ–ª–∂–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å "
                    f"–æ–±—â–µ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–∏–¥–µ–æ <b>n_frames</b> (<b>{n_frames}—Å</b>).\n\n"
                    "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤—Å–µ—Ö —Å—Ü–µ–Ω –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ <b>shots</b>."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Total shots duration ({total_duration}) doesn't match n_frames ({n_frames}) for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            # Validate image_urls (optional, array of URLs, max 1 image)
            if 'image_urls' in api_params and api_params.get('image_urls'):
                image_urls = api_params['image_urls']
                # Convert single URL string to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                
                if not isinstance(image_urls, list):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_urls type for sora-2-pro-storyboard: {type(image_urls)}")
                    return ConversationHandler.END
                
                if len(image_urls) > 1:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Too many image_urls for sora-2-pro-storyboard: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate each URL
                validated_image_urls = []
                for i, url in enumerate(image_urls, 1):
                    if not isinstance(url, str):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_url #{i} type for sora-2-pro-storyboard: {type(url)}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not url:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                            f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Empty image_url #{i} for sora-2-pro-storyboard")
                        return ConversationHandler.END
                    
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_url #{i} format for sora-2-pro-storyboard: {url}")
                        return ConversationHandler.END
                    
                    validated_image_urls.append(url)
                
                api_params['image_urls'] = validated_image_urls
            else:
                # Remove image_urls if it's empty or None
                if 'image_urls' in api_params:
                    del api_params['image_urls']
            
            # Validate aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-storyboard: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
        
        # For elevenlabs/speech-to-text, validate and normalize parameters
        # NOTE: Price calculation - 3.5 credits per minute (calculated in calculate_price_rub)
        if model_id == "elevenlabs/speech-to-text":
            # Validate audio_url (required, URL)
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ elevenlabs/speech-to-text."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for elevenlabs/speech-to-text")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url.startswith(('http://', 'https://')):
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {audio_url[:100]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for elevenlabs/speech-to-text: {audio_url[:100]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate language_code (optional, string, default "" according to API docs)
            # Common language codes: eng, ru, de, fr, es, it, zh, ja, ko, etc.
            if 'language_code' in api_params and api_params.get('language_code'):
                lang_code = str(api_params['language_code']).strip()
                if lang_code:
                    # Try to convert common language names to codes
                    lang_lower = lang_code.lower()
                    lang_map = {
                        '—Ä—É—Å—Å–∫–∏–π': 'ru',
                        'russian': 'ru',
                        '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π': 'eng',
                        'english': 'eng',
                        'en': 'eng',
                        '–Ω–µ–º–µ—Ü–∫–∏–π': 'de',
                        'german': 'de',
                        '—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π': 'fr',
                        'french': 'fr',
                        '–∏—Å–ø–∞–Ω—Å–∫–∏–π': 'es',
                        'spanish': 'es',
                        '–∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π': 'it',
                        'italian': 'it',
                        '–∫–∏—Ç–∞–π—Å–∫–∏–π': 'zh',
                        'chinese': 'zh',
                        '—è–ø–æ–Ω—Å–∫–∏–π': 'ja',
                        'japanese': 'ja',
                        '–∫–æ—Ä–µ–π—Å–∫–∏–π': 'ko',
                        'korean': 'ko'
                    }
                    if lang_lower in lang_map:
                        api_params['language_code'] = lang_map[lang_lower]
                    # If it's already a code (2-5 letters), keep it as is (normalize to lowercase)
                    elif len(lang_code) <= 5 and lang_code.replace('-', '').replace('_', '').isalpha():
                        api_params['language_code'] = lang_code.lower()
                    else:
                        # Invalid format, remove parameter (use API default "")
                        api_params.pop('language_code', None)
                else:
                    # Empty language_code - remove parameter (use API default "")
                    api_params.pop('language_code', None)
            else:
                # If not set, don't send parameter (API will use default "")
                api_params.pop('language_code', None)
            
            # Validate tag_audio_events (optional, boolean)
            if 'tag_audio_events' in api_params and api_params.get('tag_audio_events') is not None:
                tag_audio_events = api_params['tag_audio_events']
                # Normalize boolean values
                if isinstance(tag_audio_events, str):
                    tag_audio_events_lower = tag_audio_events.lower().strip()
                    if tag_audio_events_lower in ['true', '1', 'yes', 'on']:
                        api_params['tag_audio_events'] = True
                    elif tag_audio_events_lower in ['false', '0', 'no', 'off']:
                        api_params['tag_audio_events'] = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {tag_audio_events}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid tag_audio_events for elevenlabs/speech-to-text: {tag_audio_events}")
                        return ConversationHandler.END
                elif isinstance(tag_audio_events, bool):
                    api_params['tag_audio_events'] = tag_audio_events
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(tag_audio_events).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid tag_audio_events type for elevenlabs/speech-to-text: {type(tag_audio_events)}")
                    return ConversationHandler.END
                
                # Remove if False (default value)
                if api_params.get('tag_audio_events') is False:
                    api_params.pop('tag_audio_events')
            
            # Validate diarize (optional, boolean)
            if 'diarize' in api_params and api_params.get('diarize') is not None:
                diarize = api_params['diarize']
                # Normalize boolean values
                if isinstance(diarize, str):
                    diarize_lower = diarize.lower().strip()
                    if diarize_lower in ['true', '1', 'yes', 'on']:
                        api_params['diarize'] = True
                    elif diarize_lower in ['false', '0', 'no', 'off']:
                        api_params['diarize'] = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {diarize}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid diarize for elevenlabs/speech-to-text: {diarize}")
                        return ConversationHandler.END
                elif isinstance(diarize, bool):
                    api_params['diarize'] = diarize
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(diarize).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid diarize type for elevenlabs/speech-to-text: {type(diarize)}")
                    return ConversationHandler.END
                
                # Remove if False (default value)
                if api_params.get('diarize') is False:
                    api_params.pop('diarize')
        
        # Log API params for debugging (only for admin)
        if is_admin_user:
            logger.info(f"Creating task for model {model_id} with params: {json.dumps(api_params, indent=2, ensure_ascii=False)}")
        
        # For elevenlabs/speech-to-text, verify audio_url is accessible
        if model_id == "elevenlabs/speech-to-text" and 'audio_url' in api_params:
            audio_url = api_params['audio_url']
            try:
                # Quick check if URL is accessible
                session = await get_http_client()
                async with session.head(audio_url) as resp:
                        if resp.status != 200:
                            logger.warning(f"Audio URL returned status {resp.status}: {audio_url}")
                            if is_admin_user:
                                await query.edit_message_text(
                                    f"‚ö†Ô∏è <b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ</b>\n\n"
                                    f"URL –∞—É–¥–∏–æ-—Ñ–∞–π–ª–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å {resp.status}.\n"
                                    f"URL: {audio_url[:100]}...\n\n"
                                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –µ—â–µ —Ä–∞–∑.",
                                    parse_mode='HTML'
                                )
                                return ConversationHandler.END
            except Exception as e:
                logger.warning(f"Could not verify audio URL accessibility: {e}")
        
        # For sora-watermark-remover, validate video_url parameter
        # NOTE: Price calculation - Fixed at 10 credits per use (doesn't depend on parameters)
        if model_id == "sora-watermark-remover":
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-watermark-remover."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for sora-watermark-remover")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            
            # Validate max length (500 characters)
            if len(video_url) > 500:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(video_url)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"video_url too long for sora-watermark-remover: {len(video_url)} characters")
                return ConversationHandler.END
            
            # Validate URL format (should contain sora.chatgpt.com)
            # Accept URLs like: https://sora.chatgpt.com/p/s_...
            if 'sora.chatgpt.com' not in video_url:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –≤–∏–¥–µ–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç OpenAI Sora 2 (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å sora.chatgpt.com).\n\n"
                    f"–ü—Ä–∏–º–µ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ URL: https://sora.chatgpt.com/p/s_...\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π URL: {video_url[:100]}{'...' if len(video_url) > 100 else ''}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for sora-watermark-remover: {video_url[:100]}")
                return ConversationHandler.END
            
            # Additional validation: check if URL looks like a valid Sora URL
            # Should start with http:// or https://
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π URL: {video_url[:100]}{'...' if len(video_url) > 100 else ''}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url protocol for sora-watermark-remover: {video_url[:100]}")
                return ConversationHandler.END
            
            # Update api_params with validated video_url
            api_params['video_url'] = video_url
            
            # Optional: Quick check if URL is accessible (similar to audio_url check)
        
        # For sora-2-pro-text-to-video, validate and normalize parameters
        # NOTE: Price depends on size and n_frames (see calculate_price_rub())
        # Price calculation:
        # Standard: 10s = 150 credits, 15s = 270 credits
        # High: 10s = 330 credits, 15s = 630 credits
        if model_id == "sora-2-pro-text-to-video":
            # Validate prompt (required, string, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-pro-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-pro-text-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for sora-2-pro-text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid n_frames for sora-2-pro-text-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize size (optional, enum: "standard" or "high")
            # NOTE: Size affects price significantly (Standard vs High)
            if 'size' in api_params and api_params.get('size'):
                size = str(api_params['size']).strip().lower()
                
                if size not in ["standard", "high"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>standard</b> –∏–ª–∏ <b>high</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid size for sora-2-pro-text-to-video: {api_params['size']}")
                    return ConversationHandler.END
                api_params['size'] = size
            else:
                # Default size if not provided
                api_params['size'] = "standard"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid remove_watermark for sora-2-pro-text-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid remove_watermark type for sora-2-pro-text-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-pro-image-to-video, validate and normalize parameters
        # NOTE: Price depends on size and n_frames (see calculate_price_rub())
        # Price calculation:
        # Standard: 10s = 150 credits, 15s = 270 credits
        # High: 10s = 330 credits, 15s = 630 credits
        if model_id == "sora-2-pro-image-to-video":
            # Validate prompt (required, string, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for sora-2-pro-image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 1 image)
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_urls if it's a single URL string or list
                    if isinstance(image_input, str):
                        api_params['image_urls'] = [image_input.strip()]
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        api_params['image_urls'] = [str(url).strip() for url in image_input[:1]]  # Take only first
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_urls for sora-2-pro-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_urls for sora-2-pro-image-to-video")
                    return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string to list
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            
            if not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for sora-2-pro-image-to-video: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            if len(image_urls) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for sora-2-pro-image-to-video: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL
            validated_image_urls = []
            for i, url in enumerate(image_urls, 1):
                if not isinstance(url, str):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_url #{i} type for sora-2-pro-image-to-video: {type(url)}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not url:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty image_url #{i} for sora-2-pro-image-to-video")
                    return ConversationHandler.END
                
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_url #{i} format for sora-2-pro-image-to-video: {url}")
                    return ConversationHandler.END
                
                validated_image_urls.append(url)
            
            api_params['image_urls'] = validated_image_urls
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-image-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid n_frames for sora-2-pro-image-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize size (optional, enum: "standard" or "high")
            # NOTE: Size affects price significantly (Standard vs High)
            if 'size' in api_params and api_params.get('size'):
                size = str(api_params['size']).strip().lower()
                
                if size not in ["standard", "high"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>standard</b> –∏–ª–∏ <b>high</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid size for sora-2-pro-image-to-video: {api_params['size']}")
                    return ConversationHandler.END
                api_params['size'] = size
            else:
                # Default size if not provided
                api_params['size'] = "standard"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid remove_watermark for sora-2-pro-image-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid remove_watermark type for sora-2-pro-image-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 30 credits per 10-second video (see calculate_price_rub())
        # Price: 30 credits (fixed, doesn't depend on parameters)
        if model_id == "sora-2-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for sora-2-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid n_frames for sora-2-text-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid remove_watermark for sora-2-text-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid remove_watermark type for sora-2-text-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 30 credits per 10-second video (see calculate_price_rub())
        # Price: 30 credits (fixed, doesn't depend on parameters)
        if model_id == "sora-2-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 1 image)
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_urls if it's a single URL string or list
                    if isinstance(image_input, str):
                        api_params['image_urls'] = [image_input.strip()]
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        api_params['image_urls'] = [str(url).strip() for url in image_input[:1]]  # Take only first
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_urls for sora-2-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_urls for sora-2-image-to-video")
                    return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string to list
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            
            if not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for sora-2-image-to-video: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for sora-2-image-to-video")
                return ConversationHandler.END
            
            if len(image_urls) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for sora-2-image-to-video: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL
            validated_image_urls = []
            for i, url in enumerate(image_urls, 1):
                if not isinstance(url, str):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_url #{i} type for sora-2-image-to-video: {type(url)}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not url:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty image_url #{i} for sora-2-image-to-video")
                    return ConversationHandler.END
                
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_url #{i} format for sora-2-image-to-video: {url}")
                    return ConversationHandler.END
                
                validated_image_urls.append(url)
            
            api_params['image_urls'] = validated_image_urls
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for sora-2-image-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid n_frames for sora-2-image-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid remove_watermark for sora-2-image-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid remove_watermark type for sora-2-image-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For topaz/image-upscale, validate and normalize parameters
        # NOTE: Price depends on upscale_factor (see calculate_price_rub())
        # Price calculation: 1x = 10 credits, 2x/4x = 20 credits, 8x = 40 credits
        if model_id == "topaz/image-upscale":
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_url for topaz/image-upscale")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_url for topaz/image-upscale")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for topaz/image-upscale")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for topaz/image-upscale: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize upscale_factor (required, enum: "1", "2", "4", or "8")
            # Normalize by removing "x" suffix if present
            if 'upscale_factor' not in api_params or not api_params.get('upscale_factor'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∞–ø—Å–∫–µ–π–ª–∞: <b>1x</b>, <b>2x</b>, <b>4x</b> –∏–ª–∏ <b>8x</b>."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter upscale_factor for topaz/image-upscale")
                return ConversationHandler.END
            
            upscale_factor = str(api_params['upscale_factor']).strip().lower()
            # Remove "x" suffix if present
            if upscale_factor.endswith('x'):
                upscale_factor = upscale_factor[:-1].strip()
            
            if upscale_factor not in ["1", "2", "4", "8"]:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1x</b>, <b>2x</b>, <b>4x</b> –∏–ª–∏ <b>8x</b>.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['upscale_factor']}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid upscale_factor for topaz/image-upscale: {api_params['upscale_factor']}")
                return ConversationHandler.END
            api_params['upscale_factor'] = upscale_factor
        
        # For kling/v2-5-turbo-text-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 5s = 42 credits, 10s = 84 credits
        if model_id == "kling/v2-5-turbo-text-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-text-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-5-turbo-text-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-5-turbo-text-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling/v2-5-turbo-text-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize aspect_ratio (optional, enum: "16:9", "9:16", or "1:1")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                
                if aspect_ratio not in ["16:9", "9:16", "1:1"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>16:9</b>, <b>9:16</b> –∏–ª–∏ <b>1:1</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for kling/v2-5-turbo-text-to-video-pro: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale type for kling/v2-5-turbo-text-to-video-pro: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale value for kling/v2-5-turbo-text-to-video-pro: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid cfg_scale for kling/v2-5-turbo-text-to-video-pro: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For kling/v2-5-turbo-image-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 5s = 42 credits, 10s = 84 credits
        if model_id == "kling/v2-5-turbo-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_url for kling/v2-5-turbo-image-to-video-pro")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_url for kling/v2-5-turbo-image-to-video-pro")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-5-turbo-image-to-video-pro: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate tail_image_url (optional, single URL string)
            if 'tail_image_url' in api_params and api_params.get('tail_image_url'):
                tail_image_url = str(api_params['tail_image_url']).strip()
                if tail_image_url:
                    # Basic URL format validation
                    if not (tail_image_url.startswith('http://') or tail_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tail_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {tail_image_url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid tail_image_url format for kling/v2-5-turbo-image-to-video-pro: {tail_image_url}")
                        return ConversationHandler.END
                    api_params['tail_image_url'] = tail_image_url
                else:
                    # Remove tail_image_url if it's empty
                    del api_params['tail_image_url']
            else:
                # Remove tail_image_url if it's empty or None
                if 'tail_image_url' in api_params:
                    del api_params['tail_image_url']
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling/v2-5-turbo-image-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale type for kling/v2-5-turbo-image-to-video-pro: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale value for kling/v2-5-turbo-image-to-video-pro: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid cfg_scale for kling/v2-5-turbo-image-to-video-pro: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For wan/2-5-image-to-video, validate and normalize parameters
        # NOTE: Price depends on duration and resolution (see calculate_price_rub())
        # Price calculation: 720p = 12 credits/sec, 1080p = 20 credits/sec
        if model_id == "wan/2-5-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-5-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-5-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Missing required parameter image_url for wan/2-5-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Missing required parameter image_url for wan/2-5-image-to-video")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-5-image-to-video")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-5-image-to-video: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for wan/2-5-image-to-video: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize resolution (optional, enum: "720p" or "1080p")
            # NOTE: Resolution affects price significantly (720p vs 1080p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["720p", "1080p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-5-image-to-video: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize enable_prompt_expansion (optional, boolean)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-5-image-to-video: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-5-image-to-video: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Remove enable_prompt_expansion if it's empty or None
                if 'enable_prompt_expansion' in api_params:
                    del api_params['enable_prompt_expansion']
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for wan/2-5-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for wan/2-5-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For wan/2-5-text-to-video, validate and normalize parameters
        # NOTE: Price depends on duration and resolution (see calculate_price_rub())
        # Price calculation: 720p = 12 credits/sec, 1080p = 20 credits/sec
        if model_id == "wan/2-5-text-to-video":
            # Validate prompt (required, string, max 800 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤)."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-5-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤)."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-5-text-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 800:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for wan/2-5-text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for wan/2-5-text-to-video: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize aspect_ratio (optional, enum: "16:9", "9:16", or "1:1")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                
                if aspect_ratio not in ["16:9", "9:16", "1:1"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>16:9</b>, <b>9:16</b> –∏–ª–∏ <b>1:1</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for wan/2-5-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize resolution (optional, enum: "720p" or "1080p")
            # NOTE: Resolution affects price significantly (720p vs 1080p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["720p", "1080p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-5-text-to-video: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate negative_prompt (optional, string, max 500 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>negative_prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for wan/2-5-text-to-video: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize enable_prompt_expansion (optional, boolean)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-5-text-to-video: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-5-text-to-video: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Remove enable_prompt_expansion if it's empty or None
                if 'enable_prompt_expansion' in api_params:
                    del api_params['enable_prompt_expansion']
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for wan/2-5-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for wan/2-5-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For wan/2-2-animate-move, validate and normalize parameters
        # NOTE: Price depends on resolution (see calculate_price_rub())
        # Price calculation: 480p = 6 credits/sec, 580p = 9.5 credits/sec, 720p = 12.5 credits/sec
        # Duration is determined by input video length (up to 30 seconds)
        if model_id == "wan/2-2-animate-move":
            # Validate video_url (required, URL)
            # Note: video_url should already be converted from video_input in the conversion block above
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-move.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for wan/2-2-animate-move: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-move.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-2-animate-move: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p")
            # NOTE: Resolution affects price significantly (480p vs 580p vs 720p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["480p", "580p", "720p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>580p</b> –∏–ª–∏ <b>720p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-2-animate-move: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "480p"
        
        # For hailuo/02-text-to-video-pro, validate and normalize parameters
        # NOTE: Price is fixed at 57 credits for 6-second 1080p video (see calculate_price_rub())
        if model_id == "hailuo/02-text-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-text-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-text-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-text-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-text-to-video-pro: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-text-to-video-pro: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-image-to-video-pro, validate and normalize parameters
        # NOTE: Price is fixed at 57 credits for 6-second 1080p video (see calculate_price_rub())
        if model_id == "hailuo/02-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/02-image-to-video-pro: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid end_image_url format for hailuo/02-image-to-video-pro: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-image-to-video-pro: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-image-to-video-pro: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-image-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 512P = 2 credits/sec, 768P = 5 credits/sec
        if model_id == "hailuo/02-image-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/02-image-to-video-standard: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid end_image_url format for hailuo/02-image-to-video-standard: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for hailuo/02-image-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "512P" or "768P")
            # NOTE: Resolution affects price significantly (512P vs 768P)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix (uppercase)
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["512P", "768P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>512P</b> –∏–ª–∏ <b>768P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for hailuo/02-image-to-video-standard: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-image-to-video-standard: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-image-to-video-standard: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-text-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 768P = 5 credits/sec (fixed resolution)
        if model_id == "hailuo/02-text-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-text-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-text-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-text-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for hailuo/02-text-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-text-to-video-standard: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-text-to-video-standard: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For topaz/video-upscale, validate and normalize parameters
        # NOTE: Price is 12 credits per second (see calculate_price_rub())
        # Duration is determined by input video length
        if model_id == "topaz/video-upscale":
            # Validate video_url (required, URL)
            # Note: video_url should already be converted from video_input in the conversion block above
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/video-upscale.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for topaz/video-upscale: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate and normalize upscale_factor (optional, enum: "1", "2", or "4")
            # Normalize by removing "x" suffix if present (e.g., "2x" -> "2")
            if 'upscale_factor' in api_params and api_params.get('upscale_factor'):
                upscale_factor = str(api_params['upscale_factor']).strip().lower()
                # Remove "x" suffix if present
                if upscale_factor.endswith('x'):
                    upscale_factor = upscale_factor[:-1].strip()
                
                if upscale_factor not in ["1", "2", "4"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1</b>, <b>2</b> –∏–ª–∏ <b>4</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['upscale_factor']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid upscale_factor for topaz/video-upscale: {api_params['upscale_factor']}")
                    return ConversationHandler.END
                api_params['upscale_factor'] = upscale_factor
            else:
                # Remove upscale_factor if it's empty or None
                if 'upscale_factor' in api_params:
                    del api_params['upscale_factor']
        
        # For kling/v1-avatar-standard, validate and normalize parameters
        # NOTE: Price is 8 credits per second for 720P, up to 15 seconds (see calculate_price_rub())
        if model_id == "kling/v1-avatar-standard":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v1-avatar-standard: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for kling/v1-avatar-standard: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v1-avatar-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
        
        # For kling/ai-avatar-v1-pro, validate and normalize parameters
        # NOTE: Price is 16 credits per second for 1080P, up to 15 seconds (see calculate_price_rub())
        if model_id == "kling/ai-avatar-v1-pro":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/ai-avatar-v1-pro: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for kling/ai-avatar-v1-pro: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
        
        # For kling/v2-1-pro, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to API documentation
        # NOTE: Price depends on duration (5s = 50 credits, 10s = 100 credits, see calculate_price_rub())
        if model_id == "kling/v2-1-pro":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-1-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-1-pro")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for kling/v2-1-pro: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v2-1-pro")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-1-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-1-pro: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # CRITICAL: API expects string format ("5" or "10"), not integer
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Remove "s" or "seconds" suffix if present
                if duration.lower().endswith('seconds'):
                    duration = duration[:-7].strip()
                elif duration.lower().endswith('s'):
                    duration = duration[:-1].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling/v2-1-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string, max 500 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for kling/v2-1-pro: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number, min: 0, max: 1, step: 0.1)
            # CRITICAL: API expects number (float), not string
            # Normalize by rounding to 1 decimal place (step 0.1)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert to float
                    if isinstance(cfg_scale, str):
                        cfg_scale_str = cfg_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in cfg_scale_str:
                            cfg_scale_str = cfg_scale_str.replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale type for kling/v2-1-pro: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Check range (0 to 1)
                    if cfg_scale < 0 or cfg_scale > 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>0</b> –¥–æ <b>1</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale value for kling/v2-1-pro: {cfg_scale}")
                        return ConversationHandler.END
                    
                    # Round to 1 decimal place (step 0.1)
                    cfg_scale = round(cfg_scale, 1)
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0 –¥–æ 1.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid cfg_scale for kling/v2-1-pro: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
            
            # Validate tail_image_url (optional, URL)
            if 'tail_image_url' in api_params and api_params.get('tail_image_url'):
                tail_image_url = str(api_params['tail_image_url']).strip()
                if tail_image_url:
                    # Check for placeholder values
                    if tail_image_url.lower() in ['click to upload', 'click to upload or drag and drop', 'upload successfully', 'file 1', 'preview']:
                        # Remove placeholder
                        if 'tail_image_url' in api_params:
                            del api_params['tail_image_url']
                    else:
                        # Validate URL format
                        if not (tail_image_url.startswith('http://') or tail_image_url.startswith('https://')):
                            error_msg = (
                                "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                                "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tail_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                                f"–ü–æ–ª—É—á–µ–Ω–æ: {tail_image_url[:50]}..."
                            )
                            await send_or_edit_message(error_msg)
                            logger.error(f"Invalid tail_image_url format for kling/v2-1-pro: {tail_image_url[:50]}")
                            return ConversationHandler.END
                        api_params['tail_image_url'] = tail_image_url
                else:
                    # Remove tail_image_url if it's empty
                    if 'tail_image_url' in api_params:
                        del api_params['tail_image_url']
            else:
                # Remove tail_image_url if it's empty or None
                if 'tail_image_url' in api_params:
                    del api_params['tail_image_url']
        
        # For kling/v2-1-standard, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to API documentation
        # NOTE: Price depends on duration (5s = 25 credits, 10s = 50 credits, see calculate_price_rub())
        # CRITICAL: API uses image_url (string), NOT image_input (array) - same as kling/v2-1-pro
        if model_id == "kling/v2-1-standard":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-1-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-1-standard")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for kling/v2-1-standard: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # CRITICAL: API expects image_url (string), not image_input (array) - same as kling/v2-1-pro
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v2-1-standard")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-1-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-1-standard: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # CRITICAL: API expects string format ("5" or "10"), not integer
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Remove "s" or "seconds" suffix if present
                if duration.lower().endswith('seconds'):
                    duration = duration[:-7].strip()
                elif duration.lower().endswith('s'):
                    duration = duration[:-1].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid duration for kling/v2-1-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string, max 500 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for kling/v2-1-standard: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number, min: 0, max: 1, step: 0.1)
            # CRITICAL: API expects number (float), not string
            # Normalize by rounding to 1 decimal place (step 0.1)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert to float
                    if isinstance(cfg_scale, str):
                        cfg_scale_str = cfg_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in cfg_scale_str:
                            cfg_scale_str = cfg_scale_str.replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale type for kling/v2-1-standard: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Check range (0 to 1)
                    if cfg_scale < 0 or cfg_scale > 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>0</b> –¥–æ <b>1</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid cfg_scale value for kling/v2-1-standard: {cfg_scale}")
                        return ConversationHandler.END
                    
                    # Round to 1 decimal place (step 0.1)
                    cfg_scale = round(cfg_scale, 1)
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0 –¥–æ 1.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid cfg_scale for kling/v2-1-standard: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For wan/2-2-a14b-text-to-video-turbo, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price depends on resolution (480p: 8 credits/sec, 580p: 12 credits/sec, 720p: 16 credits/sec, see calculate_price_rub())
        if model_id == "wan/2-2-a14b-text-to-video-turbo":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-text-to-video-turbo.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-2-a14b-text-to-video-turbo")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-2-a14b-text-to-video-turbo")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for wan/2-2-a14b-text-to-video-turbo: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p", default: "720p")
            # CRITICAL: API expects lowercase with "p" suffix
            valid_resolutions = ["480p", "580p", "720p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_resolutions)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-2-a14b-text-to-video-turbo: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate and normalize aspect_ratio (optional, enum: "16:9", "9:16", or "1:1", default: "16:9")
            valid_aspect_ratios = ["16:9", "9:16", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_aspect_ratios)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for wan/2-2-a14b-text-to-video-turbo: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Default aspect_ratio if not provided
                api_params['aspect_ratio'] = "16:9"
            
            # Validate and normalize enable_prompt_expansion (optional, boolean, default: False)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-2-a14b-text-to-video-turbo: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-2-a14b-text-to-video-turbo: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Default enable_prompt_expansion if not provided
                api_params['enable_prompt_expansion'] = False
            
            # Validate and normalize seed (optional, integer, range: 0 to 2147483647)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for wan/2-2-a14b-text-to-video-turbo: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Check range (0 to 2147483647)
                    if seed < 0 or seed > 2147483647:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>0</b> –¥–æ <b>2147483647</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for wan/2-2-a14b-text-to-video-turbo: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for wan/2-2-a14b-text-to-video-turbo: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize acceleration (optional, enum: "none" or "regular", default: "none")
            valid_accelerations = ["none", "regular"]
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip().lower()
                if acceleration not in valid_accelerations:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_accelerations)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid acceleration for wan/2-2-a14b-text-to-video-turbo: {api_params['acceleration']}")
                    return ConversationHandler.END
                api_params['acceleration'] = acceleration
            else:
                # Default acceleration if not provided
                api_params['acceleration'] = "none"
        
        # For wan/2-2-a14b-image-to-video-turbo, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to API documentation
        # NOTE: Price depends on resolution (480p: 8 credits/sec, 580p: 12 credits/sec, 720p: 16 credits/sec, see calculate_price_rub())
        # CRITICAL: aspect_ratio has "auto" option and defaults to "auto" (unlike text-to-video which defaults to "16:9")
        if model_id == "wan/2-2-a14b-image-to-video-turbo":
            # Validate image_url (required, URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-image-to-video-turbo.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for wan/2-2-a14b-image-to-video-turbo")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-2-a14b-image-to-video-turbo")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-2-a14b-image-to-video-turbo: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-image-to-video-turbo.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-2-a14b-image-to-video-turbo")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-2-a14b-image-to-video-turbo")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for wan/2-2-a14b-image-to-video-turbo: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p", default: "720p")
            # CRITICAL: API expects lowercase with "p" suffix
            valid_resolutions = ["480p", "580p", "720p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_resolutions)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-2-a14b-image-to-video-turbo: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate and normalize aspect_ratio (optional, enum: "auto", "16:9", "9:16", or "1:1", default: "auto")
            # CRITICAL: aspect_ratio has "auto" option and defaults to "auto" (unlike text-to-video which defaults to "16:9")
            valid_aspect_ratios = ["auto", "16:9", "9:16", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                # Normalize "Auto" to "auto"
                if aspect_ratio == "auto":
                    aspect_ratio = "auto"
                elif aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_aspect_ratios)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for wan/2-2-a14b-image-to-video-turbo: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Default aspect_ratio if not provided
                api_params['aspect_ratio'] = "auto"
            
            # Validate and normalize enable_prompt_expansion (optional, boolean, default: False)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-2-a14b-image-to-video-turbo: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-2-a14b-image-to-video-turbo: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Default enable_prompt_expansion if not provided
                api_params['enable_prompt_expansion'] = False
            
            # Validate and normalize seed (optional, integer, range: 0 to 2147483647)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for wan/2-2-a14b-image-to-video-turbo: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Check range (0 to 2147483647)
                    if seed < 0 or seed > 2147483647:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>0</b> –¥–æ <b>2147483647</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for wan/2-2-a14b-image-to-video-turbo: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for wan/2-2-a14b-image-to-video-turbo: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize acceleration (optional, enum: "none" or "regular", default: "none")
            valid_accelerations = ["none", "regular"]
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip().lower()
                if acceleration not in valid_accelerations:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_accelerations)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid acceleration for wan/2-2-a14b-image-to-video-turbo: {api_params['acceleration']}")
                    return ConversationHandler.END
                api_params['acceleration'] = acceleration
            else:
                # Default acceleration if not provided
                api_params['acceleration'] = "none"
        
        # For wan/2-2-a14b-speech-to-video-turbo, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price depends on resolution and audio duration (480p: 12 credits/sec, 580p: 18 credits/sec, 720p: 24 credits/sec, see calculate_price_rub())
        if model_id == "wan/2-2-a14b-speech-to-video-turbo":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-speech-to-video-turbo.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for wan/2-2-a14b-speech-to-video-turbo: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-speech-to-video-turbo.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-2-a14b-speech-to-video-turbo: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_input is converted to audio_url earlier in the code
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-a14b-speech-to-video-turbo.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for wan/2-2-a14b-speech-to-video-turbo")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for wan/2-2-a14b-speech-to-video-turbo: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate and normalize num_frames (optional, integer, range: 40-120, must be multiple of 4, default: 80)
            if 'num_frames' in api_params and api_params.get('num_frames') is not None:
                num_frames = api_params['num_frames']
                try:
                    # Convert to integer
                    if isinstance(num_frames, str):
                        num_frames_str = num_frames.strip()
                        # Remove any decimal part if present
                        if '.' in num_frames_str:
                            num_frames_str = num_frames_str.split('.')[0]
                        num_frames = int(num_frames_str)
                    elif isinstance(num_frames, (int, float)):
                        num_frames = int(num_frames)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_frames).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_frames type for wan/2-2-a14b-speech-to-video-turbo: {type(num_frames)}")
                        return ConversationHandler.END
                    
                    # Check range (40 to 120)
                    if num_frames < 40 or num_frames > 120:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>40</b> –¥–æ <b>120</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_frames}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_frames value for wan/2-2-a14b-speech-to-video-turbo: {num_frames}")
                        return ConversationHandler.END
                    
                    # Check if multiple of 4
                    if num_frames % 4 != 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ä–∞—Ç–µ–Ω <b>4</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_frames}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_frames (not multiple of 4) for wan/2-2-a14b-speech-to-video-turbo: {num_frames}")
                        return ConversationHandler.END
                    
                    api_params['num_frames'] = num_frames
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 40 –¥–æ 120 (–∫—Ä–∞—Ç–Ω—ã–º 4).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_frames')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_frames for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('num_frames')}")
                    return ConversationHandler.END
            else:
                # Default num_frames if not provided
                api_params['num_frames'] = 80
            
            # Validate and normalize frames_per_second (optional, integer, range: 4-60, default: 16)
            if 'frames_per_second' in api_params and api_params.get('frames_per_second') is not None:
                frames_per_second = api_params['frames_per_second']
                try:
                    # Convert to integer
                    if isinstance(frames_per_second, str):
                        frames_per_second_str = frames_per_second.strip()
                        # Remove any decimal part if present
                        if '.' in frames_per_second_str:
                            frames_per_second_str = frames_per_second_str.split('.')[0]
                        frames_per_second = int(frames_per_second_str)
                    elif isinstance(frames_per_second, (int, float)):
                        frames_per_second = int(frames_per_second)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>frames_per_second</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(frames_per_second).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid frames_per_second type for wan/2-2-a14b-speech-to-video-turbo: {type(frames_per_second)}")
                        return ConversationHandler.END
                    
                    # Check range (4 to 60)
                    if frames_per_second < 4 or frames_per_second > 60:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>frames_per_second</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>4</b> –¥–æ <b>60</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {frames_per_second}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid frames_per_second value for wan/2-2-a14b-speech-to-video-turbo: {frames_per_second}")
                        return ConversationHandler.END
                    
                    api_params['frames_per_second'] = frames_per_second
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>frames_per_second</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 4 –¥–æ 60.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('frames_per_second')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid frames_per_second for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('frames_per_second')}")
                    return ConversationHandler.END
            else:
                # Default frames_per_second if not provided
                api_params['frames_per_second'] = 16
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p", default: "480p")
            # CRITICAL: API expects lowercase with "p" suffix
            valid_resolutions = ["480p", "580p", "720p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_resolutions)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-2-a14b-speech-to-video-turbo: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "480p"
            
            # Validate negative_prompt (optional, string, max 500 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for wan/2-2-a14b-speech-to-video-turbo: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize seed (optional, integer, range: 0 to 2147483647)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for wan/2-2-a14b-speech-to-video-turbo: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Check range (0 to 2147483647)
                    if seed < 0 or seed > 2147483647:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>0</b> –¥–æ <b>2147483647</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for wan/2-2-a14b-speech-to-video-turbo: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize num_inference_steps (optional, integer, range: 2-40, default: 27)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps_str = num_inference_steps.strip()
                        # Remove any decimal part if present
                        if '.' in num_inference_steps_str:
                            num_inference_steps_str = num_inference_steps_str.split('.')[0]
                        num_inference_steps = int(num_inference_steps_str)
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps type for wan/2-2-a14b-speech-to-video-turbo: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    # Check range (2 to 40)
                    if num_inference_steps < 2 or num_inference_steps > 40:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>2</b> –¥–æ <b>40</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps value for wan/2-2-a14b-speech-to-video-turbo: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 2 –¥–æ 40.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_inference_steps for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided
                api_params['num_inference_steps'] = 27
            
            # Validate and normalize guidance_scale (optional, number, range: 1.0-10.0, step: 0.1, default: 3.5)
            # CRITICAL: API expects number (float), not string
            # Normalize by rounding to 1 decimal place (step 0.1)
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale type for wan/2-2-a14b-speech-to-video-turbo: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check range (1.0 to 10.0)
                    if guidance_scale < 1.0 or guidance_scale > 10.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>1.0</b> –¥–æ <b>10.0</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale value for wan/2-2-a14b-speech-to-video-turbo: {guidance_scale}")
                        return ConversationHandler.END
                    
                    # Round to 1 decimal place (step 0.1)
                    guidance_scale = round(guidance_scale, 1)
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1.0 –¥–æ 10.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid guidance_scale for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Default guidance_scale if not provided
                api_params['guidance_scale'] = 3.5
            
            # Validate and normalize shift (optional, number, range: 1.0-10.0, step: 0.1, default: 5.0)
            # CRITICAL: API expects number (float), not string
            # Normalize by rounding to 1 decimal place (step 0.1)
            if 'shift' in api_params and api_params.get('shift') is not None:
                shift = api_params['shift']
                try:
                    # Convert to float
                    if isinstance(shift, str):
                        shift_str = shift.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in shift_str:
                            shift_str = shift_str.replace(',', '.')
                        shift = float(shift_str)
                    elif isinstance(shift, (int, float)):
                        shift = float(shift)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shift</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(shift).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid shift type for wan/2-2-a14b-speech-to-video-turbo: {type(shift)}")
                        return ConversationHandler.END
                    
                    # Check range (1.0 to 10.0)
                    if shift < 1.0 or shift > 10.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shift</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç <b>1.0</b> –¥–æ <b>10.0</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {shift}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid shift value for wan/2-2-a14b-speech-to-video-turbo: {shift}")
                        return ConversationHandler.END
                    
                    # Round to 1 decimal place (step 0.1)
                    shift = round(shift, 1)
                    api_params['shift'] = shift
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shift</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1.0 –¥–æ 10.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('shift')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid shift for wan/2-2-a14b-speech-to-video-turbo: {api_params.get('shift')}")
                    return ConversationHandler.END
            else:
                # Default shift if not provided
                api_params['shift'] = 5.0
            
            # Validate and normalize enable_safety_checker (optional, boolean, default: True)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for wan/2-2-a14b-speech-to-video-turbo: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for wan/2-2-a14b-speech-to-video-turbo: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Default enable_safety_checker if not provided
                api_params['enable_safety_checker'] = True
        
        # For wan/2-2-animate-replace, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to API documentation
        # NOTE: Price depends on resolution (480p: 6 credits/sec, 580p: 9.5 credits/sec, 720p: 12.5 credits/sec, see calculate_price_rub())
        # CRITICAL: API uses video_url (string) and image_url (string), NOT video_input/image_input (arrays)
        # CRITICAL: API does NOT require prompt parameter (unlike wan/2-2-animate-move)
        if model_id == "wan/2-2-animate-replace":
            # Validate video_url (required, URL)
            # Note: video_input is converted to video_url earlier in the code
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-replace.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for wan/2-2-animate-replace")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for wan/2-2-animate-replace")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for wan/2-2-animate-replace: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate image_url (required, URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-replace.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for wan/2-2-animate-replace")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-2-animate-replace")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-2-animate-replace: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p")
            # CRITICAL: API expects lowercase with "p" suffix
            valid_resolutions = ["480p", "580p", "720p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_resolutions)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for wan/2-2-animate-replace: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            # NOTE: resolution is optional, no default value needed
            
            # Remove prompt if present (API does not require it for wan/2-2-animate-replace)
            if 'prompt' in api_params:
                del api_params['prompt']
        
        # For bytedance/seedream-v4-text-to-image, validate and normalize parameters
        # NOTE: Price is 5 credits per image, depends on max_images (see calculate_price_rub())
        if model_id == "bytedance/seedream-v4-text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-text-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream-v4-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream-v4-text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for bytedance/seedream-v4-text-to-image: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize image_resolution (optional, enum: "1K", "2K", or "4K")
            if 'image_resolution' in api_params and api_params.get('image_resolution'):
                image_resolution = str(api_params['image_resolution']).strip().upper()
                # Ensure "K" suffix (uppercase)
                if not image_resolution.endswith('K'):
                    # Try to add "K" if it's just a number
                    try:
                        num = int(image_resolution)
                        image_resolution = f"{num}K"
                    except ValueError:
                        pass
                
                if image_resolution not in ["1K", "2K", "4K"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1K</b>, <b>2K</b> –∏–ª–∏ <b>4K</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_resolution for bytedance/seedream-v4-text-to-image: {api_params['image_resolution']}")
                    return ConversationHandler.END
                api_params['image_resolution'] = image_resolution
            else:
                # Remove image_resolution if it's empty or None
                if 'image_resolution' in api_params:
                    del api_params['image_resolution']
            
            # Validate and normalize max_images (optional, integer from 1 to 6)
            # NOTE: max_images affects price significantly (5 credits per image)
            if 'max_images' in api_params and api_params.get('max_images') is not None:
                max_images = api_params['max_images']
                try:
                    # Convert to integer
                    if isinstance(max_images, str):
                        max_images = int(max_images.strip())
                    elif isinstance(max_images, (int, float)):
                        max_images = int(max_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(max_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid max_images type for bytedance/seedream-v4-text-to-image: {type(max_images)}")
                        return ConversationHandler.END
                    
                    if max_images < 1 or max_images > 6:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>6</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {max_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid max_images value for bytedance/seedream-v4-text-to-image: {max_images}")
                        return ConversationHandler.END
                    
                    api_params['max_images'] = max_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('max_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid max_images for bytedance/seedream-v4-text-to-image: {api_params.get('max_images')}")
                    return ConversationHandler.END
            else:
                # Default max_images if not provided
                api_params['max_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/seedream-v4-text-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/seedream-v4-text-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For bytedance/seedream-v4-edit, validate and normalize parameters
        # NOTE: Price is 5 credits per image, depends on max_images (see calculate_price_rub())
        if model_id == "bytedance/seedream-v4-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 10 images)
            # Note: image_urls should already be converted from image_input in the conversion block above
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è(–∏–π) –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string or single-item list to list format
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            elif not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π URL.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for bytedance/seedream-v4-edit: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            if len(image_urls) > 10:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∞–∫—Å–∏–º—É–º <b>10</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for bytedance/seedream-v4-edit: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL in the array
            validated_urls = []
            for idx, url in enumerate(image_urls):
                url_str = str(url).strip()
                if not url_str:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty URL at index {idx} in image_urls for bytedance/seedream-v4-edit")
                    return ConversationHandler.END
                
                if not (url_str.startswith('http://') or url_str.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url_str[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid URL format at index {idx} in image_urls for bytedance/seedream-v4-edit: {url_str[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url_str)
            
            api_params['image_urls'] = validated_urls
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for bytedance/seedream-v4-edit: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize image_resolution (optional, enum: "1K", "2K", or "4K")
            if 'image_resolution' in api_params and api_params.get('image_resolution'):
                image_resolution = str(api_params['image_resolution']).strip().upper()
                # Ensure "K" suffix (uppercase)
                if not image_resolution.endswith('K'):
                    # Try to add "K" if it's just a number
                    try:
                        num = int(image_resolution)
                        image_resolution = f"{num}K"
                    except ValueError:
                        pass
                
                if image_resolution not in ["1K", "2K", "4K"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1K</b>, <b>2K</b> –∏–ª–∏ <b>4K</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_resolution for bytedance/seedream-v4-edit: {api_params['image_resolution']}")
                    return ConversationHandler.END
                api_params['image_resolution'] = image_resolution
            else:
                # Remove image_resolution if it's empty or None
                if 'image_resolution' in api_params:
                    del api_params['image_resolution']
            
            # Validate and normalize max_images (optional, integer from 1 to 6)
            # NOTE: max_images affects price significantly (5 credits per image)
            if 'max_images' in api_params and api_params.get('max_images') is not None:
                max_images = api_params['max_images']
                try:
                    # Convert to integer
                    if isinstance(max_images, str):
                        max_images = int(max_images.strip())
                    elif isinstance(max_images, (int, float)):
                        max_images = int(max_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(max_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid max_images type for bytedance/seedream-v4-edit: {type(max_images)}")
                        return ConversationHandler.END
                    
                    if max_images < 1 or max_images > 6:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>6</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {max_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid max_images value for bytedance/seedream-v4-edit: {max_images}")
                        return ConversationHandler.END
                    
                    api_params['max_images'] = max_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('max_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid max_images for bytedance/seedream-v4-edit: {api_params.get('max_images')}")
                    return ConversationHandler.END
            else:
                # Default max_images if not provided
                api_params['max_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/seedream-v4-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/seedream-v4-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For infinitalk/from-audio, validate and normalize parameters
        # NOTE: Price depends on resolution (see calculate_price_rub())
        # Price calculation: 480p = 3 credits/sec, 720p = 12 credits/sec, up to 15 seconds
        if model_id == "infinitalk/from-audio":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for infinitalk/from-audio: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for infinitalk/from-audio: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for infinitalk/from-audio")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for infinitalk/from-audio")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize resolution (optional, enum: "480p" or "720p")
            # NOTE: Resolution affects price significantly (480p vs 720p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["480p", "720p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b> –∏–ª–∏ <b>720p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid resolution for infinitalk/from-audio: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "480p"
            
            # Validate and normalize seed (optional, integer from 10000 to 1000000)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 10000 –¥–æ 1000000.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for infinitalk/from-audio: {type(seed)}")
                        return ConversationHandler.END
                    
                    if seed < 10000 or seed > 1000000:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>10000</b> –¥–æ <b>1000000</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for infinitalk/from-audio: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 10000 –¥–æ 1000000.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for infinitalk/from-audio: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For recraft/remove-background, validate and normalize parameters
        # NOTE: Price is fixed at 1 credit per image (see calculate_price_rub())
        if model_id == "recraft/remove-background":
            # Validate image (required, URL)
            # Note: image should already be converted from image_input in the conversion block above
            if 'image' not in api_params or not api_params.get('image'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ recraft/remove-background.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image for recraft/remove-background")
                return ConversationHandler.END
            
            image = str(api_params['image']).strip()
            if not image:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image for recraft/remove-background")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image.startswith('http://') or image.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image format for recraft/remove-background: {image[:50]}")
                return ConversationHandler.END
            api_params['image'] = image
            # Note: Additional constraints (file size, dimensions, format) are handled by the API
        
        # For recraft/crisp-upscale, validate and normalize parameters
        # NOTE: Price is free and unlimited for users (see calculate_price_rub())
        if model_id == "recraft/crisp-upscale":
            # Validate image (required, URL)
            # Note: image should already be converted from image_input in the conversion block above
            if 'image' not in api_params or not api_params.get('image'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ recraft/crisp-upscale.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image for recraft/crisp-upscale")
                return ConversationHandler.END
            
            image = str(api_params['image']).strip()
            if not image:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image for recraft/crisp-upscale")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image.startswith('http://') or image.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image format for recraft/crisp-upscale: {image[:50]}")
                return ConversationHandler.END
            api_params['image'] = image
            # Note: Additional constraints (file size, dimensions, format) are handled by the API
        
        # For ideogram/v3-reframe, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 3.5 credits/image, BALANCED = 7 credits/image, QUALITY = 10 credits/image
        if model_id == "ideogram/v3-reframe":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-reframe.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏–Ω–≥–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for ideogram/v3-reframe")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏–Ω–≥–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for ideogram/v3-reframe")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for ideogram/v3-reframe: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate image_size (required, enum: "Square HD")
            if 'image_size' not in api_params or not api_params.get('image_size'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-reframe.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_size for ideogram/v3-reframe")
                return ConversationHandler.END
            
            image_size = str(api_params['image_size']).strip()
            if not image_size:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_size for ideogram/v3-reframe")
                return ConversationHandler.END
            
            # CRITICAL: Normalize image_size format according to validation file
            # Valid values: "square", "square_hd", "portrait_4_3", "portrait_16_9", "landscape_4_3", "landscape_16_9"
            valid_image_sizes = ["square", "square_hd", "portrait_4_3", "portrait_16_9", "landscape_4_3", "landscape_16_9"]
            image_size_mapping = {
                "square": "square",
                "square hd": "square_hd",
                "squarehd": "square_hd",
                "Square HD": "square_hd",
                "SQUARE HD": "square_hd",
                "portrait 3:4": "portrait_4_3",
                "portrait 4:3": "portrait_4_3",
                "portrait 9:16": "portrait_16_9",
                "portrait 16:9": "portrait_16_9",
                "landscape 4:3": "landscape_4_3",
                "landscape 16:9": "landscape_16_9"
            }
            
            image_size_normalized = image_size.lower().replace(' ', '_').replace(':', '_')
            # Check mapping
            if image_size in image_size_mapping:
                image_size_normalized = image_size_mapping[image_size]
            elif image_size_normalized in image_size_mapping:
                image_size_normalized = image_size_mapping[image_size_normalized]
            
            if image_size_normalized not in valid_image_sizes:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_image_sizes)}.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_size for ideogram/v3-reframe: {image_size}")
                return ConversationHandler.END
            api_params['image_size'] = image_size_normalized
            
            # Validate and normalize rendering_speed (optional, enum: "Turbo", "Balanced", "Quality")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>Turbo</b>, <b>Balanced</b> –∏–ª–∏ <b>Quality</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid rendering_speed for ideogram/v3-reframe: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "GENERAL", "REALISTIC", "DESIGN")
            # CRITICAL: KIE API expects uppercase format according to validation file
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "GENERAL", "REALISTIC", "DESIGN"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>GENERAL</b>, <b>REALISTIC</b> –∏–ª–∏ <b>DESIGN</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid style for ideogram/v3-reframe: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images type for ideogram/v3-reframe: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images value for ideogram/v3-reframe: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/v3-reframe: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/v3-reframe: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/v3-reframe: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For ideogram/v3-edit, validate and normalize parameters
        # NOTE: Price depends on rendering_speed (TURBO: 3.5, BALANCED: 7, QUALITY: 10 credits, see calculate_price_rub())
        if model_id == "ideogram/v3-edit":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/v3-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/v3-edit")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for ideogram/v3-edit: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (required, array with 1 URL)
            # Note: API expects image_input as array, not image_url
            if 'image_input' not in api_params or not api_params.get('image_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            # Ensure image_input is a list
            image_input = api_params['image_input']
            if not isinstance(image_input, list):
                image_input = [image_input] if image_input else []
            
            if not image_input or len(image_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            if len(image_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_input)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many images in image_input for ideogram/v3-edit: {len(image_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            image_url = str(image_input[0]).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image URL in image_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image URL format for ideogram/v3-edit: {image_url[:50]}")
                return ConversationHandler.END
            
            # Set image_input as array with validated URL
            api_params['image_input'] = [image_url]
            
            # Validate mask_input (required, array with 1 URL)
            # Note: API expects mask_input as array, not mask_url
            if 'mask_input' not in api_params or not api_params.get('mask_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter mask_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            # Ensure mask_input is a list
            mask_input = api_params['mask_input']
            if not isinstance(mask_input, list):
                mask_input = [mask_input] if mask_input else []
            
            if not mask_input or len(mask_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty mask_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            if len(mask_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –º–∞—Å–∫—É.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(mask_input)} –º–∞—Å–æ–∫"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many masks in mask_input for ideogram/v3-edit: {len(mask_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            mask_url = str(mask_input[0]).strip()
            if not mask_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –º–∞—Å–∫–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty mask URL in mask_input for ideogram/v3-edit")
                return ConversationHandler.END
            
            if not (mask_url.startswith('http://') or mask_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –º–∞—Å–∫–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {mask_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid mask URL format for ideogram/v3-edit: {mask_url[:50]}")
                return ConversationHandler.END
            
            # Set mask_input as array with validated URL
            api_params['mask_input'] = [mask_url]
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip().upper()
                
                if rendering_speed not in ["TURBO", "BALANCED", "QUALITY"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid rendering_speed for ideogram/v3-edit: {api_params['rendering_speed']}")
                    return ConversationHandler.END
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize expand_prompt (optional, boolean)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid expand_prompt for ideogram/v3-edit: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid expand_prompt type for ideogram/v3-edit: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize num_images (optional, enum: "1", "2", "3", "4")
            if 'num_images' in api_params and api_params.get('num_images'):
                num_images = str(api_params['num_images']).strip()
                if num_images not in ["1", "2", "3", "4"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1</b>, <b>2</b>, <b>3</b> –∏–ª–∏ <b>4</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['num_images']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/v3-edit: {api_params['num_images']}")
                    return ConversationHandler.END
                api_params['num_images'] = num_images
            else:
                # Default num_images if not provided
                api_params['num_images'] = "1"
            
            # Validate and normalize seed (optional, integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/v3-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/v3-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For ideogram/v3-text-to-image, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price depends on rendering_speed (TURBO: 3.5, BALANCED: 7, QUALITY: 10 credits, see calculate_price_rub())
        if model_id == "ideogram/v3-text-to-image":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-text-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/v3-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/v3-text-to-image")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for ideogram/v3-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY", default: "BALANCED")
            # CRITICAL: KIE API expects uppercase format
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip().upper()
                
                if rendering_speed not in ["TURBO", "BALANCED", "QUALITY"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid rendering_speed for ideogram/v3-text-to-image: {api_params['rendering_speed']}")
                    return ConversationHandler.END
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "GENERAL", "REALISTIC", "DESIGN", default: "AUTO")
            # CRITICAL: KIE API expects uppercase format
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "GENERAL", "REALISTIC", "DESIGN"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>GENERAL</b>, <b>REALISTIC</b> –∏–ª–∏ <b>DESIGN</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid style for ideogram/v3-text-to-image: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: True)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid expand_prompt for ideogram/v3-text-to-image: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid expand_prompt type for ideogram/v3-text-to-image: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided (True)
                api_params['expand_prompt'] = True
            
            # Validate and normalize image_size (optional, enum, default: "square_hd")
            # CRITICAL: Normalize format (e.g., "Square HD" -> "square_hd")
            valid_image_sizes = ["square", "square_hd", "portrait_4_3", "portrait_16_9", "landscape_4_3", "landscape_16_9"]
            image_size_mapping = {
                "square": "square",
                "square hd": "square_hd",
                "squarehd": "square_hd",
                "portrait 3:4": "portrait_4_3",
                "portrait 9:16": "portrait_16_9",
                "landscape 4:3": "landscape_4_3",
                "landscape 16:9": "landscape_16_9"
            }
            
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                # Normalize: replace spaces and colons with underscores
                image_size_normalized = image_size.replace(' ', '_').replace(':', '_')
                # Check mapping
                if image_size in image_size_mapping:
                    image_size_normalized = image_size_mapping[image_size]
                elif image_size_normalized in image_size_mapping:
                    image_size_normalized = image_size_mapping[image_size_normalized]
                
                if image_size_normalized not in valid_image_sizes:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_image_sizes)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for ideogram/v3-text-to-image: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size_normalized
            else:
                # Default image_size if not provided
                api_params['image_size'] = "square_hd"
            
            # Validate and normalize num_images (optional, enum as string: "1", "2", "3", "4", default: "1")
            # CRITICAL: KIE API expects string format, not integer
            valid_num_images = ["1", "2", "3", "4"]
            if 'num_images' in api_params and api_params.get('num_images'):
                num_images = str(api_params['num_images']).strip()
                
                if num_images not in valid_num_images:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_num_images)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['num_images']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/v3-text-to-image: {api_params['num_images']}")
                    return ConversationHandler.END
                api_params['num_images'] = num_images
            else:
                # Default num_images if not provided
                api_params['num_images'] = "1"
            
            # Validate and normalize seed (optional, integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/v3-text-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/v3-text-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate negative_prompt (optional, string, max 5000 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 5000:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for ideogram/v3-text-to-image: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
        
        # For bytedance/seedream, validate and normalize parameters
        # NOTE: Price is fixed at 3.5 credits per image (see calculate_price_rub())
        if model_id == "bytedance/seedream":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for bytedance/seedream: {image_size}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale type for bytedance/seedream: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is positive
                    if guidance_scale <= 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale value for bytedance/seedream: {guidance_scale}")
                        return ConversationHandler.END
                    
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid guidance_scale for bytedance/seedream: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for bytedance/seedream: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for bytedance/seedream: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for bytedance/seedream: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for bytedance/seedream: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For google/imagen4, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price is 8 credits per image (see calculate_price_rub())
        if model_id == "google/imagen4":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/imagen4.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/imagen4")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/imagen4")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for google/imagen4: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate negative_prompt (optional, string, max 5000 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 5000:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for google/imagen4: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate aspect_ratio (optional, enum, default: "1:1")
            valid_aspect_ratios = ["1:1", "16:9", "9:16", "3:4", "4:3"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_aspect_ratios)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for google/imagen4: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Default aspect_ratio if not provided
                api_params['aspect_ratio'] = "1:1"
            
            # Validate num_images (optional, enum as string: "1", "2", "3", "4", default: "1")
            # CRITICAL: KIE API expects string format, not integer
            valid_num_images = ["1", "2", "3", "4"]
            if 'num_images' in api_params and api_params.get('num_images'):
                num_images = str(api_params['num_images']).strip()
                if num_images not in valid_num_images:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_num_images)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['num_images']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for google/imagen4: {api_params['num_images']}")
                    return ConversationHandler.END
                api_params['num_images'] = num_images
            else:
                # Default num_images if not provided
                api_params['num_images'] = "1"
            
            # Validate seed (optional, string, max 500 characters)
            # CRITICAL: KIE API expects string format, not integer (unlike imagen4-fast)
            if 'seed' in api_params and api_params.get('seed'):
                seed = str(api_params['seed']).strip()
                if seed:
                    if len(seed) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä seed —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(seed)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"seed too long for google/imagen4: {len(seed)} characters")
                        return ConversationHandler.END
                    api_params['seed'] = seed
                else:
                    # Remove seed if it's empty
                    if 'seed' in api_params:
                        del api_params['seed']
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For google/imagen4-fast, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price is 8 credits per image (see calculate_price_rub())
        # NOTE: seed is integer (unlike imagen4 where seed is string)
        if model_id == "google/imagen4-fast":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/imagen4-fast.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/imagen4-fast")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/imagen4-fast")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for google/imagen4-fast: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate negative_prompt (optional, string, max 5000 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 5000:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for google/imagen4-fast: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate aspect_ratio (optional, enum, default: "1:1")
            valid_aspect_ratios = ["1:1", "16:9", "9:16", "3:4", "4:3"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_aspect_ratios)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for google/imagen4-fast: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Default aspect_ratio if not provided
                api_params['aspect_ratio'] = "1:1"
            
            # Validate num_images (optional, enum as string: "1", "2", "3", "4", default: "1")
            # CRITICAL: KIE API expects string format, not integer
            valid_num_images = ["1", "2", "3", "4"]
            if 'num_images' in api_params and api_params.get('num_images'):
                num_images = str(api_params['num_images']).strip()
                if num_images not in valid_num_images:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_num_images)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['num_images']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for google/imagen4-fast: {api_params['num_images']}")
                    return ConversationHandler.END
                api_params['num_images'] = num_images
            else:
                # Default num_images if not provided
                api_params['num_images'] = "1"
            
            # Validate seed (optional, integer)
            # CRITICAL: KIE API expects integer format (unlike imagen4 where seed is string)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for google/imagen4-fast: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Check if seed is non-negative
                    if seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed value for google/imagen4-fast: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for google/imagen4-fast: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For google/imagen4-ultra, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price is 8 credits per image (see calculate_price_rub())
        # NOTE: seed is string (like imagen4, unlike imagen4-fast), and NO num_images parameter
        if model_id == "google/imagen4-ultra":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/imagen4-ultra.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/imagen4-ultra")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/imagen4-ultra")
                return ConversationHandler.END
            
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for google/imagen4-ultra: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate negative_prompt (optional, string, max 5000 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 5000:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä negative_prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"negative_prompt too long for google/imagen4-ultra: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    if 'negative_prompt' in api_params:
                        del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate aspect_ratio (optional, enum, default: "1:1")
            valid_aspect_ratios = ["1:1", "16:9", "9:16", "3:4", "4:3"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_aspect_ratios)}.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {aspect_ratio}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid aspect_ratio for google/imagen4-ultra: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Default aspect_ratio if not provided
                api_params['aspect_ratio'] = "1:1"
            
            # CRITICAL: google/imagen4-ultra does NOT support num_images parameter
            # Remove it if present (it's only for imagen4-fast)
            if 'num_images' in api_params:
                logger.warning(f"‚ö†Ô∏è google/imagen4-ultra does not support num_images parameter, removing it")
                del api_params['num_images']
            
            # Validate seed (optional, string, max 500 characters)
            # CRITICAL: KIE API expects string format (like imagen4, unlike imagen4-fast)
            if 'seed' in api_params and api_params.get('seed'):
                seed = str(api_params['seed']).strip()
                if seed:
                    if len(seed) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä seed —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(seed)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"seed too long for google/imagen4-ultra: {len(seed)} characters")
                        return ConversationHandler.END
                    api_params['seed'] = seed
                else:
                    # Remove seed if it's empty
                    if 'seed' in api_params:
                        del api_params['seed']
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For topaz/video-upscale, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price depends on video duration (12 credits per second, see calculate_price_rub())
        if model_id == "topaz/video-upscale":
            # Validate video_url (required, URL)
            # Note: video_input is converted to video_url earlier in the code
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/video-upscale.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for topaz/video-upscale: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate and normalize upscale_factor (optional, enum: "1", "2", or "4", default: "2")
            # Normalize by removing "x" suffix if present
            valid_upscale_factors = ["1", "2", "4"]
            if 'upscale_factor' in api_params and api_params.get('upscale_factor'):
                upscale_factor = str(api_params['upscale_factor']).strip().lower()
                # Remove "x" suffix if present
                if upscale_factor.endswith('x'):
                    upscale_factor = upscale_factor[:-1].strip()
                
                if upscale_factor not in valid_upscale_factors:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {', '.join(valid_upscale_factors)} (–∏–ª–∏ —Å —Å—É—Ñ—Ñ–∏–∫—Å–æ–º 'x': 1x, 2x, 4x).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['upscale_factor']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid upscale_factor for topaz/video-upscale: {api_params['upscale_factor']}")
                    return ConversationHandler.END
                api_params['upscale_factor'] = upscale_factor
            else:
                # Default upscale_factor if not provided
                api_params['upscale_factor'] = "2"
        
        # For elevenlabs/speech-to-text, validate and normalize parameters
        # CRITICAL: KIE API expects parameters according to validation file
        # NOTE: Price depends on audio duration (3.5 credits per minute, see calculate_price_rub())
        if model_id == "elevenlabs/speech-to-text":
            # Validate audio_url (required, URL)
            # Note: audio_input is converted to audio_url earlier in the code
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ elevenlabs/speech-to-text.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for elevenlabs/speech-to-text")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for elevenlabs/speech-to-text")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for elevenlabs/speech-to-text: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate language_code (optional, string, max 500 characters, default: "ru")
            if 'language_code' in api_params and api_params.get('language_code'):
                language_code = str(api_params['language_code']).strip()
                if language_code:
                    if len(language_code) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä language_code —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(language_code)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"language_code too long for elevenlabs/speech-to-text: {len(language_code)} characters")
                        return ConversationHandler.END
                    api_params['language_code'] = language_code
                else:
                    # Default language_code if empty
                    api_params['language_code'] = "ru"
            else:
                # Default language_code if not provided
                api_params['language_code'] = "ru"
            
            # Validate tag_audio_events (optional, boolean, default: False)
            if 'tag_audio_events' in api_params and api_params.get('tag_audio_events') is not None:
                tag_audio_events = api_params['tag_audio_events']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(tag_audio_events, str):
                    tag_audio_events = tag_audio_events.strip().lower()
                    if tag_audio_events in ['true', '1', 'yes']:
                        tag_audio_events = True
                    elif tag_audio_events in ['false', '0', 'no']:
                        tag_audio_events = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['tag_audio_events']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid tag_audio_events for elevenlabs/speech-to-text: {api_params['tag_audio_events']}")
                        return ConversationHandler.END
                elif not isinstance(tag_audio_events, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(tag_audio_events).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid tag_audio_events type for elevenlabs/speech-to-text: {type(tag_audio_events)}")
                    return ConversationHandler.END
                api_params['tag_audio_events'] = tag_audio_events
            else:
                # Default tag_audio_events if not provided
                api_params['tag_audio_events'] = False
            
            # Validate diarize (optional, boolean, default: False)
            if 'diarize' in api_params and api_params.get('diarize') is not None:
                diarize = api_params['diarize']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(diarize, str):
                    diarize = diarize.strip().lower()
                    if diarize in ['true', '1', 'yes']:
                        diarize = True
                    elif diarize in ['false', '0', 'no']:
                        diarize = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['diarize']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid diarize for elevenlabs/speech-to-text: {api_params['diarize']}")
                        return ConversationHandler.END
                elif not isinstance(diarize, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(diarize).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid diarize type for elevenlabs/speech-to-text: {type(diarize)}")
                    return ConversationHandler.END
                api_params['diarize'] = diarize
            else:
                # Default diarize if not provided
                api_params['diarize'] = False
        
        # For qwen/text-to-image, validate and normalize parameters
        # NOTE: Price depends on image_size (4 credits per megapixel, see calculate_price_rub())
        if model_id == "qwen/text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/text-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD" -> "square_hd")
            # Note: API expects "square_hd" but form shows "Square HD"
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                # Normalize "Square HD" to "square_hd" for API
                if image_size == "Square HD" or image_size.lower() == "square hd":
                    image_size = "square_hd"
                elif image_size not in ["square", "square_hd", "portrait_4_3", "portrait_16_9", "landscape_4_3", "landscape_16_9"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b> (1024√ó1024).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for qwen/text-to-image: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "square_hd"
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps type for qwen/text-to-image: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps value for qwen/text-to-image: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_inference_steps for qwen/text-to-image: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for qwen/text-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for qwen/text-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale type for qwen/text-to-image: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is in valid range [0, 20]
                    if guidance_scale < 0 or guidance_scale > 20:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0</b> –¥–æ <b>20</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale value for qwen/text-to-image: {guidance_scale}")
                        return ConversationHandler.END
                    
                    # CRITICAL: Round to 1 decimal place (step 0.1) according to validation file
                    api_params['guidance_scale'] = round(guidance_scale, 1)
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid guidance_scale for qwen/text-to-image: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for qwen/text-to-image: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for qwen/text-to-image: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
            
            # Validate and normalize output_format (optional, enum: "png" or "jpeg")
            # CRITICAL: KIE API expects lowercase format according to validation file
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                # Map jpg -> jpeg
                if output_format == "jpg":
                    output_format = "jpeg"
                
                if output_format not in ["png", "jpeg"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>png</b> –∏–ª–∏ <b>jpeg</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for qwen/text-to-image: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize acceleration (optional, enum: "None", "Regular", "High")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid acceleration for qwen/text-to-image: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Remove acceleration if it's empty or None
                if 'acceleration' in api_params:
                    del api_params['acceleration']
        
        # For qwen/image-to-image, validate and normalize parameters
        # NOTE: Price is fixed at 4 credits per image (see calculate_price_rub())
        if model_id == "qwen/image-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/image-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (required, array with 1 URL)
            # Note: API expects image_input as array, not image_url
            if 'image_input' not in api_params or not api_params.get('image_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-to-image.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_input for qwen/image-to-image")
                return ConversationHandler.END
            
            # Ensure image_input is a list
            image_input = api_params['image_input']
            if not isinstance(image_input, list):
                image_input = [image_input] if image_input else []
            
            if not image_input or len(image_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_input for qwen/image-to-image")
                return ConversationHandler.END
            
            if len(image_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_input)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many images in image_input for qwen/image-to-image: {len(image_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            image_url = str(image_input[0]).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image URL in image_input for qwen/image-to-image")
                return ConversationHandler.END
            
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image URL format for qwen/image-to-image: {image_url[:50]}")
                return ConversationHandler.END
            
            # Set image_input as array with validated URL
            api_params['image_input'] = [image_url]
            
            # Validate and normalize strength (optional, number from 0.0 to 1.0)
            # Note: strength can be a float (e.g., 0.8), and may use comma as decimal separator
            if 'strength' in api_params and api_params.get('strength') is not None:
                strength = api_params['strength']
                try:
                    # Convert to float
                    if isinstance(strength, str):
                        strength_str = strength.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in strength_str:
                            strength_str = strength_str.replace(',', '.')
                        strength = float(strength_str)
                    elif isinstance(strength, (int, float)):
                        strength = float(strength)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(strength).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid strength type for qwen/image-to-image: {type(strength)}")
                        return ConversationHandler.END
                    
                    # Check if strength is in valid range [0.0, 1.0]
                    if strength < 0.0 or strength > 1.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0.0</b> –¥–æ <b>1.0</b>.\n"
                            "1.0 = –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–¥–µ–ª–∞—Ç—å; 0.0 = —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {strength}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid strength value for qwen/image-to-image: {strength}")
                        return ConversationHandler.END
                    
                    # CRITICAL: Round to 2 decimal places (step 0.01) according to validation file
                    api_params['strength'] = round(strength, 2)
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('strength')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid strength for qwen/image-to-image: {api_params.get('strength')}")
                    return ConversationHandler.END
            else:
                # Remove strength if it's empty or None
                if 'strength' in api_params:
                    del api_params['strength']
            
            # Validate and normalize output_format (optional, enum: "png" or "jpeg")
            # CRITICAL: KIE API expects lowercase format according to validation file
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                # Map jpg -> jpeg
                if output_format == "jpg":
                    output_format = "jpeg"
                
                if output_format not in ["png", "jpeg"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>png</b> –∏–ª–∏ <b>jpeg</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for qwen/image-to-image: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize acceleration (optional, enum: "none", "regular", "high")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid acceleration for qwen/image-to-image: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Remove acceleration if it's empty or None
                if 'acceleration' in api_params:
                    del api_params['acceleration']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for qwen/image-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for qwen/image-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps type for qwen/image-to-image: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps value for qwen/image-to-image: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_inference_steps for qwen/image-to-image: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale type for qwen/image-to-image: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is in valid range [0, 20]
                    if guidance_scale < 0 or guidance_scale > 20:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0</b> –¥–æ <b>20</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale value for qwen/image-to-image: {guidance_scale}")
                        return ConversationHandler.END
                    
                    # CRITICAL: Round to 1 decimal place (step 0.1) according to validation file
                    api_params['guidance_scale'] = round(guidance_scale, 1)
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid guidance_scale for qwen/image-to-image: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for qwen/image-to-image: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for qwen/image-to-image: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For qwen/image-edit, validate and normalize parameters
        # NOTE: Price depends on image_size and num_images (‚âà $0.03 per megapixel, see calculate_price_rub())
        if model_id == "qwen/image-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/image-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/image-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (required, array with 1 URL)
            # Note: API expects image_input as array, not image_url
            if 'image_input' not in api_params or not api_params.get('image_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_input for qwen/image-edit")
                return ConversationHandler.END
            
            # Ensure image_input is a list
            image_input = api_params['image_input']
            if not isinstance(image_input, list):
                image_input = [image_input] if image_input else []
            
            if not image_input or len(image_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_input for qwen/image-edit")
                return ConversationHandler.END
            
            if len(image_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_input)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many images in image_input for qwen/image-edit: {len(image_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            image_url = str(image_input[0]).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image URL in image_input for qwen/image-edit")
                return ConversationHandler.END
            
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image URL format for qwen/image-edit: {image_url[:50]}")
                return ConversationHandler.END
            
            # Set image_input as array with validated URL
            api_params['image_input'] = [image_url]
            
            # Validate and normalize acceleration (optional, enum: "none", "regular", "high")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid acceleration for qwen/image-edit: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Default acceleration if not provided
                api_params['acceleration'] = "none"
            
            # Validate and normalize image_size (optional, enum: "Landscape 4:3" -> "landscape_4_3")
            # Note: API expects "landscape_4_3" but form shows "Landscape 4:3"
            valid_image_sizes = {
                "landscape 4:3": "landscape_4_3",
                "landscape_4_3": "landscape_4_3",
                "portrait 4:3": "portrait_4_3",
                "portrait_4_3": "portrait_4_3",
                "square": "square",
                "square_hd": "square_hd"
            }
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                image_size_lower = image_size.lower()
                
                if image_size_lower in valid_image_sizes:
                    api_params['image_size'] = valid_image_sizes[image_size_lower]
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, <b>Landscape 4:3</b>).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for qwen/image-edit: {api_params['image_size']}")
                    return ConversationHandler.END
            else:
                # Default image_size if not provided
                api_params['image_size'] = "landscape_4_3"
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps type for qwen/image-edit: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_inference_steps value for qwen/image-edit: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_inference_steps for qwen/image-edit: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided (form shows default 30, but example shows 25)
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for qwen/image-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for qwen/image-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize guidance_scale (optional, number, default: 4)
            # Note: guidance_scale can be a float (e.g., 4.0), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale type for qwen/image-edit: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is in valid range [0, 20]
                    if guidance_scale < 0 or guidance_scale > 20:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0</b> –¥–æ <b>20</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid guidance_scale value for qwen/image-edit: {guidance_scale}")
                        return ConversationHandler.END
                    
                    # CRITICAL: Round to 1 decimal place (step 0.1) according to validation file
                    api_params['guidance_scale'] = round(guidance_scale, 1)
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid guidance_scale for qwen/image-edit: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Default guidance_scale if not provided
                api_params['guidance_scale'] = 4
            
            # Validate and normalize sync_mode (optional, boolean)
            if 'sync_mode' in api_params and api_params.get('sync_mode') is not None:
                sync_mode = api_params['sync_mode']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(sync_mode, str):
                    sync_mode = sync_mode.strip().lower()
                    if sync_mode in ['true', '1', 'yes', 'on']:
                        sync_mode = True
                    elif sync_mode in ['false', '0', 'no', 'off']:
                        sync_mode = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>sync_mode</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['sync_mode']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid sync_mode for qwen/image-edit: {api_params['sync_mode']}")
                        return ConversationHandler.END
                elif not isinstance(sync_mode, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>sync_mode</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(sync_mode).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid sync_mode type for qwen/image-edit: {type(sync_mode)}")
                    return ConversationHandler.END
                api_params['sync_mode'] = sync_mode
            else:
                # Remove sync_mode if it's empty or None
                if 'sync_mode' in api_params:
                    del api_params['sync_mode']
            
            # Validate and normalize num_images (optional, integer, range: 1-4, default: 1)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º) –æ—Ç 1 –¥–æ 4.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images type for qwen/image-edit: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1 or num_images > 4:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>4</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images value for qwen/image-edit: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º) –æ—Ç 1 –¥–æ 4.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for qwen/image-edit: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize enable_safety_checker (optional, boolean, default: true)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid enable_safety_checker for qwen/image-edit: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid enable_safety_checker type for qwen/image-edit: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Default enable_safety_checker if not provided
                api_params['enable_safety_checker'] = True
            
            # Validate and normalize output_format (optional, enum: "png" or "jpeg", default: "png")
            # CRITICAL: KIE API expects lowercase format according to validation file
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                
                if output_format not in ["png", "jpeg"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>png</b> –∏–ª–∏ <b>jpeg</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for qwen/image-edit: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Default output_format if not provided
                api_params['output_format'] = "png"
            
            # Validate negative_prompt (optional, string, default: " ")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string with space if empty
                    api_params['negative_prompt'] = " "
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = " "
        
        # For google/nano-banana, validate and normalize parameters
        if model_id == "google/nano-banana":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/nano-banana")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/nano-banana")
                return ConversationHandler.END
            
            # Check max length (5000 characters)
            if len(prompt) > 5000:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å–∏–º—É–º 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Prompt too long for google/nano-banana: {len(prompt)} characters")
                return ConversationHandler.END
            
            api_params['prompt'] = prompt
            
            # Validate and normalize output_format (optional, enum: "png" or "jpeg")
            # NOTE: API expects lowercase format ("png", "jpeg")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                
                # Validate lowercase input (png/jpeg)
                if output_format not in ["png", "jpeg"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>png</b> –∏–ª–∏ <b>jpeg</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for google/nano-banana: {api_params['output_format']}")
                    return ConversationHandler.END
                
                # Keep lowercase for API (API expects "png" or "jpeg")
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize image_size (optional, enum: "1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1:1</b>, <b>9:16</b>, <b>16:9</b>, <b>3:4</b>, <b>4:3</b>, <b>3:2</b>, <b>2:3</b>, <b>5:4</b>, <b>4:5</b>, <b>21:9</b> –∏–ª–∏ <b>auto</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for google/nano-banana: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
        
        # For google/nano-banana-edit, validate and normalize parameters
        if model_id == "google/nano-banana-edit":
            # Validate prompt (required, string, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/nano-banana-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/nano-banana-edit")
                return ConversationHandler.END
            
            # Check max length (5000 characters)
            if len(prompt) > 5000:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å–∏–º—É–º 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Prompt too long for google/nano-banana-edit: {len(prompt)} characters")
                return ConversationHandler.END
            
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 10 images)
            # Note: image_urls should already be converted from image_input in the conversion block above
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è(–∏–π) –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for google/nano-banana-edit")
                return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string or single-item list to list format
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            elif not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π URL.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for google/nano-banana-edit: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls for google/nano-banana-edit")
                return ConversationHandler.END
            
            if len(image_urls) > 10:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∞–∫—Å–∏–º—É–º <b>10</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for google/nano-banana-edit: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL in the array
            validated_urls = []
            for idx, url in enumerate(image_urls):
                url_str = str(url).strip()
                if not url_str:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Empty URL at index {idx} in image_urls for google/nano-banana-edit")
                    return ConversationHandler.END
                
                if not (url_str.startswith('http://') or url_str.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url_str[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid URL format at index {idx} in image_urls for google/nano-banana-edit: {url_str[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url_str)
            
            api_params['image_urls'] = validated_urls
            
            # Validate and normalize output_format (optional, enum: "png" or "jpeg")
            # NOTE: API expects lowercase format ("png", "jpeg")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                
                # Validate lowercase input (png/jpeg)
                if output_format not in ["png", "jpeg"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>png</b> –∏–ª–∏ <b>jpeg</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid output_format for google/nano-banana-edit: {api_params['output_format']}")
                    return ConversationHandler.END
                
                # Keep lowercase for API (API expects "png" or "jpeg")
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize image_size (optional, enum: "1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1:1</b>, <b>9:16</b>, <b>16:9</b>, <b>3:4</b>, <b>4:3</b>, <b>3:2</b>, <b>2:3</b>, <b>5:4</b>, <b>4:5</b>, <b>21:9</b> –∏–ª–∏ <b>auto</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for google/nano-banana-edit: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
        
        # For ideogram/character-edit, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (required, array with 1 URL)
            # Note: API expects image_input as array, not image_url
            if 'image_input' not in api_params or not api_params.get('image_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_input for ideogram/character-edit")
                return ConversationHandler.END
            
            # Ensure image_input is a list
            image_input = api_params['image_input']
            if not isinstance(image_input, list):
                image_input = [image_input] if image_input else []
            
            if not image_input or len(image_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_input for ideogram/character-edit")
                return ConversationHandler.END
            
            if len(image_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_input)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many images in image_input for ideogram/character-edit: {len(image_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            image_url = str(image_input[0]).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image URL in image_input for ideogram/character-edit")
                return ConversationHandler.END
            
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image URL format for ideogram/character-edit: {image_url[:50]}")
                return ConversationHandler.END
            
            # Set image_input as array with validated URL
            api_params['image_input'] = [image_url]
            
            # Validate mask_input (required, array with 1 URL)
            # Note: API expects mask_input as array, not mask_url
            if 'mask_input' not in api_params or not api_params.get('mask_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter mask_input for ideogram/character-edit")
                return ConversationHandler.END
            
            # Ensure mask_input is a list
            mask_input = api_params['mask_input']
            if not isinstance(mask_input, list):
                mask_input = [mask_input] if mask_input else []
            
            if not mask_input or len(mask_input) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty mask_input for ideogram/character-edit")
                return ConversationHandler.END
            
            if len(mask_input) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –º–∞—Å–∫—É.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(mask_input)} –º–∞—Å–æ–∫"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many masks in mask_input for ideogram/character-edit: {len(mask_input)}")
                return ConversationHandler.END
            
            # Validate URL format
            mask_url = str(mask_input[0]).strip()
            if not mask_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –º–∞—Å–∫–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty mask URL in mask_input for ideogram/character-edit")
                return ConversationHandler.END
            
            if not (mask_url.startswith('http://') or mask_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "URL –º–∞—Å–∫–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {mask_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid mask URL format for ideogram/character-edit: {mask_url[:50]}")
                return ConversationHandler.END
            
            # Set mask_input as array with validated URL
            api_params['mask_input'] = [mask_url]
            
            # Validate reference_image_input (required, array of URLs)
            # Note: API expects reference_image_input as array, not reference_image_urls
            if 'reference_image_input' not in api_params or not api_params.get('reference_image_input'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_input</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_input for ideogram/character-edit")
                return ConversationHandler.END
            
            reference_image_input = api_params['reference_image_input']
            
            # Ensure reference_image_input is a list
            if not isinstance(reference_image_input, list):
                # Convert single URL to list
                if isinstance(reference_image_input, str):
                    reference_image_input = [reference_image_input]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_input</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_input).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_input type for ideogram/character-edit: {type(reference_image_input)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_input) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_input</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_input for ideogram/character-edit")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            # But we allow multiple URLs in the array (API will ignore extras)
            if len(reference_image_input) > 1:
                logger.warning(f"ideogram/character-edit: Only first image in reference_image_input will be used, {len(reference_image_input)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_input):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_input</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_input[{i}] for ideogram/character-edit: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_input</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_input[{i}] format for ideogram/character-edit: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_input'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid rendering_speed for ideogram/character-edit: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid style for ideogram/character-edit: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid expand_prompt for ideogram/character-edit: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid expand_prompt type for ideogram/character-edit: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images type for ideogram/character-edit: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images value for ideogram/character-edit: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/character-edit: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/character-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/character-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For ideogram/character-remix, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character-remix":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–º–∏–∫—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character-remix")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–º–∏–∫—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character-remix")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–º–∏–∫—Å–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for ideogram/character-remix")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–º–∏–∫—Å–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for ideogram/character-remix")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for ideogram/character-remix: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate reference_image_urls (required, array of URLs, max 1 image supported, max 10MB total)
            # Note: reference_image_urls should already be converted from reference_image_input in the conversion block above
            if 'reference_image_urls' not in api_params or not api_params.get('reference_image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_urls for ideogram/character-remix")
                return ConversationHandler.END
            
            reference_image_urls = api_params['reference_image_urls']
            
            # Ensure reference_image_urls is a list
            if not isinstance(reference_image_urls, list):
                # Convert single URL to list
                if isinstance(reference_image_urls, str):
                    reference_image_urls = [reference_image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls type for ideogram/character-remix: {type(reference_image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_urls) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_urls for ideogram/character-remix")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            if len(reference_image_urls) > 1:
                logger.warning(f"ideogram/character-remix: Only first image in reference_image_urls will be used, {len(reference_image_urls)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls[{i}] for ideogram/character-remix: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_urls'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid rendering_speed for ideogram/character-remix: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid style for ideogram/character-remix: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid expand_prompt for ideogram/character-remix: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid expand_prompt type for ideogram/character-remix: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize image_size (optional, enum: "Square HD", default: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for ideogram/character-remix: {image_size}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "Square HD"
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images type for ideogram/character-remix: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images value for ideogram/character-remix: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/character-remix: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/character-remix: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/character-remix: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize strength (optional, number from 0.0 to 1.0, default: 0.8)
            # Note: strength can be a float (e.g., 0.8), and may use comma as decimal separator
            if 'strength' in api_params and api_params.get('strength') is not None:
                strength = api_params['strength']
                try:
                    # Convert to float
                    if isinstance(strength, str):
                        strength_str = strength.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in strength_str:
                            strength_str = strength_str.replace(',', '.')
                        strength = float(strength_str)
                    elif isinstance(strength, (int, float)):
                        strength = float(strength)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(strength).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid strength type for ideogram/character-remix: {type(strength)}")
                        return ConversationHandler.END
                    
                    # Check if strength is in valid range [0.0, 1.0]
                    if strength < 0.0 or strength > 1.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0.0</b> –¥–æ <b>1.0</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {strength}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid strength value for ideogram/character-remix: {strength}")
                        return ConversationHandler.END
                    
                    api_params['strength'] = strength
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('strength')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid strength for ideogram/character-remix: {api_params.get('strength')}")
                    return ConversationHandler.END
            else:
                # Default strength if not provided
                api_params['strength'] = 0.8
            
            # Validate negative_prompt (optional, string, default: "")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string if empty
                    api_params['negative_prompt'] = ""
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = ""
            
            # Validate image_urls (optional, array of URLs, max 5 images, max 10MB total)
            # Note: image_urls are style references
            if 'image_urls' in api_params and api_params.get('image_urls'):
                image_urls = api_params['image_urls']
                
                # Ensure image_urls is a list
                if not isinstance(image_urls, list):
                    # Convert single URL to list
                    if isinstance(image_urls, str):
                        image_urls = [image_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_urls type for ideogram/character-remix: {type(image_urls)}")
                        return ConversationHandler.END
                
                # Validate that list has max 5 items
                if len(image_urls) > 5:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 5).\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Too many image_urls for ideogram/character-remix: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate each URL is a string and has valid format
                validated_urls = []
                for i, url in enumerate(image_urls):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_urls[{i}] for ideogram/character-remix: {url}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid image_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                        return ConversationHandler.END
                    
                    validated_urls.append(url)
                
                api_params['image_urls'] = validated_urls
            else:
                # Remove image_urls if it's empty or None
                if 'image_urls' in api_params:
                    del api_params['image_urls']
            
            # Validate reference_mask_urls (optional, array of URLs, max 1 mask supported, max 10MB total)
            if 'reference_mask_urls' in api_params and api_params.get('reference_mask_urls'):
                reference_mask_urls = api_params['reference_mask_urls']
                
                # Ensure reference_mask_urls is a list
                if not isinstance(reference_mask_urls, list):
                    # Convert single URL to list
                    if isinstance(reference_mask_urls, str):
                        reference_mask_urls = [reference_mask_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_mask_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –º–∞—Å–æ–∫.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_mask_urls).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid reference_mask_urls type for ideogram/character-remix: {type(reference_mask_urls)}")
                        return ConversationHandler.END
                
                # Note: Currently only 1 mask is supported, rest will be ignored
                if len(reference_mask_urls) > 1:
                    logger.warning(f"ideogram/character-remix: Only first mask in reference_mask_urls will be used, {len(reference_mask_urls)} provided")
                
                # Validate each URL is a string and has valid format
                validated_urls = []
                for i, url in enumerate(reference_mask_urls):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_mask_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid reference_mask_urls[{i}] for ideogram/character-remix: {url}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_mask_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid reference_mask_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                        return ConversationHandler.END
                    
                    validated_urls.append(url)
                
                api_params['reference_mask_urls'] = validated_urls
            else:
                # Remove reference_mask_urls if it's empty or None
                if 'reference_mask_urls' in api_params:
                    del api_params['reference_mask_urls']
        
        # For ideogram/character, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate reference_image_urls (required, array of URLs, max 1 image supported, max 10MB total)
            # Note: reference_image_urls should already be converted from reference_image_input in the conversion block above
            if 'reference_image_urls' not in api_params or not api_params.get('reference_image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_urls for ideogram/character")
                return ConversationHandler.END
            
            reference_image_urls = api_params['reference_image_urls']
            
            # Ensure reference_image_urls is a list
            if not isinstance(reference_image_urls, list):
                # Convert single URL to list
                if isinstance(reference_image_urls, str):
                    reference_image_urls = [reference_image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_urls).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls type for ideogram/character: {type(reference_image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_urls) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_urls for ideogram/character")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            if len(reference_image_urls) > 1:
                logger.warning(f"ideogram/character: Only first image in reference_image_urls will be used, {len(reference_image_urls)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls[{i}] for ideogram/character: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid reference_image_urls[{i}] format for ideogram/character: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_urls'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid rendering_speed for ideogram/character: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid style for ideogram/character: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid expand_prompt for ideogram/character: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid expand_prompt type for ideogram/character: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images type for ideogram/character: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid num_images value for ideogram/character: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid num_images for ideogram/character: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize image_size (optional, enum: "square_hd", default: "square_hd")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["square_hd"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>square_hd</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid image_size for ideogram/character: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "square_hd"
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await send_or_edit_message(error_msg)
                        logger.error(f"Invalid seed type for ideogram/character: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await send_or_edit_message(error_msg)
                    logger.error(f"Invalid seed for ideogram/character: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate negative_prompt (optional, string, default: "")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string if empty
                    api_params['negative_prompt'] = ""
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = ""
            
        # Check video_url validation for sora-watermark-remover (if applicable)
        if model_id == "sora-watermark-remover" and 'video_url' in api_params:
            try:
                session = await get_http_client()
                async with session.head(video_url, allow_redirects=True) as resp:
                    if resp.status not in [200, 301, 302, 303, 307, 308]:
                        logger.warning(f"Video URL returned status {resp.status}: {video_url}")
                        if is_admin_user:
                            await query.edit_message_text(
                                f"‚ö†Ô∏è <b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ</b>\n\n"
                                f"URL –≤–∏–¥–µ–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å {resp.status}.\n"
                                f"URL: {video_url[:100]}...\n\n"
                                f"–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ URL –ø—É–±–ª–∏—á–Ω–æ –¥–æ—Å—Ç—É–ø–µ–Ω.",
                                parse_mode='HTML'
                            )
                            return ConversationHandler.END
            except Exception as e:
                logger.warning(f"Could not verify video URL accessibility: {e}")
                # Don't fail if we can't verify, just log warning
        
        # Check maximum concurrent generations per user BEFORE creating task
        # This prevents race conditions and unnecessary API calls
        async with active_generations_lock:
            user_active_count = sum(1 for (uid, _) in active_generations.keys() if uid == user_id)
            if user_active_count >= MAX_CONCURRENT_GENERATIONS_PER_USER:
                await query.edit_message_text(
                    f"‚ö†Ô∏è <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                    f"–£ –≤–∞—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω–æ {user_active_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n"
                    f"–ú–∞–∫—Å–∏–º—É–º: {MAX_CONCURRENT_GENERATIONS_PER_USER}.\n\n"
                    f"–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–¥–Ω–æ–π –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ –µ—ë.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        # Verify session still exists before proceeding
        if user_id not in user_sessions:
            await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END
        
        # DRY-RUN GUARD: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Ä–µ–∞–ª—å–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å
        dry_run = is_dry_run() or not allow_real_generation()
        
        if dry_run:
            logger.info(f"üîß DRY-RUN: Simulating generation for model {model_id}, user {user_id}")
            # –ü–æ–ª—É—á–∞–µ–º gateway –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–æ–∫–æ–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            gateway = get_kie_gateway()
            
            # –°–æ–∑–¥–∞–µ–º –º–æ–∫–æ–≤—É—é –∑–∞–¥–∞—á—É
            try:
                result = await gateway.create_task(model_id, api_params)
                task_id = result.get('taskId', f"dry_run_{hash(model_id) % 10000}")
                logger.info(f"üîß DRY-RUN: Mock task created: {task_id}")
            except Exception as e:
                logger.error(f"‚ùå DRY-RUN: Error creating mock task: {e}")
                import hashlib
                task_id = f"dry_run_{hashlib.md5(f'{model_id}:{user_id}'.encode()).hexdigest()[:12]}"
                result = {'ok': True, 'taskId': task_id}
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–æ–∫–æ–≤—ã–π URL —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            is_video = any(kw in model_id.lower() for kw in ['video', 'sora', 'kling', 'wan', 'hailuo'])
            ext = '.mp4' if is_video else '.png'
            mock_url = f"https://example.com/mock/{model_id.replace('/', '_')}/{task_id}{ext}"
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–º–µ—Ç–∫–æ–π DRY-RUN
            user_lang = get_user_language(user_id) if user_id else 'ru'
            dry_run_text = "üîß DRY-RUN: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–∞" if user_lang == 'ru' else "üîß DRY-RUN: Generation simulated"
            
            await query.edit_message_text(
                f"‚úÖ <b>{dry_run_text}</b>\n\n"
                f"Task ID: <code>{task_id}</code>\n"
                f"Model: <code>{model_id}</code>\n\n"
                f"üîó Mock URL: {mock_url}\n\n"
                f"‚ö†Ô∏è –ë–∞–ª–∞–Ω—Å –ù–ï —Å–ø–∏—Å–∞–Ω (DRY-RUN —Ä–µ–∂–∏–º)",
                parse_mode='HTML'
            )
            
            # –ù–ï —Å–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –≤ DRY-RUN
            logger.info(f"üîß DRY-RUN: Would deduct {price} from user {user_id} (NOT DEDUCTED)")
            if create_operation:
                try:
                    create_operation(user_id, "dry_run_generation", Decimal('0.00'), model_id, mock_url, None)
                except:
                    pass
            
            return ConversationHandler.END
        
        # REAL GENERATION: –ò—Å–ø–æ–ª—å–∑—É–µ–º gateway
        gateway = get_kie_gateway()
        
        # üî¥ –ö–†–ò–¢–ò–ß–ù–û: –°–ø–∏—Å–∞–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –î–û —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏ (–∞—Ç–æ–º–∞—Ä–Ω–æ)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—É –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞ (official_usd * –∫—É—Ä—Å * 2)
        if not is_admin_user and not is_free:
            # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.services.pricing_service import price_for_model_rub, get_model_price_info
            from app.config import get_settings
            
            settings = get_settings()
            mode_index = 0  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–≤—ã–π —Ä–µ–∂–∏–º
            price_rub_catalog = price_for_model_rub(model_id, mode_index, settings)
            
            if price_rub_catalog is None:
                logger.error(f"Price not found in catalog for model {model_id}, using calculated price")
                price_rub_catalog = price
            
            # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–µ
            price_info = get_model_price_info(model_id, mode_index, settings)
            if price_info:
                logger.info(
                    f"PRICE_RUB={price_rub_catalog} OFFICIAL_USD={price_info['official_usd']:.4f} "
                    f"MULT={price_info['price_multiplier']} RATE={price_info['usd_to_rub']} "
                    f"MODEL={model_id} USER={user_id}"
                )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
            user_balance_check = await get_user_balance_async(user_id)
            if user_balance_check < price_rub_catalog:
                price_str = f"{price_rub_catalog:.2f}".rstrip('0').rstrip('.')
                balance_str = f"{user_balance_check:.2f}".rstrip('0').rstrip('.')
                user_lang_check = get_user_language(user_id)
                needed = price_rub_catalog - user_balance_check
                needed_str = f"{needed:.2f}".rstrip('0').rstrip('.')
                
                if user_lang_check == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                        f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient funds</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>Your balance:</b> {balance_str} ‚ÇΩ\n"
                        f"üí∞ <b>Required:</b> {price_str} ‚ÇΩ\n"
                        f"‚ùå <b>Missing:</b> {needed_str} ‚ÇΩ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° Top up balance to generate"
                    )
                
                keyboard = [
                    [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang_check), callback_data="topup_balance")],
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang_check), callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(insufficient_msg, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
                return ConversationHandler.END
            
            # –°–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –î–û —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
            success = await subtract_user_balance_async(user_id, price_rub_catalog)
            if not success:
                logger.error(f"Failed to deduct balance for user {user_id}, amount {price_rub_catalog}")
                user_lang_check = get_user_language(user_id)
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞</b>\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
                ) if user_lang_check == 'ru' else (
                    f"‚ùå <b>Balance deduction error</b>\n\n"
                    f"Please try later or contact support."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                return ConversationHandler.END
            
            # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ —Å–ø–∏—Å–∞–Ω–∏–µ
            new_balance = await get_user_balance_async(user_id)
            logger.info(
                f"BALANCE VERIFIED: user_id={user_id} deducted={price_rub_catalog} "
                f"old_balance={user_balance_check:.2f} new_balance={new_balance:.2f} model={model_id}"
            )
            
            # –û–±–Ω–æ–≤–ª—è–µ–º price –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            price = price_rub_catalog
        
        # Create task (for async models like z-image) with retry logic
        # ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–û: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤ KIE API
        # –í–°–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–æ–ª–∂–Ω—ã —Å—Ç—Ä–æ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º KIE AI
        # –ù–ò–ß–ï–ì–û –æ—Ç —Å–µ–±—è –Ω–µ –ø—Ä–∏–¥—É–º—ã–≤–∞—Ç—å - —Ç–æ–ª—å–∫–æ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏!
        # –°–º. KIE_AI_STRICT_RULES.md –¥–ª—è –ø–æ–ª–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª
        import json
        logger.info(f"üöÄüöÄüöÄ Creating task for model {model_id}, user {user_id}")
        logger.info(f"üìã API Parameters (KIE API format): model={model_id}, input={json.dumps(api_params, ensure_ascii=False, indent=2)}")
        result = None
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            logger.info(f"üîÑ Task creation attempt {attempt + 1}/{max_retries} for {model_id}")
            result = await gateway.create_task(model_id, api_params)
            logger.info(f"üìã Task creation result: ok={result.get('ok')}, taskId={result.get('taskId')}, error={result.get('error')}")
            
            # Log result for debugging (only for admin)
            if is_admin_user:
                logger.info(f"Task creation attempt {attempt + 1}/{max_retries} result: {result}")
            
            if result.get('ok'):
                break
            
            # CRITICAL: Check for 422 errors (validation errors) - don't retry these
            status = result.get('status')
            error = result.get('error', '').lower()
            if status == 422:
                logger.error(f"‚ùå 422 Validation Error for {model_id}: {error}")
                logger.error(f"‚ùå API Parameters that caused error: {json.dumps(api_params, ensure_ascii=False, indent=2)}")
                # Don't retry 422 errors - they indicate invalid parameters
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</b>\n\n"
                    f"–°–µ—Ä–≤–µ—Ä –æ—Ç–∫–ª–æ–Ω–∏–ª –∑–∞–ø—Ä–æ—Å –∏–∑-–∑–∞ –Ω–µ–≤–µ—Ä–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.\n"
                    f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∫–∞–∑–∞–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ.\n\n"
                    f"–û—à–∏–±–∫–∞: {error[:200]}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                return ConversationHandler.END
            
            # Check if error is retryable
            is_retryable = any(keyword in error for keyword in ['server exception', 'please again', 'try again', 'timeout', 'temporarily', 'connection'])
            
            if is_retryable and attempt < max_retries - 1:
                if is_admin_user:
                    await query.edit_message_text(
                        f"‚è≥ <b>–ü–æ–ø—ã—Ç–∫–∞ {attempt + 2}/{max_retries}</b>\n\n"
                        f"–û—à–∏–±–∫–∞ API: {result.get('error', 'Unknown')}\n"
                        f"–ü–æ–≤—Ç–æ—Ä—è—é —á–µ—Ä–µ–∑ {retry_delay} —Å–µ–∫...",
                        parse_mode='HTML'
                    )
                await asyncio.sleep(retry_delay)
                retry_delay *= 2  # Exponential backoff
            else:
                break
        
        if result.get('ok'):
            task_id = result.get('taskId')
            
            # Verify session still exists before moving to active_generations
            if user_id not in user_sessions:
                logger.error(f"Session disappeared for user {user_id} after task creation")
                await query.edit_message_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                    f"–°–µ—Å—Å–∏—è –±—ã–ª–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞. –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞, –Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.\n"
                    f"Task ID: {task_id}",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Move session from user_sessions to active_generations
            # This allows multiple concurrent generations per user
            generation_key = (user_id, task_id)
            
            # Store task data for polling
            session['task_id'] = task_id
            session['poll_attempts'] = 0
            session['max_poll_attempts'] = 60  # Poll for up to 5 minutes (60 * 5 seconds)
            session['is_free_generation'] = is_free  # Store if this is a free generation
            session['model_id'] = model_id
            session['model_info'] = model_info
            session['params'] = api_params.copy()
            session['created_at'] = time.time()  # Store creation time to detect duplicates
            
            # Move to active_generations atomically
            async with active_generations_lock:
                # Double-check limit hasn't changed (another generation might have started)
                user_active_count_now = sum(1 for (uid, _) in active_generations.keys() if uid == user_id)
                if user_active_count_now >= MAX_CONCURRENT_GENERATIONS_PER_USER:
                    await query.edit_message_text(
                        f"‚ö†Ô∏è <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                        f"–ü–æ–∫–∞ —Å–æ–∑–¥–∞–≤–∞–ª–∞—Å—å –∑–∞–¥–∞—á–∞, –ª–∏–º–∏—Ç –±—ã–ª –¥–æ—Å—Ç–∏–≥–Ω—É—Ç.\n"
                        f"–£ –≤–∞—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω–æ {user_active_count_now} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n"
                        f"–ú–∞–∫—Å–∏–º—É–º: {MAX_CONCURRENT_GENERATIONS_PER_USER}.\n\n"
                        f"–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–¥–Ω–æ–π –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.",
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
                
                active_generations[generation_key] = session.copy()
                final_count = user_active_count_now + 1
            
            # Remove from user_sessions (input collection is done)
            if user_id in user_sessions:
                del user_sessions[user_id]
            
            # Show task created message with "Back to menu" button
            # User can continue working while generation runs in background
            user_lang = get_user_language(user_id)
            model_name = model_info.get('name', 'Unknown')
            
            if is_admin_user:
                message_text = (
                    f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                    f"üÜî <b>Task ID:</b> <code>{task_id}</code>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"‚è≥ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ</b>\n\n"
                    f"üìä <b>–ê–∫—Ç–∏–≤–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b> {final_count}/{MAX_CONCURRENT_GENERATIONS_PER_USER}\n\n"
                    f"üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                    f"‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ –≤ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ –º–æ–¥–µ–ª–∏\n"
                    f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –∫–æ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è\n"
                    f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                    f"‚ú® –ù–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ –±–æ—Ç–∞, –ø—Ä–æ—Ü–µ—Å—Å –∏–¥–µ—Ç!"
                )
            else:
                if user_lang == 'en':
                    message_text = (
                        f"‚úÖ <b>Task created!</b>\n\n"
                        f"Model: <b>{model_name}</b>\n\n"
                        f"‚è≥ Generation is running in the background.\n\n"
                        f"üí° You can go to the menu and try other models.\n"
                        f"The result will come automatically when generation completes."
                    )
                else:
                    message_text = (
                        f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"‚è≥ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ</b>\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                        f"‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ –≤ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ –º–æ–¥–µ–ª–∏\n"
                        f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –∫–æ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è\n"
                        f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                        f"‚ú® –ù–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ –±–æ—Ç–∞, –ø—Ä–æ—Ü–µ—Å—Å –∏–¥–µ—Ç!"
                    )
            
            # Add "Back to menu" button
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                message_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            
            # Start polling for task completion (async, non-blocking)
            # Results will be sent automatically when ready
            logger.info(f"üöÄüöÄüöÄ Starting polling for task {task_id}, user {user_id}, model {model_id}")
            asyncio.create_task(poll_task_status(update, context, task_id, user_id))
            logger.info(f"‚úÖ‚úÖ‚úÖ Polling task created for task {task_id}")
            
            # CRITICAL: Return END to allow user to work with other models
            # Generation continues in background, result will be sent when ready
            logger.info(f"‚úÖ‚úÖ‚úÖ Task created, returning END to allow user to work with other models")
            return ConversationHandler.END
        else:
            error = result.get('error', 'Unknown error')
            error_details = ""
            
            # Add more details for admin
            if is_admin_user:
                error_details = f"\n\nüìã <b>–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                try:
                    params_preview = json.dumps(api_params, indent=2, ensure_ascii=False)
                    # Limit preview length
                    if len(params_preview) > 500:
                        params_preview = params_preview[:500] + "..."
                    error_details += f"<code>{params_preview}</code>"
                except Exception as e:
                    error_details += f"<code>{str(api_params)[:500]}</code>"
                    logger.error(f"Error formatting params for error message: {e}")
            
            # Check if it's a server error
            is_server_error = any(keyword in error.lower() for keyword in ['server exception', 'please again', 'try again'])
            
            keyboard = []
            if is_server_error:
                keyboard.append([InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑", callback_data=f"retry_generate:{model_id}")])
            keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            error_msg = (
                f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏</b>\n\n"
                f"{error}\n"
                f"{error_details}\n\n"
            )
            
            if is_server_error:
                error_msg += (
                    f"‚ö†Ô∏è <b>–≠—Ç–æ –æ—à–∏–±–∫–∞ API —Å–µ—Ä–≤–µ—Ä–∞ KIE</b>\n\n"
                    f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–∂–∞—Ç—å '–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑'\n"
                    f"‚Ä¢ –ò–ª–∏ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞\n"
                    f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –≤–∞—à–µ–≥–æ –∞—É–¥–∏–æ-—Ñ–∞–π–ª–∞ –ø–æ URL"
                )
            else:
                error_msg += (
                    f"üí° <b>–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:</b>\n"
                    f"‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∑–∞–ø—Ä–æ—Å–∞\n"
                    f"‚Ä¢ –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö\n"
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑"
                )
            
            await query.edit_message_text(
                error_msg,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            # Clean up session
            if user_id in user_sessions:
                del user_sessions[user_id]
    
    except Exception as e:
        logger.error(f"Error during generation: {e}", exc_info=True)
        await query.edit_message_text(
            f"‚ùå <b>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞:</b>\n\n{str(e)}",
            parse_mode='HTML'
        )
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
    
    return ConversationHandler.END


async def poll_task_status(update: Update, context: ContextTypes.DEFAULT_TYPE, task_id: str, user_id: int):
    """Poll task status until completion."""
    max_attempts = 60  # 5 minutes max
    attempt = 0
    start_time = asyncio.get_event_loop().time()
    last_status_message = None
    
    # CRITICAL: Get chat_id from update or use user_id (for private chats, chat_id == user_id)
    chat_id = user_id
    if update and hasattr(update, 'effective_chat') and update.effective_chat:
        chat_id = update.effective_chat.id
    elif update and hasattr(update, 'message') and update.message:
        chat_id = update.message.chat_id
    elif update and hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
        chat_id = update.callback_query.message.chat_id
    
    while attempt < max_attempts:
        await asyncio.sleep(5)  # Wait 5 seconds between polls
        attempt += 1
        
        try:
            gateway = get_kie_gateway()
            status_result = await gateway.get_task_status(task_id)
            
            if not status_result.get('ok'):
                error = status_result.get('error', 'Unknown error')
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞:</b>\n\n{error}",
                    parse_mode='HTML'
                )
                # Clean up active generation on error
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        del active_generations[generation_key]
                break
            
            state = status_result.get('state')
            
            if state == 'success':
                # Send notification immediately when generation completes
                try:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=(
                            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üéâ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                            "‚è≥ <b>–ó–∞–≥—Ä—É–∂–∞—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç...</b>\n\n"
                            "üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                            "‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω –Ω–∏–∂–µ\n"
                            "‚Ä¢ –í—ã —Å–º–æ–∂–µ—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–ª–∏ –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –∏–º\n"
                            "‚Ä¢ –ú–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n\n"
                            "‚ú® –°–∫–æ—Ä–æ –≤—ã —É–≤–∏–¥–∏—Ç–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç!"
                        ) if user_lang == 'ru' else (
                            "‚úÖ <b>Generation Completed!</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üéâ <b>Result is ready!</b>\n\n"
                            "‚è≥ <b>Loading result...</b>\n\n"
                            "üí° <b>What's next:</b>\n"
                            "‚Ä¢ Result will be shown below\n"
                            "‚Ä¢ You can save or share it\n"
                            "‚Ä¢ You can create a new generation\n\n"
                            "‚ú® You'll see the created content shortly!"
                        ),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.warning(f"Could not send completion notification: {e}")
                
                # Task completed successfully - deduct balance
                # Get session data from active_generations (supports multiple concurrent generations)
                generation_key = (user_id, task_id)
                saved_session_data = None
                model_id = ''
                params = {}
                
                async with active_generations_lock:
                    if generation_key in active_generations:
                        session = active_generations[generation_key]
                        saved_session_data = {
                            'model_id': session.get('model_id'),
                            'model_info': session.get('model_info'),
                            'params': session.get('params', {}).copy(),
                            'properties': session.get('properties', {}).copy(),
                            'required': session.get('required', []).copy()
                        }
                        
                        # Get price and deduct from balance or limit
                        model_id = session.get('model_id', '')
                        params = session.get('params', {})
                        is_admin_user = get_is_admin(user_id)
                        is_free = session.get('is_free_generation', False)
                    else:
                        # Session not found - might have been cleaned up
                        logger.warning(f"Generation session not found for {generation_key}")
                        is_admin_user = get_is_admin(user_id)
                        is_free = False
                    
                    if is_free:
                        # Use free generation
                        if use_free_generation(user_id):
                            price = 0.0
                        else:
                            # Free generation limit reached, treat as paid
                            is_free = False
                            price = calculate_price_rub(model_id, params, is_admin_user)
                    else:
                        price = calculate_price_rub(model_id, params, is_admin_user)
                    
                    # DRY-RUN GUARD: –ù–µ —Å–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ
                    dry_run = is_dry_run() or not allow_real_generation()
                    
                    if user_id != ADMIN_ID and not dry_run:
                        if is_free:
                            # Free generation - no deduction needed
                            pass
                        elif is_admin_user:
                            # Limited admin - deduct from limit
                            add_admin_spent(user_id, price)
                        else:
                            # Regular user - deduct from balance
                            await subtract_user_balance_async(user_id, price)
                    elif dry_run:
                        logger.info(f"üîß DRY-RUN: Would deduct {price} from user {user_id} after successful generation (NOT DEDUCTED)")
                
                # Task completed successfully
                result_json = status_result.get('resultJson', '{}')
                last_message = None
                try:
                    result_data = json.loads(result_json)
                    
                    # Determine if this is a video model
                    is_video_model = model_id in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard', 'topaz/video-upscale', 'kling/v1-avatar-standard', 'kling/ai-avatar-v1-pro', 'infinitalk/from-audio', 'wan/2-2-a14b-speech-to-video-turbo', 'bytedance/v1-pro-fast-image-to-video', 'kling/v2-1-master-image-to-video', 'kling/v2-1-standard', 'kling/v2-1-pro', 'kling/v2-1-master-text-to-video', 'wan/2-2-a14b-text-to-video-turbo', 'wan/2-2-a14b-image-to-video-turbo']
                    
                    # For sora-2-text-to-video, check remove_watermark parameter
                    if model_id == 'sora-2-text-to-video':
                        remove_watermark = params.get('remove_watermark', True)
                        # If remove_watermark is True, use resultUrls (without watermark)
                        # If False, use resultWaterMarkUrls (with watermark)
                        if remove_watermark:
                            result_urls = result_data.get('resultUrls', [])
                        else:
                            result_urls = result_data.get('resultWaterMarkUrls', [])
                            # Fallback to resultUrls if resultWaterMarkUrls is empty
                            if not result_urls:
                                result_urls = result_data.get('resultUrls', [])
                    else:
                        # For other models, use resultUrls
                        result_urls = result_data.get('resultUrls', [])
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∫–µ—à
                    if result_urls and model_id:
                        try:
                            from optimization_results_cache import get_cache_key_for_generation, set_cached_result
                            cache_key = get_cache_key_for_generation(model_id, params)
                            set_cached_result(cache_key, {
                                'ok': True,
                                'result_urls': result_urls.copy(),
                                'model_id': model_id,
                                'params': params.copy()
                            })
                        except ImportError:
                            pass  # –ö–µ—à –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω
                    
                    # Save to history
                    if result_urls and model_id:
                        model_info = saved_session_data.get('model_info', {}) if saved_session_data else {}
                        model_name = model_info.get('name', model_id)
                        save_generation_to_history(
                            user_id=user_id,
                            model_id=model_id,
                            model_name=model_name,
                            params=params.copy(),
                            result_urls=result_urls.copy(),
                            task_id=task_id,
                            price=price,
                            is_free=is_free
                        )
                    
                    # Prepare buttons for last message
                    # Save generation data for "generate_again" button
                    if saved_session_data:
                        if user_id not in saved_generations:
                            saved_generations[user_id] = {}
                        saved_generations[user_id] = saved_session_data.copy()
                    
                    keyboard = [
                        [InlineKeyboardButton("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –µ—â–µ", callback_data="generate_again")],
                        [InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")],
                        [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    if result_urls:
                        # Send media (video or image) directly
                        session_http = await get_http_client()
                        for i, url in enumerate(result_urls[:5]):  # Limit to 5 items
                            try:
                                # Try to download media and send it
                                async with session_http.get(url) as resp:
                                        if resp.status == 200:
                                            media_data = await resp.read()
                                            
                                            # Add buttons only to the last item
                                            is_last = (i == len(result_urls[:5]) - 1)
                                            # Get model name for caption
                                            model_name_display = model_name if model_name else model_id
                                            
                                            caption = (
                                                "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                                "üéâ <b>–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name_display}\n"
                                                f"üìä <b>–†–µ–∑—É–ª—å—Ç–∞—Ç:</b> {i + 1} –∏–∑ {len(result_urls[:5])}\n\n"
                                                "üí° –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å —Å–æ–∑–¥–∞–Ω–Ω—ã–º –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º!"
                                            ) if i == 0 and user_lang == 'ru' else (
                                                "‚úÖ <b>Generation Completed!</b>\n\n"
                                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                                "üéâ <b>Your result is ready!</b>\n\n"
                                                f"ü§ñ <b>Model:</b> {model_name_display}\n"
                                                f"üìä <b>Result:</b> {i + 1} of {len(result_urls[:5])}\n\n"
                                                "üí° Enjoy your generated content!"
                                            ) if i == 0 else None
                                            
                                            if is_video_model:
                                                # Send as video
                                                video_file = io.BytesIO(media_data)
                                                video_file.name = f"generated_video_{i+1}.mp4"
                                                
                                                if is_last:
                                                    last_message = await context.bot.send_video(
                                                        chat_id=chat_id,
                                                        video=video_file,
                                                        caption=caption,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_video(
                                                        chat_id=chat_id,
                                                        video=video_file,
                                                        caption=caption,
                                                        parse_mode='HTML'
                                                    )
                                            else:
                                                # Send as image
                                                photo_file = io.BytesIO(media_data)
                                                photo_file.name = f"generated_image_{i+1}.png"
                                                
                                                if is_last:
                                                    last_message = await context.bot.send_photo(
                                                        chat_id=chat_id,
                                                        photo=photo_file,
                                                        caption=caption,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_photo(
                                                        chat_id=chat_id,
                                                        photo=photo_file,
                                                        caption=caption,
                                                        parse_mode='HTML'
                                                    )
                                        else:
                                            # If download fails, try sending URL directly
                                            if is_video_model:
                                                if i == len(result_urls[:5]) - 1:
                                                    last_message = await context.bot.send_video(
                                                        chat_id=chat_id,
                                                        video=url,
                                                        caption=(
                                                            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                                            "üéâ <b>–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                                            f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç {i + 1} –∏–∑ {len(result_urls[:5])}"
                                                        ) if i == 0 and user_lang == 'ru' else (
                                                            "‚úÖ <b>Generation Completed!</b>\n\n"
                                                            "üéâ <b>Your result is ready!</b>\n\n"
                                                            f"üìä Result {i + 1} of {len(result_urls[:5])}"
                                                        ) if i == 0 else None,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_video(
                                                        chat_id=chat_id,
                                                        video=url,
                                                        caption=(
                                                            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                                            "üéâ <b>–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                                            f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç {i + 1} –∏–∑ {len(result_urls[:5])}"
                                                        ) if i == 0 and user_lang == 'ru' else (
                                                            "‚úÖ <b>Generation Completed!</b>\n\n"
                                                            "üéâ <b>Your result is ready!</b>\n\n"
                                                            f"üìä Result {i + 1} of {len(result_urls[:5])}"
                                                        ) if i == 0 else None,
                                                        parse_mode='HTML'
                                                    )
                                            else:
                                                if i == len(result_urls[:5]) - 1:
                                                    last_message = await context.bot.send_photo(
                                                        chat_id=chat_id,
                                                        photo=url,
                                                        caption=(
                                                            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                                            "üéâ <b>–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                                            f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç {i + 1} –∏–∑ {len(result_urls[:5])}"
                                                        ) if i == 0 and user_lang == 'ru' else (
                                                            "‚úÖ <b>Generation Completed!</b>\n\n"
                                                            "üéâ <b>Your result is ready!</b>\n\n"
                                                            f"üìä Result {i + 1} of {len(result_urls[:5])}"
                                                        ) if i == 0 else None,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_photo(
                                                        chat_id=chat_id,
                                                        photo=url,
                                                        caption=(
                                                            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                                            "üéâ <b>–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                                            f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç {i + 1} –∏–∑ {len(result_urls[:5])}"
                                                        ) if i == 0 and user_lang == 'ru' else (
                                                            "‚úÖ <b>Generation Completed!</b>\n\n"
                                                            "üéâ <b>Your result is ready!</b>\n\n"
                                                            f"üìä Result {i + 1} of {len(result_urls[:5])}"
                                                        ) if i == 0 else None,
                                                        parse_mode='HTML'
                                                    )
                            except Exception as e:
                                # If all methods fail, try sending URL directly as last resort
                                media_type = "video" if is_video_model else "photo"
                                logger.warning(f"Failed to send {media_type} {url}: {e}")
                                try:
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    if is_video_model:
                                        if is_last:
                                            last_message = await context.bot.send_video(
                                                chat_id=chat_id,
                                                video=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                reply_markup=reply_markup,
                                                parse_mode='HTML'
                                            )
                                        else:
                                            await context.bot.send_video(
                                                chat_id=chat_id,
                                                video=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                parse_mode='HTML'
                                            )
                                    else:
                                        if is_last:
                                            last_message = await context.bot.send_photo(
                                                chat_id=chat_id,
                                                photo=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                reply_markup=reply_markup,
                                                parse_mode='HTML'
                                            )
                                        else:
                                            await context.bot.send_photo(
                                                chat_id=chat_id,
                                                photo=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                parse_mode='HTML'
                                            )
                                except Exception as e2:
                                    logger.error(f"Failed to send {media_type} even via URL: {e2}")
                                    # Last resort: send as message
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    media_name = "–í–∏–¥–µ–æ" if is_video_model else "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
                                    if is_last:
                                        last_message = await context.bot.send_message(
                                            chat_id=chat_id,
                                            text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n{media_name}: {url}",
                                            reply_markup=reply_markup,
                                            parse_mode='HTML'
                                        )
                                    else:
                                        await context.bot.send_message(
                                            chat_id=chat_id,
                                            text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n{media_name}: {url}",
                                            parse_mode='HTML'
                                        )
                    else:
                        last_message = await context.bot.send_message(
                            chat_id=chat_id,
                            text="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤.",
                            reply_markup=reply_markup,
                            parse_mode='HTML'
                        )
                except json.JSONDecodeError:
                    last_message = await context.bot.send_message(
                        chat_id=chat_id,
                        text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç: {result_json[:500]}",
                        reply_markup=reply_markup,
                        parse_mode='HTML'
                    )
                
                # Clean up active generation
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        del active_generations[generation_key]
                break
            
            elif state == 'fail':
                # Task failed
                fail_msg = status_result.get('failMsg', 'Unknown error')
                fail_code = status_result.get('failCode', '')
                
                # CRITICAL: Log full error details for debugging
                logger.error(f"‚ùå Task {task_id} failed: code={fail_code}, msg={fail_msg}")
                logger.error(f"‚ùå Full status_result: {json.dumps(status_result, ensure_ascii=False, indent=2)}")
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–Ω—è—Ç–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
                try:
                    from error_handler_providers import get_error_handler
                    handler = get_error_handler()
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∏–∑ model_id
                    provider_name = model_id.split('/')[0] if '/' in model_id else "Unknown"
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
                    user_message, error_details = handler.handle_provider_error(
                        provider_name=provider_name,
                        error_message=fail_msg,
                        status_code=None,
                        request_details={
                            "task_id": task_id,
                            "model_id": model_id,
                            "fail_code": fail_code
                        }
                    )
                except ImportError:
                    # Fallback –µ—Å–ª–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                    user_message = (
                        f"‚ùå <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π</b>\n\n"
                        f"–û—à–∏–±–∫–∞: {fail_msg}\n\n"
                        "–≠—Ç–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Å–µ—Ä–≤–µ—Ä–∞, –º—ã —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ–º –Ω–∞–¥ –µ—ë —Ä–µ—à–µ–Ω–∏–µ–º.\n\n"
                        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                    )
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=user_message,
                    parse_mode='HTML'
                )
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –∫–∞–∫ failed
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        session = active_generations[generation_key]
                        session['status'] = 'failed'
                        session['error'] = fail_msg
                        session['fail_code'] = fail_code
                        # –ù–µ —É–¥–∞–ª—è–µ–º —Å—Ä–∞–∑—É, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ —É–≤–∏–¥–µ—Ç—å —Å—Ç–∞—Ç—É—Å
                
                break
            
            elif state in ['waiting', 'queuing', 'generating']:
                # Still processing, continue polling
                # Don't send status updates - user can work with other models
                # Result will be sent automatically when ready
                continue
            else:
                # Unknown state
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {state}\n–ü—Ä–æ–¥–æ–ª–∂–∞—é –æ–∂–∏–¥–∞–Ω–∏–µ...",
                    parse_mode='HTML'
                )
                continue
        
        except Exception as e:
            logger.error(f"Error polling task status: {e}", exc_info=True)
            if attempt >= max_attempts:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
                    parse_mode='HTML'
                )
                # Clean up active generation on timeout/error
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        del active_generations[generation_key]
                break
            # For non-fatal errors, continue polling (don't break the loop)
            continue
    
    if attempt >= max_attempts:
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
            parse_mode='HTML'
        )
        # Clean up active generation on timeout
        generation_key = (user_id, task_id)
        async with active_generations_lock:
            if generation_key in active_generations:
                del active_generations[generation_key]


async def check_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check user balance in rubles. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è."""
    user_id = update.effective_user.id
    user_lang = get_user_language(user_id)
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞–ª–∞–Ω—Å–µ
    balance_info = await get_balance_info(user_id, user_lang)
    balance_text = await format_balance_message(balance_info, user_lang)
    keyboard = get_balance_keyboard(balance_info, user_lang)
    
    await update.message.reply_text(
        balance_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel the current operation."""
    user_id = update.effective_user.id
    
    # Handle callback query (button press)
    if update.callback_query:
        query = update.callback_query
        await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
        
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
        
        try:
            await query.edit_message_text(
                "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."
            )
        except Exception as e:
            logger.error(f"Error editing message on cancel: {e}", exc_info=True)
            try:
                await query.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
            except:
                pass
        return ConversationHandler.END
    
    # Handle command
    if update.message:
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
        
        await update.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        return ConversationHandler.END


# Keep existing handlers
async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle search queries."""
    query = ' '.join(context.args) if context.args else ''
    
    if not query:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–∞–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /search [–∑–∞–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(query)
    
    if results:
        response = f'–ù–∞–π–¥–µ–Ω–æ {len(results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç(–æ–≤) –¥–ª—è "{query}":\n\n'
        for i, result in enumerate(results[:5], 1):
            response += f'{i}. {result["content"][:100]}...\n'
    else:
        response = f'–ü–æ –∑–∞–ø—Ä–æ—Å—É "{query}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def ask(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle questions."""
    question = ' '.join(context.args) if context.args else ''
    
    if not question:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ask [–≤–æ–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(question)
    
    if results:
        response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}":\n\n'
        for i, result in enumerate(results[:3], 1):
            response += f'{i}. {result["content"]}\n\n'
    else:
        kie_model = os.getenv('KIE_DEFAULT_MODEL') or os.getenv('KIE_MODEL')
        if kie_model:
            try:
                await update.message.reply_text('ü§î –ò—â—É –æ—Ç–≤–µ—Ç...')
                kie_resp = await kie.invoke_model(kie_model, {'text': question})
                if kie_resp.get('ok'):
                    result = kie_resp.get('result')
                    if isinstance(result, dict) and 'output' in result:
                        output = result['output']
                    else:
                        output = result
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—Ç–≤–µ—Ç:\n{output}'
                else:
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞ API: {kie_resp.get("error")}'
            except Exception as e:
                response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞: {e}'
        else:
            response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def add_knowledge(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add new knowledge."""
    knowledge = ' '.join(context.args) if context.args else ''
    
    if not knowledge:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–Ω–∞–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add [–∑–Ω–∞–Ω–∏–µ]')
        return
    
    success = storage.add_entry(knowledge, update.effective_user.id)
    
    if success:
        await update.message.reply_text(f'‚úÖ –ó–Ω–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ: "{knowledge[:50]}..."')
    else:
        await update.message.reply_text('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ.')


async def pre_checkout_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle pre-checkout query for Telegram Stars payments."""
    query = update.pre_checkout_query
    user_id = query.from_user.id
    
    # Verify the payment amount matches what we expect
    # The payload format is: topup_{user_id}_{timestamp}
    payload_parts = query.invoice_payload.split('_')
    
    if len(payload_parts) >= 2 and payload_parts[0] == 'topup':
        # Extract user_id from payload to verify
        payload_user_id = int(payload_parts[1])
        
        if payload_user_id == user_id:
            # Check if user has a pending payment in session
            if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
                # Approve the pre-checkout query
                await query.answer(ok=True)
                logger.info(f"Pre-checkout approved for user {user_id}, amount: {query.total_amount} XTR")
            else:
                # Reject if no pending payment
                await query.answer(ok=False, error_message="Payment session expired. Please try again.")
                logger.warning(f"Pre-checkout rejected for user {user_id}: no pending payment")
        else:
            await query.answer(ok=False, error_message="Invalid payment request.")
            logger.warning(f"Pre-checkout rejected for user {user_id}: invalid user_id in payload")
    else:
        await query.answer(ok=False, error_message="Invalid payment payload.")
        logger.warning(f"Pre-checkout rejected for user {user_id}: invalid payload format")


async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle successful Telegram Stars payment."""
    user_id = update.effective_user.id
    payment = update.message.successful_payment
    
    user_lang = get_user_language(user_id)
    
    # Extract payment info
    payload_parts = payment.invoice_payload.split('_')
    amount_stars = payment.total_amount  # Amount in XTR (Stars)
    
    # Convert stars to rubles using exchange rate 1.6
    # 1 ruble = 1.6 stars, so 1 star = 1/1.6 rubles
    # But we use the amount from session if available (more accurate)
    if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
        # Use the amount from session (more accurate - this is the original ruble amount)
        amount_rubles = user_sessions[user_id]['topup_amount']
    else:
        # Fallback: convert stars back to rubles (1 star = 1/1.6 rubles)
        amount_rubles = float(amount_stars) / 1.6
    
    # Add balance to user
    await add_user_balance_async(user_id, amount_rubles)
    
    # Save payment operation to database (if create_operation is available)
    if create_operation:
        try:
            from decimal import Decimal
            create_operation(
                user_id=user_id,
                operation_type='payment',
                amount=Decimal(str(amount_rubles)),
                model=None,
                result_url=None,
                prompt=None
            )
            logger.info(f"‚úÖ Payment operation saved to DB: user_id={user_id}, amount={amount_rubles}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–∞ –≤ –ë–î: {e}")
    
    # Clear payment session
    if user_id in user_sessions:
        del user_sessions[user_id]
    
    # Save payment record
    # Ensure payments file exists
    if not os.path.exists(PAYMENTS_FILE):
        try:
            with open(PAYMENTS_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
            logger.info(f"Created payments file {PAYMENTS_FILE}")
        except Exception as e:
            logger.error(f"Error creating payments file {PAYMENTS_FILE}: {e}")
    
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_id = f"stars_{user_id}_{int(time.time())}"
    payments[payment_id] = {
        'user_id': user_id,
        'amount': amount_rubles,
        'currency': 'RUB',
        'payment_method': 'telegram_stars',
        'stars_amount': amount_stars,
        'timestamp': time.time(),
        'status': 'completed'
    }
    
    # Ensure directory exists
    dir_path = os.path.dirname(PAYMENTS_FILE)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)
        logger.info(f"‚úÖ Created directory for payments file: {dir_path}")
    
    # Force immediate save for payments (critical data)
    if PAYMENTS_FILE in _last_save_time:
        del _last_save_time[PAYMENTS_FILE]
    save_json_file(PAYMENTS_FILE, payments, use_cache=True)
    
    # Verify payment was saved (with retry)
    max_retries = 3
    for retry in range(max_retries):
        if os.path.exists(PAYMENTS_FILE):
            verify_payments = load_json_file(PAYMENTS_FILE, {})
            if payment_id in verify_payments:
                logger.info(f"‚úÖ Saved Stars payment: user_id={user_id}, amount={amount_rubles}, payment_id={payment_id}")
                break
            elif retry < max_retries - 1:
                logger.warning(f"‚ö†Ô∏è Retry {retry + 1}/{max_retries}: Payment verification failed, retrying save...")
                save_json_file(PAYMENTS_FILE, payments, use_cache=False)
                time.sleep(0.1)  # Small delay before retry
            else:
                logger.error(f"‚ùå Stars payment saved but not found in file after {max_retries} retries! payment_id={payment_id}")
        elif retry < max_retries - 1:
            logger.warning(f"‚ö†Ô∏è Retry {retry + 1}/{max_retries}: Payment file not found, retrying save...")
            save_json_file(PAYMENTS_FILE, payments, use_cache=False)
            time.sleep(0.1)  # Small delay before retry
        else:
            logger.error(f"‚ùå Failed to save Stars payment file after {max_retries} retries: {PAYMENTS_FILE} does not exist after save!")
    
    # Send confirmation message
    balance_str = f"{await get_user_balance_async(user_id):.2f}".rstrip('0').rstrip('.')
    
    if user_lang == 'ru':
        success_text = (
            f'{t("msg_payment_success", lang=user_lang)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_added", lang=user_lang, amount=amount_rubles)}\n'
            f'{t("msg_payment_method", lang=user_lang, stars=amount_stars)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_balance", lang=user_lang, balance=balance_str)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_use_funds", lang=user_lang)}'
        )
    else:
        success_text = (
            f'{t("msg_payment_success", lang=user_lang)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_added", lang=user_lang, amount=amount_rubles)}\n'
            f'{t("msg_payment_method", lang=user_lang, stars=amount_stars)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_balance", lang=user_lang, balance=balance_str)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_use_funds", lang=user_lang)}'
        )
    
    keyboard = [
        [InlineKeyboardButton(t('btn_check_balance', lang=user_lang), callback_data="check_balance")],
        [InlineKeyboardButton(t('btn_start_generation', lang=user_lang), callback_data="show_models")],
        [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
    ]
    
    await update.message.reply_text(
        success_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )
    
    logger.info(f"Successful Stars payment for user {user_id}: {amount_rubles} RUB ({amount_stars} stars)")


def initialize_data_files():
    """Initialize all data files if they don't exist."""
    # Log data directory location
    logger.info(f"üìÅ Data directory: {DATA_DIR} (from DATA_DIR env var or default)")
    logger.info(f"üìÅ Data directory exists: {os.path.exists(DATA_DIR)}")
    logger.info(f"üìÅ Data directory writable: {os.access(DATA_DIR if DATA_DIR != '.' else '.', os.W_OK)}")
    
    data_files = [
        BALANCES_FILE,
        USER_LANGUAGES_FILE,
        GIFT_CLAIMED_FILE,
        ADMIN_LIMITS_FILE,
        PAYMENTS_FILE,
        BLOCKED_USERS_FILE,
        FREE_GENERATIONS_FILE,
        PROMOCODES_FILE,
        CURRENCY_RATE_FILE,
        REFERRALS_FILE,
        BROADCASTS_FILE,
        GENERATIONS_HISTORY_FILE
    ]
    
    created_count = 0
    for filename in data_files:
        if not os.path.exists(filename):
            try:
                # Ensure directory exists
                dir_path = os.path.dirname(filename)
                if dir_path and not os.path.exists(dir_path):
                    os.makedirs(dir_path, exist_ok=True)
                
                # Create empty JSON file
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump({}, f, ensure_ascii=False, indent=2)
                logger.info(f"‚úÖ Created data file: {filename}")
                created_count += 1
            except Exception as e:
                logger.error(f"‚ùå Failed to create {filename}: {e}", exc_info=True)
        else:
            file_size = os.path.getsize(filename)
            logger.info(f"‚úì Data file exists: {filename} ({file_size} bytes)")
    
    if created_count > 0:
        logger.info(f"‚úÖ Initialized {created_count} new data files")
    else:
        logger.info("‚úÖ All data files already exist")
    
    # Log critical files status
    critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE]
    for critical_file in critical_files:
        if os.path.exists(critical_file):
            file_size = os.path.getsize(critical_file)
            logger.info(f"üîí Critical file: {critical_file} ({file_size} bytes)")
        else:
            logger.warning(f"‚ö†Ô∏è Critical file missing: {critical_file}")
    
    # Also initialize knowledge store
    try:
        storage = KnowledgeStorage()
        storage.ensure_storage_exists()
        logger.info("‚úÖ Knowledge store initialized")
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize knowledge store: {e}")


    # ==================== SINGLE INSTANCE LOCK ====================
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –µ–¥–∏–Ω—ã–π –º–æ–¥—É–ª—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è 409 Conflict
    from app.locking.single_instance import (
        acquire_single_instance_lock,
        release_single_instance_lock,
        is_lock_held,
    )
    
    logger.info("üîí Acquiring single instance lock...")
    if not acquire_single_instance_lock():
        logger.error("‚ùå‚ùå‚ùå Failed to acquire single instance lock!")
        logger.error("   Another bot instance is already running")
        logger.error("   Exiting gracefully (exit code 0) to prevent restart loop")
        sys.exit(0)
    
    logger.info("‚úÖ Single instance lock acquired - this is the leader instance")
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ lock –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
    import atexit
    def release_lock_on_exit():
        try:
            release_single_instance_lock()
        except Exception as e:
            logger.error(f"Error releasing lock on exit: {e}")
    atexit.register(release_lock_on_exit)


async def create_bot_application(settings) -> Application:
    """
    –°–æ–∑–¥–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç Telegram Application —Å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ handlers.
    –ù–ï –∑–∞–ø—É—Å–∫–∞–µ—Ç polling/webhook - —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç application.
    
    Args:
        settings: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ app.config.Settings
        
    Returns:
        Application —Å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ handlers
    """
    # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º Settings –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞
    from app.config import Settings
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø settings (–º–æ–∂–µ—Ç –±—ã—Ç—å Settings –∏–ª–∏ dict)
    if not isinstance(settings, Settings):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω dict, —Å–æ–∑–¥–∞–µ–º Settings –∏–∑ –Ω–µ–≥–æ
        if isinstance(settings, dict):
            from app.config import get_settings
            settings = get_settings(validate=False)
        else:
            raise TypeError(f"settings must be Settings or dict, got {type(settings)}")
    
    if not settings.telegram_bot_token:
        raise ValueError("telegram_bot_token is required in settings")
    
    # Verify models are loaded correctly (using registry)
    from app.models.registry import get_models_sync, get_model_registry
    models_list = get_models_sync()
    registry_info = get_model_registry()
    
    categories = get_categories_from_registry()
    
    # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ registry
    logger.info(f"üìä models_registry source={registry_info['used_source']} count={registry_info['count']}")
    if registry_info.get('yaml_total_models'):
        logger.info(f"üìä YAML total_models={registry_info['yaml_total_models']}")
    
    logger.info(f"Creating application with {len(models_list)} models in {len(categories)} categories: {categories}")
    
    # Create the Application —á–µ—Ä–µ–∑ bootstrap (—Å dependency container)
    from app.bootstrap import create_application
    application = await create_application(settings)
    
    # –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    # TODO: –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ handlers
    global storage, kie
    deps = application.bot_data["deps"]
    storage = deps.get_storage()
    kie = deps.get_kie_client()
    
    # ==================== NO-SILENCE GUARD ====================
    from app.observability.no_silence_guard import get_no_silence_guard
    no_silence_guard = get_no_silence_guard()
    logger.info("‚úÖ NO-SILENCE GUARD: Integrated in button_callback, input_parameters, error_handler")
    
    # ==================== PASSIVE MODE MIDDLEWARE ====================
    # Add passive mode middleware BEFORE exception middleware to handle PASSIVE UX
    from bot.middleware.passive_mode_middleware import PassiveModeMiddleware
    passive_middleware = PassiveModeMiddleware()
    application.middleware.setup(passive_middleware)
    logger.info("‚úÖ PASSIVE MODE MIDDLEWARE: Registered to provide UX feedback during deploy overlap")
    
    # ==================== EXCEPTION MIDDLEWARE ====================
    # Add exception middleware FIRST (before handlers) to catch all unhandled exceptions
    from bot.middleware.exception_middleware import ExceptionMiddleware
    exception_middleware = ExceptionMiddleware()
    application.middleware.setup(exception_middleware)
    logger.info("‚úÖ EXCEPTION MIDDLEWARE: Registered to catch all unhandled exceptions")
    
    # –í—ã–∑—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ handlers
    # (—Å–º. _register_all_handlers_internal –Ω–∏–∂–µ –≤ main())
    await _register_all_handlers_internal(application)
    
    logger.info("‚úÖ Application created with all handlers registered")
    return application


async def _register_all_handlers_internal(application: Application):
    """
    –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—Å–µ—Ö handlers.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –≤ create_bot_application, –∏ –≤ main().
    """
    # Create conversation handler for generation
    generation_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(button_callback, pattern='^show_models$'),
            CallbackQueryHandler(button_callback, pattern='^show_all_models_list$'),
            CallbackQueryHandler(button_callback, pattern='^category:'),
            CallbackQueryHandler(button_callback, pattern='^all_models$'),
            CallbackQueryHandler(button_callback, pattern='^gen_type:'),
            CallbackQueryHandler(button_callback, pattern='^free_tools$'),
            CallbackQueryHandler(button_callback, pattern='^check_balance$'),
            CallbackQueryHandler(button_callback, pattern='^language_select:'),
            CallbackQueryHandler(button_callback, pattern='^change_language$'),
            CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
            CallbackQueryHandler(button_callback, pattern='^claim_gift$'),
            CallbackQueryHandler(button_callback, pattern='^help_menu$'),
            CallbackQueryHandler(button_callback, pattern='^support_contact$'),
            CallbackQueryHandler(button_callback, pattern='^select_model:'),
            CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
            CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
            CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
            CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
            CallbackQueryHandler(button_callback, pattern='^admin_set_currency_rate$'),
            CallbackQueryHandler(button_callback, pattern='^admin_search$'),
            CallbackQueryHandler(button_callback, pattern='^admin_add$'),
            CallbackQueryHandler(button_callback, pattern='^view_payment_screenshots$'),
            CallbackQueryHandler(button_callback, pattern='^payment_screenshot_nav:'),
            CallbackQueryHandler(button_callback, pattern='^admin_payments_back$'),
            CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
            CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
            CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
            CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
            CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
            CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
            CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
            CallbackQueryHandler(button_callback, pattern='^referral_info$'),
            CallbackQueryHandler(button_callback, pattern='^generate_again$'),
            CallbackQueryHandler(button_callback, pattern='^my_generations$'),
            CallbackQueryHandler(button_callback, pattern='^gen_view:'),
            CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
            CallbackQueryHandler(button_callback, pattern='^gen_history:'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_complete$')
        ],
        states={
            SELECTING_MODEL: [
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^show_models$'),
                CallbackQueryHandler(button_callback, pattern='^show_all_models_list$'),
                CallbackQueryHandler(button_callback, pattern='^category:'),
                CallbackQueryHandler(button_callback, pattern='^all_models$'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^free_tools$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^cancel$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_previous_step$')
            ],
            CONFIRMING_GENERATION: [
                CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
                CallbackQueryHandler(button_callback, pattern='^retry_generate:'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^cancel$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_previous_step$')
            ],
            INPUTTING_PARAMS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.Document.ALL, input_parameters),
                MessageHandler(filters.AUDIO | filters.VOICE, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^cancel$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_previous_step$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$')
            ]
        },
        fallbacks=[CallbackQueryHandler(button_callback, pattern='^cancel$'),
                   CommandHandler('cancel', cancel)]
        # REMOVED per_message=True - it can cause unexpected behavior with message context
    )
    
    # NOTE: –ü–æ–ª–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è handlers –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ main() –Ω–∞—á–∏–Ω–∞—è —Å–æ —Å—Ç—Ä–æ–∫–∏ ~25292
    # –ó–¥–µ—Å—å –º—ã —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ handlers, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ main()
    # –î–ª—è –ø–æ–ª–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –ø–æ–ª–Ω—É—é —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∏–∑ main()
    # –ù–æ –¥–ª—è create_bot_application –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∑–æ–≤–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º error handler (–Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –µ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ)
    # application.add_error_handler(error_handler) - –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ main()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º generation_handler
    application.add_handler(generation_handler)
    
    # –ë–∞–∑–æ–≤—ã–µ command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("balance", check_balance))
    application.add_handler(CommandHandler("cancel", cancel))
    application.add_handler(CommandHandler('generate', start_generation))
    application.add_handler(CommandHandler('models', list_models))
    
    # –ë–∞–∑–æ–≤—ã–µ callback handlers
    application.add_handler(CallbackQueryHandler(button_callback))
    
    logger.info("‚úÖ Basic handlers registered (full registration happens in main())")


async def main():
    """Start the bot."""
    global storage, kie
    
    # ==================== –ù–ê–ß–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê ====================
    logger.info("=" * 60)
    logger.info("üöÄ Starting KIE Telegram Bot")
    logger.info("=" * 60)
    logger.info(f"üì¶ Python version: {sys.version}")
    logger.info(f"üìÅ Working directory: {os.getcwd()}")
    logger.info(f"üÜî Process ID: {os.getpid()}")
    logger.info(f"üåç Platform: {platform.system()} {platform.release()}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
    bot_token_set = bool(BOT_TOKEN)
    kie_api_key_set = bool(os.getenv('KIE_API_KEY'))
    database_url_set = bool(os.getenv('DATABASE_URL'))
    
    logger.info(f"üîë BOT_TOKEN: {'‚úÖ Set' if bot_token_set else '‚ùå NOT SET'}")
    logger.info(f"üîë KIE_API_KEY: {'‚úÖ Set' if kie_api_key_set else '‚ùå NOT SET'}")
    logger.info(f"üóÑÔ∏è DATABASE_URL: {'‚úÖ Set' if database_url_set else '‚ö†Ô∏è Not set (using JSON storage)'}")
    
    if not bot_token_set:
        logger.error("‚ùå‚ùå‚ùå CRITICAL: TELEGRAM_BOT_TOKEN is not set!")
        logger.error("   Bot cannot start without a valid token.")
        logger.error("   Set TELEGRAM_BOT_TOKEN in Render Dashboard ‚Üí Environment")
        sys.exit(1)
    
    if not kie_api_key_set:
        logger.warning("‚ö†Ô∏è KIE_API_KEY is not set - KIE AI features will not work")
    
    logger.info("=" * 60)
    
    # ==================== SINGLE INSTANCE LOCK ====================
    # Lock —É–∂–µ –ø–æ–ª—É—á–µ–Ω –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ app.locking.single_instance
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ lock –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
    from app.locking.single_instance import is_lock_held
    if not is_lock_held():
        logger.error("‚ùå‚ùå‚ùå CRITICAL: Single instance lock is not held!")
        logger.error("   This should not happen - lock should be acquired at module level")
        logger.error("   Exiting to prevent 409 Conflict...")
        sys.exit(1)
    
    logger.info("‚úÖ Single instance lock verified - proceeding with bot initialization")
    
    # CRITICAL: Ensure data directory exists and is writable before anything else
    logger.info("üîí Ensuring data persistence...")
    if not os.path.exists(DATA_DIR):
        try:
            os.makedirs(DATA_DIR, exist_ok=True)
            logger.info(f"‚úÖ Created data directory: {DATA_DIR}")
        except Exception as e:
            logger.error(f"‚ùå CRITICAL: Failed to create data directory {DATA_DIR}: {e}")
            logger.error("‚ùå Data will NOT persist between deploys!")
    
    # Verify write access
    if not os.access(DATA_DIR if DATA_DIR != '.' else '.', os.W_OK):
        logger.error(f"‚ùå CRITICAL: Data directory {DATA_DIR} is NOT writable!")
        logger.error("‚ùå Data will NOT persist between deploys!")
    else:
        logger.info(f"‚úÖ Data directory {DATA_DIR} is writable")
    
    # Storage initialization is handled by app.storage.factory (already initialized above)
    
    # Initialize all data files first (for JSON fallback)
    logger.info("üîß Initializing data files...")
    initialize_data_files()
    
    # Final verification of critical files (for JSON fallback)
    logger.info("üîí Verifying critical data files...")
    critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE, GIFT_CLAIMED_FILE]
    all_critical_ok = True
    for critical_file in critical_files:
        if os.path.exists(critical_file):
            file_size = os.path.getsize(critical_file)
            if file_size > 0:
                logger.info(f"‚úÖ Critical file OK: {critical_file} ({file_size} bytes)")
            else:
                logger.warning(f"‚ö†Ô∏è Critical file is empty: {critical_file}")
                all_critical_ok = False
        else:
            logger.warning(f"‚ö†Ô∏è Critical file missing: {critical_file}")
            all_critical_ok = False
    
    if all_critical_ok:
        logger.info("‚úÖ All critical data files verified and ready (JSON storage)")
    else:
        logger.warning("‚ö†Ô∏è Some critical files need attention, but bot will continue")
    
    # NOTE: Health check server –¥–ª—è Render
    # –ï—Å–ª–∏ –Ω—É–∂–µ–Ω health check endpoint, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –∫–æ–¥ –Ω–∏–∂–µ
    # –í–ê–ñ–ù–û: –≠—Ç–æ Python –ø—Ä–æ–µ–∫—Ç, –ù–ï Node.js! –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ index.js!
    #
    # import threading
    # from http.server import HTTPServer, BaseHTTPRequestHandler
    # 
    # class HealthCheckHandler(BaseHTTPRequestHandler):
    #     def do_GET(self):
    #         if self.path == '/health' or self.path == '/':
    #             self.send_response(200)
    #             self.send_header('Content-type', 'application/json')
    #             self.end_headers()
    #             self.wfile.write(b'{"status":"ok","service":"telegram-bot"}')
    #         else:
    #             self.send_response(404)
    #             self.end_headers()
    #     
    #     def log_message(self, format, *args):
    #         pass  # Suppress HTTP server logs
    # 
    # def start_health_server():
    #     port = int(os.getenv('PORT', 10000))
    #     try:
    #         server = HTTPServer(('0.0.0.0', port), HealthCheckHandler)
    #         logger.info(f"‚úÖ Health check server started on port {port}")
    #         server.serve_forever()
    #     except Exception as e:
    #         logger.error(f"‚ùå Failed to start health server: {e}")
    #         import traceback
    #         traceback.print_exc()
    # 
    # health_thread = threading.Thread(target=start_health_server, daemon=True)
    # health_thread.start()
    # logger.info("üöÄ Health check server thread started")
    # time.sleep(2)
    
    logger.info("‚úÖ Bot initialization complete (Python only, no Node.js needed)")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ bootstrap (dependency container)
    # –ù–ï –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º storage/kie –∫–∞–∫ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º dependency container
    from app.config import get_settings
    
    settings = get_settings()
    
    if not settings.telegram_bot_token:
        logger.error("No TELEGRAM_BOT_TOKEN found in environment variables!")
        return
    
    # Verify models are loaded correctly (using registry)
    from app.models.registry import get_models_sync, get_model_registry
    models_list = get_models_sync()
    registry_info = get_model_registry()
    
    categories = get_categories_from_registry()
    sora_models = [m for m in models_list if m.get('id') == 'sora-watermark-remover']
    
    # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ registry (source, count)
    logger.info(f"üìä models_registry source={registry_info['used_source']} count={registry_info['count']}")
    if registry_info.get('yaml_total_models'):
        logger.info(f"üìä YAML total_models={registry_info['yaml_total_models']}")
    
    logger.info(f"Bot starting with {len(models_list)} models in {len(categories)} categories: {categories}")
    if sora_models:
        logger.info(f"[OK] Sora model loaded: {sora_models[0].get('name', 'unknown')} ({sora_models[0].get('category', 'unknown')})")
    else:
        logger.warning(f"[WARN] Sora model NOT found! Available models: {[m.get('id') for m in models_list[:10]]}")
    
    # Create the Application —á–µ—Ä–µ–∑ bootstrap (—Å dependency container)
    from app.bootstrap import create_application
    application = await create_application(settings)
    
    # –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    # TODO: –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ handlers
    global storage, kie
    deps = application.bot_data["deps"]
    storage = deps.get_storage()
    kie = deps.get_kie_client()
    
    # ==================== NO-SILENCE GUARD (–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ò–ù–í–ê–†–ò–ê–ù–¢) ====================
    # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –∫–∞–∂–¥—ã–π –≤—Ö–æ–¥—è—â–∏–π update
    # NO-SILENCE GUARD —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —á–µ—Ä–µ–∑:
    # 1. app/observability/no_silence_guard.py - middleware –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è outgoing actions
    # 2. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ button_callback - –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç query.answer() –∏ –≤—Å–µ send/edit
    # 3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ input_parameters - –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç reply_text –∏ –≤—Å–µ send/edit
    # 4. –£–ª—É—á—à–µ–Ω–Ω—ã–π error_handler - –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç fallback –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
    # 5. –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –≤ button_callback (–≤—Å–µ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç query.answer())
    # 6. –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –≤ input_parameters (–æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
    from app.observability.no_silence_guard import get_no_silence_guard
    no_silence_guard = get_no_silence_guard()
    logger.info("‚úÖ NO-SILENCE GUARD: Integrated in button_callback, input_parameters, error_handler")
    # ==================== END NO-SILENCE GUARD ====================
    
    # Create conversation handler for generation
    # Note: per_message=True requires all entry points to be CallbackQueryHandler
    # So we handle commands separately and use only callbacks for conversation
    generation_handler = ConversationHandler(
        entry_points=[
            # Only CallbackQueryHandler for per_message=True
            CallbackQueryHandler(button_callback, pattern='^show_models$'),
            CallbackQueryHandler(button_callback, pattern='^show_all_models_list$'),
            CallbackQueryHandler(button_callback, pattern='^category:'),
            CallbackQueryHandler(button_callback, pattern='^all_models$'),
            CallbackQueryHandler(button_callback, pattern='^gen_type:'),
            CallbackQueryHandler(button_callback, pattern='^free_tools$'),
            CallbackQueryHandler(button_callback, pattern='^check_balance$'),
            CallbackQueryHandler(button_callback, pattern='^language_select:'),
            CallbackQueryHandler(button_callback, pattern='^change_language$'),
            CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
            CallbackQueryHandler(button_callback, pattern='^claim_gift$'),
            CallbackQueryHandler(button_callback, pattern='^help_menu$'),
            CallbackQueryHandler(button_callback, pattern='^support_contact$'),
            CallbackQueryHandler(button_callback, pattern='^select_model:'),
            CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
            CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
            CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
            CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
            CallbackQueryHandler(button_callback, pattern='^admin_set_currency_rate$'),
            CallbackQueryHandler(button_callback, pattern='^admin_search$'),
            CallbackQueryHandler(button_callback, pattern='^admin_add$'),
            CallbackQueryHandler(button_callback, pattern='^view_payment_screenshots$'),
            CallbackQueryHandler(button_callback, pattern='^payment_screenshot_nav:'),
            CallbackQueryHandler(button_callback, pattern='^admin_payments_back$'),
            CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
            CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
            CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
            CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
            CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
            CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
            CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
            CallbackQueryHandler(button_callback, pattern='^referral_info$'),
            CallbackQueryHandler(button_callback, pattern='^generate_again$'),
            CallbackQueryHandler(button_callback, pattern='^my_generations$'),
            CallbackQueryHandler(button_callback, pattern='^gen_view:'),
            CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
            CallbackQueryHandler(button_callback, pattern='^gen_history:'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_complete$')
        ],
        states={
            SELECTING_MODEL: [
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^show_models$'),
                CallbackQueryHandler(button_callback, pattern='^show_all_models_list$'),
                CallbackQueryHandler(button_callback, pattern='^category:'),
                CallbackQueryHandler(button_callback, pattern='^all_models$'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^free_tools$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^cancel$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_previous_step$')
            ],
            CONFIRMING_GENERATION: [
                CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
                CallbackQueryHandler(button_callback, pattern='^retry_generate:'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_previous_step$')
            ],
            INPUTTING_PARAMS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")), input_parameters),
                CallbackQueryHandler(button_callback, pattern='^set_param:'),
                CallbackQueryHandler(button_callback, pattern='^add_image$'),
                CallbackQueryHandler(button_callback, pattern='^skip_image$'),
                CallbackQueryHandler(button_callback, pattern='^image_done$'),
                CallbackQueryHandler(button_callback, pattern='^add_audio$'),
                CallbackQueryHandler(button_callback, pattern='^skip_audio$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            SELECTING_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^pay_stars:'),
                CallbackQueryHandler(button_callback, pattern='^pay_sbp:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^claim_gift$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            WAITING_PAYMENT_SCREENSHOT: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            ADMIN_TEST_OCR: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            WAITING_BROADCAST_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
            ],
            WAITING_CURRENCY_RATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^change_language$'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ]
        },
        fallbacks=[
            CallbackQueryHandler(cancel, pattern='^cancel$'),
            CommandHandler('cancel', cancel)
        ]
        # REMOVED per_message=True - it prevents MessageHandler from working!
        # per_message=True requires ALL handlers to be CallbackQueryHandler, which breaks photo/audio handling
    )
    
    # ==================== PHASE 1: GLOBAL INPUT ROUTERS (BEFORE ConversationHandler) ====================
    # These routers catch TEXT/PHOTO/AUDIO OUTSIDE conversation and route to input_parameters if waiting_for exists
    # This ensures NO SILENCE even if ConversationHandler doesn't catch the message
    
    async def global_text_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Global router for TEXT messages - routes to input_parameters if waiting_for exists"""
        from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
        guard = get_no_silence_guard()
        update_id = update.update_id
        user_id = update.effective_user.id if update.effective_user else None
        
        # Instant ACK before processing
        try:
            await update.message.reply_text("‚è≥ –ü—Ä–∏–Ω—è—Ç–æ. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é‚Ä¶", parse_mode='HTML')
            track_outgoing_action(update_id)
        except Exception as e:
            logger.warning(f"Could not send instant ACK: {e}")
        
        # Check if user has active session with waiting_for
        if user_id and user_id in user_sessions:
            session = user_sessions[user_id]
            waiting_for = session.get('waiting_for')
            if waiting_for:
                # Route to input_parameters
                logger.info(f"üîÄ GLOBAL_TEXT_ROUTER: Routing to input_parameters (waiting_for={waiting_for})")
                return await input_parameters(update, context)
        
        # No waiting_for - show main menu
        logger.info(f"üîÄ GLOBAL_TEXT_ROUTER: No waiting_for, showing main menu")
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            keyboard = build_main_menu_keyboard(user_id, user_lang)
            await update.message.reply_text(
                "‚ùå <b>–Ø –Ω–µ –∂–¥—É —Ç–µ–∫—Å—Ç —Å–µ–π—á–∞—Å</b>\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n"
                "‚Ä¢ –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è",
                reply_markup=keyboard,
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)
        except Exception as e:
            logger.error(f"Error in global_text_router fallback: {e}", exc_info=True)
            await guard.check_and_ensure_response(update, context)
    
    async def global_photo_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Global router for PHOTO messages - routes to input_parameters if waiting_for expects image"""
        from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
        guard = get_no_silence_guard()
        update_id = update.update_id
        user_id = update.effective_user.id if update.effective_user else None
        
        # Instant ACK before processing
        try:
            await update.message.reply_text("‚è≥ –ü—Ä–∏–Ω—è—Ç–æ. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ‚Ä¶", parse_mode='HTML')
            track_outgoing_action(update_id)
        except Exception as e:
            logger.warning(f"Could not send instant ACK: {e}")
        
        # Check if user has active session expecting image
        if user_id and user_id in user_sessions:
            session = user_sessions[user_id]
            waiting_for = session.get('waiting_for')
            current_param = session.get('current_param', waiting_for)
            # Check if waiting for image-related parameter
            if waiting_for and current_param in ['image_input', 'image_urls', 'mask_input', 'reference_image_input']:
                logger.info(f"üîÄ GLOBAL_PHOTO_ROUTER: Routing to input_parameters (waiting_for={waiting_for})")
                return await input_parameters(update, context)
        
        # Not expecting photo - show guidance
        logger.info(f"üîÄ GLOBAL_PHOTO_ROUTER: Not expecting photo, showing guidance")
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            keyboard = build_main_menu_keyboard(user_id, user_lang)
            await update.message.reply_text(
                "‚ùå <b>–Ø –Ω–µ –∂–¥—É —Ñ–æ—Ç–æ —Å–µ–π—á–∞—Å</b>\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n"
                "‚Ä¢ –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è",
                reply_markup=keyboard,
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)
        except Exception as e:
            logger.error(f"Error in global_photo_router fallback: {e}", exc_info=True)
            await guard.check_and_ensure_response(update, context)
    
    async def global_audio_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Global router for AUDIO/VOICE messages - routes to input_parameters if waiting_for expects audio"""
        from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
        guard = get_no_silence_guard()
        update_id = update.update_id
        user_id = update.effective_user.id if update.effective_user else None
        
        # Instant ACK before processing
        try:
            await update.message.reply_text("‚è≥ –ü—Ä–∏–Ω—è—Ç–æ. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ‚Ä¶", parse_mode='HTML')
            track_outgoing_action(update_id)
        except Exception as e:
            logger.warning(f"Could not send instant ACK: {e}")
        
        # Check if user has active session expecting audio
        if user_id and user_id in user_sessions:
            session = user_sessions[user_id]
            waiting_for = session.get('waiting_for')
            current_param = session.get('current_param', waiting_for)
            # Check if waiting for audio-related parameter
            if waiting_for and current_param in ['audio_url', 'audio_input']:
                logger.info(f"üîÄ GLOBAL_AUDIO_ROUTER: Routing to input_parameters (waiting_for={waiting_for})")
                return await input_parameters(update, context)
        
        # Not expecting audio - show guidance
        logger.info(f"üîÄ GLOBAL_AUDIO_ROUTER: Not expecting audio, showing guidance")
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            keyboard = build_main_menu_keyboard(user_id, user_lang)
            await update.message.reply_text(
                "‚ùå <b>–Ø –Ω–µ –∂–¥—É –∞—É–¥–∏–æ —Å–µ–π—á–∞—Å</b>\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n"
                "‚Ä¢ –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è",
                reply_markup=keyboard,
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)
        except Exception as e:
            logger.error(f"Error in global_audio_router fallback: {e}", exc_info=True)
            await guard.check_and_ensure_response(update, context)
    
    # Add global routers BEFORE ConversationHandler (higher priority)
    # These catch messages even if ConversationHandler doesn't
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, global_text_router), group=-1)
    application.add_handler(MessageHandler(filters.PHOTO, global_photo_router), group=-1)
    application.add_handler(MessageHandler(filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")), global_audio_router), group=-1)
    # ==================== END PHASE 1: GLOBAL INPUT ROUTERS ====================
    
    # Add command handlers separately (not in conversation, as per_message=True requires only CallbackQueryHandler)
    application.add_handler(CommandHandler('generate', start_generation))
    application.add_handler(CommandHandler('models', list_models))
    application.add_handler(CommandHandler('cancel', cancel))
    
    # Add handlers
    # Admin commands
    async def show_admin_payments(update_or_query, context: ContextTypes.DEFAULT_TYPE, is_callback: bool = False):
        """Show all payments (admin only). Can be called from command or callback."""
        # Determine if it's a callback query or message
        if is_callback:
            query = update_or_query
            user_id = query.from_user.id
            message_func = query.edit_message_text
        else:
            update = update_or_query
            user_id = update.effective_user.id
            message_func = update.message.reply_text
        
        if user_id != ADMIN_ID:
            if is_callback:
                await query.answer("‚ùå –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", show_alert=True)
            else:
                await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        stats = get_payment_stats()
        payments = stats['payments']
        
        if not payments:
            await message_func("üìä <b>–ü–ª–∞—Ç–µ–∂–∏</b>\n\n–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π.", parse_mode='HTML')
            return
        
        # Show last 10 payments
        total_amount = stats['total_amount']
        total_count = stats['total_count']
        total_str = f"{total_amount:.2f}".rstrip('0').rstrip('.')
        
        text = f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π:</b>\n\n"
        text += f"üí∞ <b>–í—Å–µ–≥–æ:</b> {total_str} ‚ÇΩ\n"
        text += f"üìù <b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b> {total_count}\n\n"
        text += f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∏:</b>\n\n"
        
        import datetime
        payments_with_screenshots = 0
        for payment in payments[:10]:
            user_id_payment = payment.get('user_id', 0)
            amount = payment.get('amount', 0)
            timestamp = payment.get('timestamp', 0)
            amount_str = f"{amount:.2f}".rstrip('0').rstrip('.')
            
            if timestamp:
                dt = datetime.datetime.fromtimestamp(timestamp)
                date_str = dt.strftime("%d.%m.%Y %H:%M")
            else:
                date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            
            # Create user link: tg://user?id=USER_ID
            user_link = f"tg://user?id={user_id_payment}"
            text += f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id_payment}</a> | üíµ {amount_str} ‚ÇΩ | üìÖ {date_str}\n"
            
            if payment.get('screenshot_file_id'):
                payments_with_screenshots += 1
        
        if total_count > 10:
            text += f"\n... –∏ –µ—â–µ {total_count - 10} –ø–ª–∞—Ç–µ–∂–µ–π"
        
        # Count total payments with screenshots
        total_with_screenshots = sum(1 for p in payments if p.get('screenshot_file_id'))
        
        # Add button to view screenshots
        keyboard = []
        if total_with_screenshots > 0:
            keyboard.append([InlineKeyboardButton("üì∏ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤", callback_data="view_payment_screenshots")])
        
        reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
        
        await message_func(text, parse_mode='HTML', reply_markup=reply_markup)
    
    async def admin_payments(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show all payments (admin only)."""
        await show_admin_payments(update, context, is_callback=False)
    
    async def admin_block_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Block a user (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /block_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            block_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_unblock_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Unblock a user (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unblock_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            unblock_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_user_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Check user balance (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /user_balance [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            balance = await get_user_balance_async(user_id)
            balance_str = f"{balance:.2f}".rstrip('0').rstrip('.')
            is_blocked = is_user_blocked(user_id)
            blocked_text = "üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω" if is_blocked else "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω"
            
            # Get user payments
            user_payments = get_user_payments(user_id)
            total_paid = sum(p.get('amount', 0) for p in user_payments)
            total_paid_str = f"{total_paid:.2f}".rstrip('0').rstrip('.')
            
            # Check if user is limited admin
            admin_info = ""
            if is_admin(user_id) and user_id != ADMIN_ID:
                limit = get_admin_limit(user_id)
                spent = get_admin_spent(user_id)
                remaining = get_admin_remaining(user_id)
                admin_info = (
                    f"\nüëë <b>–ê–¥–º–∏–Ω —Å –ª–∏–º–∏—Ç–æ–º:</b>\n"
                    f"üí≥ –õ–∏–º–∏—Ç: {limit:.2f} ‚ÇΩ\n"
                    f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: {spent:.2f} ‚ÇΩ\n"
                    f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: {remaining:.2f} ‚ÇΩ"
                )
            
            text = (
                f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user_id}\n"
                f"üí∞ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                f"üíµ <b>–í—Å–µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–æ:</b> {total_paid_str} ‚ÇΩ\n"
                f"üìù <b>–ü–ª–∞—Ç–µ–∂–µ–π:</b> {len(user_payments)}\n"
                f"üîê <b>–°—Ç–∞—Ç—É—Å:</b> {blocked_text}"
                f"{admin_info}"
            )
            
            await update.message.reply_text(text, parse_mode='HTML')
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Add admin with 100 rubles limit (main admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_admin [user_id]\n\n–î–æ–±–∞–≤–ª—è–µ—Ç –∞–¥–º–∏–Ω–∞ —Å –ª–∏–º–∏—Ç–æ–º 100 ‚ÇΩ –Ω–∞ —Ç–µ—Å—Ç—ã.")
            return
        
        try:
            new_admin_id = int(context.args[0])
            
            # Check if already admin
            if new_admin_id == ADMIN_ID:
                await update.message.reply_text("‚ùå –≠—Ç–æ –≥–ª–∞–≤–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä.")
                return
            
            admin_limits = get_admin_limits()
            if str(new_admin_id) in admin_limits:
                await update.message.reply_text(f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {new_admin_id} —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º.")
                return
            
            # Add admin with 100 rubles limit
            # NOTE: time already imported at top level
            admin_limits[str(new_admin_id)] = {
                'limit': 100.0,
                'spent': 0.0,
                'added_by': update.effective_user.id,
                'added_at': int(time.time())
            }
            save_admin_limits(admin_limits)
            
            await update.message.reply_text(
                f"‚úÖ <b>–ê–¥–º–∏–Ω –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
                f"üë§ User ID: {new_admin_id}\n"
                f"üí≥ –õ–∏–º–∏—Ç: 100.00 ‚ÇΩ\n"
                f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: 0.00 ‚ÇΩ\n"
                f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: 100.00 ‚ÇΩ",
                parse_mode='HTML'
            )
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    # Add handlers
    # üî¥ –ì–õ–û–ë–ê–õ–¨–ù–´–ô ERROR HANDLER
    async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –¥–ª—è –≤—Å–µ—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π –≤ –±–æ—Ç–µ.
        –õ–æ–≥–∏—Ä—É–µ—Ç –∫–æ—Ä–æ—Ç–∫–æ (–±–µ–∑ —Å–µ–∫—Ä–µ—Ç–æ–≤), –æ—Ç–≤–µ—á–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –±–µ–∑–æ–ø–∞—Å–Ω–æ.
        –û—à–∏–±–∫–∞ –Ω–µ –¥–æ–ª–∂–Ω–∞ –≤–∞–ª–∏—Ç—å polling.
        –ö–†–ò–¢–ò–ß–ù–û: –ù–ï –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç polling, –ù–ï –¥–µ–ª–∞–µ—Ç retry - —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ—Ç!
        """
        try:
            error = context.error
            error_type = type(error).__name__
            error_msg = str(error)
            
            # –ö–†–ò–¢–ò–ß–ù–û: –õ–æ–≥–∏—Ä—É–µ–º –í–°–ï –æ—à–∏–±–∫–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.error(f"[ERROR_HANDLER] Called with error: {error_type}: {error_msg[:200]}")
            
            # ==================== –ö–†–ò–¢–ò–ß–ù–û: –û–±—Ä–∞–±–æ—Ç–∫–∞ 409 Conflict ====================
            # –ï—Å–ª–∏ —ç—Ç–æ Conflict –æ—à–∏–±–∫–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ—ë —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ (graceful exit)
            from telegram.error import Conflict as TelegramConflict
            if isinstance(error, TelegramConflict) or "Conflict" in error_msg or "terminated by other getUpdates" in error_msg or "409" in error_msg:
                logger.error(f"‚ùå‚ùå‚ùå 409 CONFLICT DETECTED: {error_msg}")
                logger.error("   Another bot instance is running or webhook is active")
                logger.error("   This process will exit gracefully to prevent conflicts")
                logger.error("   üí° ACTIONS:")
                logger.error("      1. Check Render Dashboard - ensure only ONE service is running")
                logger.error("      2. Check local runs - stop all bot instances")
                logger.error("      3. Verify singleton lock is working correctly")
                logger.error("      4. Ensure webhook is deleted: curl https://api.telegram.org/bot<TOKEN>/deleteWebhook?drop_pending_updates=true")
                
                # CRITICAL: Stop updater FIRST to stop polling loop immediately
                try:
                    if hasattr(context, 'application') and context.application:
                        app = context.application
                        # Stop updater polling immediately
                        if hasattr(app, 'updater') and app.updater:
                            try:
                                if app.updater.running:
                                    logger.info("   Stopping updater polling immediately...")
                                    await app.updater.stop()
                                    logger.info("   Updater stopped")
                            except Exception as updater_error:
                                logger.warning(f"   Could not stop updater: {updater_error}")
                        
                        # Then stop application
                        try:
                            if app.running:
                                logger.info("   Stopping application...")
                                await app.stop()
                                await app.shutdown()
                                logger.info("   Application stopped")
                        except Exception as stop_error:
                            logger.warning(f"   Could not stop application: {stop_error}")
                except Exception as e:
                    logger.warning(f"   Error stopping updater/application: {e}")
                
                try:
                    handle_conflict_gracefully(error, "polling")
                except Exception as e:
                    logger.error(f"   Error in handle_conflict_gracefully: {e}")
                
                # Graceful shutdown –ø—Ä–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–µ
                logger.error("   Exiting gracefully to prevent repeated conflicts...")
                try:
                    from app.locking.single_instance import release_single_instance_lock
                    release_single_instance_lock()
                except:
                    pass
                
                # CRITICAL: Use os._exit(0) for immediate termination without cleanup
                # This prevents Render from restarting and stops polling loop immediately
                # os._exit() terminates the process immediately, bypassing cleanup handlers
                # Exit code 0 = success, Render won't restart the service
                import os
                logger.info("   Exiting with code 0 (immediate termination, no restart needed)")
                os._exit(0)  # Immediate exit - stops polling loop, Render won't restart
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Å –ø–æ–ª–Ω—ã–º traceback –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ-Conflict –æ—à–∏–±–æ–∫)
            logger.exception(f"‚ùå‚ùå‚ùå GLOBAL ERROR HANDLER: {error_type}: {error_msg}")
            
            # ==================== SELF-HEAL: –ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è ====================
            try:
                from app.observability.error_guard import ErrorGuard
                project_root = Path(__file__).parent
                error_guard = ErrorGuard(project_root)
                
                # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
                user_id = None
                callback_data = None
                if isinstance(update, Update):
                    if update.effective_user:
                        user_id = update.effective_user.id
                    if update.callback_query:
                        callback_data = update.callback_query.data
                
                # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–∏–º–µ–Ω–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ñ–∏–∫—Å
                fixed = await error_guard.handle_error(
                    error, update, context, user_id, callback_data
                )
                
                if fixed:
                    logger.info("‚úÖ –û—à–∏–±–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ (self-heal)")
                
            except Exception as heal_error:
                logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ self-heal: {heal_error}")
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—ã—á–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–∫–∏
            
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å user_id –∏–∑ update
            user_id = None
            user_lang = 'ru'
            chat_id = None
            
            if isinstance(update, Update):
                if update.effective_user:
                    user_id = update.effective_user.id
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                if update.effective_chat:
                    chat_id = update.effective_chat.id
            
            # –õ–æ–≥–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏
            error_details = {
                'error_type': error_type,
                'error_message': error_msg,
                'user_id': user_id,
                'chat_id': chat_id
            }
            logger.error(f"Error details: {error_details}")
            
            # ==================== NO-SILENCE GUARD: Ensure response on error ====================
            from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
            guard = get_no_silence_guard()
            update_id = update.update_id if isinstance(update, Update) else None
            
            # –î–ª—è callback –æ—à–∏–±–æ–∫ –æ—Ç–≤–µ—á–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ
            if isinstance(update, Update) and update.callback_query:
                try:
                    error_text = "‚ö†Ô∏è –û—à–∏–±–∫–∞. –û—Ç–∫—Ä–æ–π—Ç–µ /start" if user_lang == 'ru' else "‚ö†Ô∏è Error. Open /start"
                    await update.callback_query.answer(error_text, show_alert=True)
                    if update_id:
                        track_outgoing_action(update_id)
                except Exception as e:
                    logger.warning(f"Could not answer callback in error handler: {e}")
            
            # –î–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –æ—Ç–≤–µ—Ç
            if isinstance(update, Update) and update.message and chat_id:
                try:
                    error_text = (
                        "‚ùå <b>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞</b>\n\n"
                        "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\n\n"
                        "–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
                    ) if user_lang == 'ru' else (
                        "‚ùå <b>An error occurred</b>\n\n"
                        "Server error, please try later.\n\n"
                        "If the problem persists, please contact support."
                    )
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=error_text,
                        parse_mode='HTML'
                    )
                    if update_id:
                        track_outgoing_action(update_id)
                except Exception as e:
                    logger.warning(f"Could not send error message: {e}")
            
            # NO-SILENCE GUARD: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª –æ—Ç–≤–µ—Ç
            if update_id:
                await guard.check_and_ensure_response(update, context)
            # ==================== END NO-SILENCE GUARD ====================
        except Exception as e:
            # –ï—Å–ª–∏ —Å–∞–º error handler —É–ø–∞–ª, –ª–æ–≥–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫—É—é –æ—à–∏–±–∫—É
            logger.critical(f"‚ùå‚ùå‚ùå CRITICAL: Error handler itself failed: {e}", exc_info=True)
    
    application.add_error_handler(error_handler)
    
    # Add payment handlers for Telegram Stars
    # NOTE: MessageHandler and filters already imported at top level, don't re-import
    from telegram.ext import PreCheckoutQueryHandler
    application.add_handler(PreCheckoutQueryHandler(pre_checkout_query_handler))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_handler))
    
    # CRITICAL FIX: Add universal photo handler as fallback to catch photos that ConversationHandler misses
    # This ensures photos are ALWAYS processed, even if ConversationHandler doesn't handle them
    async def universal_photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Universal photo handler that processes photos if ConversationHandler doesn't."""
        user_id = update.effective_user.id
        logger.info(f"üîµüîµüîµ UNIVERSAL_PHOTO_HANDLER CALLED: user_id={user_id}, has_photo={bool(update.message and update.message.photo)}")
        
        # Check if user is in conversation
        if user_id in user_sessions:
            session = user_sessions[user_id]
            model_id = session.get('model_id', 'Unknown')
            waiting_for = session.get('waiting_for', 'None')
            logger.info(f"üîµ User {user_id} has session: model_id={model_id}, waiting_for={waiting_for}")
            
            # If user is waiting for image, process it
            if waiting_for in ['image_input', 'image_urls', 'image', 'mask_input', 'reference_image_input']:
                logger.info(f"üîµ User {user_id} is waiting for {waiting_for}, calling input_parameters...")
                # Call input_parameters directly
                return await input_parameters(update, context)
            else:
                logger.warning(f"üîµ User {user_id} sent photo but waiting_for={waiting_for}, not processing")
        else:
            logger.warning(f"üîµ User {user_id} sent photo but no session found")
    
    # Add universal photo handler AFTER generation_handler to catch missed photos
    application.add_handler(MessageHandler(filters.PHOTO, universal_photo_handler))
    
    # Self-test command (admin only)
    async def selftest_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Self-test command –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (admin only)."""
        user_id = update.effective_user.id
        if user_id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        config = get_config_summary()
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º gateway
        gateway = get_kie_gateway()
        from kie_gateway import MockKieGateway, RealKieGateway
        if isinstance(gateway, MockKieGateway):
            gateway_type = "MockKieGateway"
        elif isinstance(gateway, RealKieGateway):
            gateway_type = "RealKieGateway"
        else:
            gateway_type = f"{type(gateway).__name__}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º storage
        storage_status = "‚ùå –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
        try:
            from app.storage.factory import get_storage
            storage = get_storage()
            # –í–ê–ñ–ù–û: –í async –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º async_test_connection
            if hasattr(storage, 'async_test_connection'):
                test_result = await storage.async_test_connection()
                if test_result:
                    storage_status = "‚úÖ –¥–æ—Å—Ç—É–ø–Ω–æ"
                else:
                    storage_status = "‚ö†Ô∏è —Ç–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ –ø—Ä–æ—à–µ–ª"
            else:
                # Fallback –¥–ª—è storage –±–µ–∑ async –º–µ—Ç–æ–¥–∞
                if storage.test_connection():
                    storage_status = "‚úÖ –¥–æ—Å—Ç—É–ø–Ω–æ"
                else:
                    storage_status = "‚ö†Ô∏è —Ç–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ –ø—Ä–æ—à–µ–ª"
        except Exception as e:
            storage_status = f"‚ùå –æ—à–∏–±–∫–∞: {str(e)[:50]}"
        db_status = storage_status  # For compatibility with existing code
        
        # –°–æ–±–∏—Ä–∞–µ–º callback_data –∏–∑ –∫–ª–∞–≤–∏–∞—Ç—É—Ä
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ test_callbacks_smoke, –Ω–æ –µ—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é
            try:
                from tests.test_callbacks_smoke import get_all_known_callbacks
                callback_count = len(get_all_known_callbacks())
            except ImportError:
                # Fallback: —Å—á–∏—Ç–∞–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
                known_patterns = [
                    'show_models', 'show_all_models_list', 'category:', 'all_models',
                    'gen_type:', 'free_tools', 'check_balance', 'language_select:',
                    'change_language', 'copy_bot', 'claim_gift', 'help_menu',
                    'support_contact', 'select_model:', 'back_to_menu', 'topup_balance',
                    'topup_amount:', 'topup_custom', 'referral_info', 'generate_again',
                    'my_generations', 'gen_view:', 'gen_repeat:', 'gen_history:',
                    'tutorial_start', 'tutorial_step', 'tutorial_complete', 'confirm_generate',
                    'retry_generate:', 'cancel', 'back_to_previous_step', 'set_param:',
                ]
                callback_count = len(known_patterns) + len(get_models_sync())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
        except Exception as e:
            callback_count = f"N/A ({str(e)[:30]})"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç
        report = (
            "üîç <b>Self-Test Report</b>\n\n"
            f"üìã <b>–†–µ–∂–∏–º—ã:</b>\n"
            f"  TEST_MODE: {'‚úÖ' if config['TEST_MODE'] else '‚ùå'}\n"
            f"  DRY_RUN: {'‚úÖ' if config['DRY_RUN'] else '‚ùå'}\n"
            f"  ALLOW_REAL_GENERATION: {'‚úÖ' if config['ALLOW_REAL_GENERATION'] else '‚ùå'}\n\n"
            f"üîß <b>Gateway:</b> {gateway_type}\n\n"
            f"üóÑÔ∏è <b>–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö:</b> {db_status}\n\n"
            f"üîò <b>Callback data:</b> {callback_count} –Ω–∞–π–¥–µ–Ω–æ\n\n"
            f"‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –í TEST_MODE/DRY_RUN –±–∞–ª–∞–Ω—Å –ù–ï —Å–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è"
        )
        
        await update.message.reply_text(report, parse_mode='HTML')
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("balance", check_balance))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("ask", ask))
    application.add_handler(CommandHandler("add", add_knowledge))
    application.add_handler(CommandHandler("selftest", selftest_command))
    application.add_handler(CommandHandler("payments", admin_payments))
    application.add_handler(CommandHandler("block_user", admin_block_user))
    application.add_handler(CommandHandler("unblock_user", admin_unblock_user))
    application.add_handler(CommandHandler("user_balance", admin_user_balance))
    application.add_handler(CommandHandler("add_admin", admin_add_admin))
    # Add separate handlers for main menu buttons (works outside ConversationHandler)
    # This ensures the buttons work from main menu
    # NOTE: These handlers must be registered BEFORE generation_handler to catch callbacks first
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^show_models$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^show_all_models_list$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^back_to_menu$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^gen_type:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^category:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^all_models$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^check_balance$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^topup_balance$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^topup_amount:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^topup_custom$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^referral_info$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^my_generations$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^gen_view:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^gen_repeat:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^gen_history:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^help_menu$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^support_contact$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^change_language$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^language_select:'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^free_tools$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^claim_gift$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^generate_again$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^copy_bot$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^tutorial_start$'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^tutorial_step'))
    application.add_handler(CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'))
    
    # CRITICAL: Add universal fallback handler for ALL other callbacks
    # This ensures NO button is left unhandled - catches everything not matched above
    # Must be registered AFTER specific handlers but BEFORE generation_handler
    # This handler will catch any callback_data that doesn't match patterns above
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # üî¥ –ì–õ–û–ë–ê–õ–¨–ù–´–ô ERROR HANDLER
    # –î—É–±–ª–∏–∫–∞—Ç error_handler —É–¥–∞–ª–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 24313)
    
    application.add_handler(generation_handler)
    application.add_handler(CommandHandler("models", list_models))
    
    # HTTP server already started at the beginning of main()
    # Run the bot
    logger.info("Bot starting...")
    
    # ==================== BOT MODE SELECTION ====================
    # –ö–†–ò–¢–ò–ß–ù–û: –°—Ç—Ä–æ–≥–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ polling –∏ webhook —á–µ—Ä–µ–∑ BOT_MODE
    bot_mode = get_bot_mode()
    logger.info(f"üì° Bot mode: {bot_mode}")
    
    # –ï—Å–ª–∏ webhook —Ä–µ–∂–∏–º - –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º polling
    if bot_mode == "webhook":
        webhook_url = WEBHOOK_URL or os.getenv("WEBHOOK_URL")
        if not webhook_url:
            logger.error("‚ùå WEBHOOK_URL not set for webhook mode!")
            logger.error("   Set WEBHOOK_URL environment variable or use BOT_MODE=polling")
            return
        
        logger.info(f"üåê Starting webhook mode: {webhook_url}")
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook
        try:
            from telegram import Bot
            temp_bot = Bot(token=BOT_TOKEN)
            if not await ensure_webhook_mode(temp_bot, webhook_url):
                logger.error("‚ùå Failed to set webhook")
                return
            
            logger.info("‚úÖ Webhook mode ready - waiting for updates via webhook")
            logger.info("   Bot will receive updates at: {webhook_url}")
            
            # –í webhook —Ä–µ–∂–∏–º–µ –ø—Ä–æ—Å—Ç–æ –∂–¥—ë–º (webhook handler –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω –æ—Ç–¥–µ–ª—å–Ω–æ)
            # –î–ª—è Render Web Service —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ - –æ–Ω–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å POST –∑–∞–ø—Ä–æ—Å—ã
            while True:
                await asyncio.sleep(60)  # Health check loop
        except Conflict as e:
            handle_conflict_gracefully(e, "webhook")
            return
        except Exception as e:
            logger.error(f"‚ùå Error in webhook mode: {e}")
            return
    
    # Polling —Ä–µ–∂–∏–º - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ
    logger.info("üì° Starting polling mode")
    
    # CRITICAL: Wait longer to let any previous instance finish completely
    # –ù–∞ Render –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤, –∑–∞–ø—É—Å–∫–∞—é—â–∏—Ö—Å—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    logger.info("‚è≥ Waiting 10 seconds to avoid conflicts with previous instance...")
    await asyncio.sleep(10)
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ polling
    logger.info("üîç Final conflict check before polling...")
    try:
        from telegram import Bot
        check_bot = Bot(token=BOT_TOKEN)
        # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å webhook info - –µ—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π polling, —ç—Ç–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç
        webhook_info = await check_bot.get_webhook_info()
        if webhook_info.url:
            logger.warning(f"‚ö†Ô∏è Webhook still active: {webhook_info.url}, removing...")
            await check_bot.delete_webhook(drop_pending_updates=True)
            await asyncio.sleep(2)
        
        # –ü—Ä–æ–±—É–µ–º getUpdates —Å –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–º timeout –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞
        try:
            await check_bot.get_updates(offset=-1, limit=1, timeout=1)
        except Exception as test_e:
            if "Conflict" in str(test_e) or "terminated by other getUpdates" in str(test_e):
                logger.error("‚ùå‚ùå‚ùå CONFLICT DETECTED: Another instance is polling!")
                logger.error("   Exiting gracefully to prevent 409 Conflict...")
                handle_conflict_gracefully(test_e, "polling")
                return
    except Exception as e:
        if "Conflict" in str(e) or "terminated by other getUpdates" in str(e):
            logger.error("‚ùå‚ùå‚ùå CONFLICT DETECTED during pre-check!")
            handle_conflict_gracefully(e, "polling")
            return
        logger.warning(f"‚ö†Ô∏è Pre-check warning (non-critical): {e}")
    
    # –ö–†–ò–¢–ò–ß–ù–û: –£–¥–∞–ª–∏—Ç—å –í–°–ï webhook –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º polling
    async def preflight_telegram():
        """
        Preflight –ø—Ä–æ–≤–µ—Ä–∫–∞: —É–¥–∞–ª—è–µ—Ç webhook –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤.
        –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ polling –±—É–¥–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –∞–ø–¥–µ–π—Ç–æ–≤.
        –¢–û–õ–¨–ö–û –¥–ª—è polling —Ä–µ–∂–∏–º–∞!
        """
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π bot –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ (–±–µ–∑ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ application)
            from telegram import Bot
            temp_bot = Bot(token=BOT_TOKEN)
            
            async with temp_bot:
                # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ webhook
                logger.info("üîç Checking webhook status...")
                webhook_info = await temp_bot.get_webhook_info()
                
                if webhook_info.url:
                    logger.warning(f"‚ö†Ô∏è Webhook –æ–±–Ω–∞—Ä—É–∂–µ–Ω: {webhook_info.url}")
                    logger.info("üóëÔ∏è –£–¥–∞–ª—è—é webhook —Å drop_pending_updates=True...")
                    
                    # –£–¥–∞–ª—è–µ–º webhook —Å –æ—á–∏—Å—Ç–∫–æ–π –æ—á–µ—Ä–µ–¥–∏
                    result = await temp_bot.delete_webhook(drop_pending_updates=True)
                    logger.info(f"‚úÖ Webhook —É–¥–∞–ª—ë–Ω: {result}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ webhook –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª—ë–Ω
                    await asyncio.sleep(1)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è Telegram API
                    webhook_info_after = await temp_bot.get_webhook_info()
                    
                    if webhook_info_after.url:
                        logger.error(f"‚ùå Webhook –≤—Å—ë –µ—â—ë —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_info_after.url}")
                        logger.error("üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è...")
                        await temp_bot.delete_webhook(drop_pending_updates=True)
                        await asyncio.sleep(1)
                        webhook_info_final = await temp_bot.get_webhook_info()
                        if webhook_info_final.url:
                            logger.error("‚ùå‚ùå‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook –ø–æ—Å–ª–µ 2 –ø–æ–ø—ã—Ç–æ–∫!")
                            raise RuntimeError(f"Webhook still active: {webhook_info_final.url}")
                        else:
                            logger.info("‚úÖ Webhook —É–¥–∞–ª—ë–Ω –ø–æ—Å–ª–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏")
                    else:
                        logger.info("‚úÖ Webhook –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—ë–Ω, –≥–æ—Ç–æ–≤ –∫ polling")
                else:
                    logger.info("‚úÖ Webhook –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≥–æ—Ç–æ–≤ –∫ polling")
                
                # –®–∞–≥ 2: –ò—Å–ø–æ–ª—å–∑—É–µ–º bot_mode helper –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ polling —Ä–µ–∂–∏–º–∞
                if not await ensure_polling_mode(temp_bot):
                    raise RuntimeError("Failed to ensure polling mode")
                
                logger.info("‚úÖ Preflight check passed: no conflicts detected, ready for polling")
        except Conflict as e:
            handle_conflict_gracefully(e, "polling")
            raise
        except Exception as e:
            error_msg = str(e)
            if "Conflict" in error_msg or "terminated by other getUpdates" in error_msg:
                from telegram.error import Conflict as TelegramConflict
                handle_conflict_gracefully(TelegramConflict(str(e)), "polling")
                raise
            else:
                logger.warning(f"‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ preflight check: {e}")
                # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
    
    # ==================== –ï–î–ò–ù–ê–Ø –¢–û–ß–ö–ê –í–•–û–î–ê –î–õ–Ø –°–¢–ê–†–¢–ê POLLING ====================
    # –ñ—ë—Å—Ç–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—É—Å–∫–æ–≤ (409 Conflict)
    async def safe_start_polling(application: Application, *, drop_updates: bool = True):
        """
        –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–æ—Å–æ–± –∑–∞–ø—É—Å–∫–∞ polling.
        –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ polling –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑.
        –ö–†–ò–¢–ò–ß–ù–û: –£–¥–∞–ª—è–µ—Ç webhook –ü–ï–†–ï–î –∑–∞–ø—É—Å–∫–æ–º polling.
        """
        global _POLLING_STARTED
        
        async with _POLLING_LOCK:
            if _POLLING_STARTED:
                logger.warning("‚ö†Ô∏è Polling already started; skip second start")
                return
            _POLLING_STARTED = True
        
        # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ single instance lock –≤—Å–µ –µ—â–µ –∞–∫—Ç–∏–≤–µ–Ω –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º polling
        from app.locking.single_instance import is_lock_held
        if not is_lock_held():
            logger.error("‚ùå‚ùå‚ùå Single instance lock –Ω–µ —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è! –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å polling.")
            logger.error("   This should not happen - lock should be acquired at startup")
            raise RuntimeError("Single instance lock not held - cannot start polling")
        
        logger.info("‚úÖ Single instance lock verified - proceeding with polling start")
        
        # –ö–†–ò–¢–ò–ß–ù–û: Polling mode must not have webhook
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º temp Bot –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è webhook –ü–ï–†–ï–î –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π application
        logger.info("üóëÔ∏è Removing webhook before polling start...")
        try:
            from telegram import Bot
            async with Bot(token=BOT_TOKEN) as temp_bot:
                await temp_bot.delete_webhook(drop_pending_updates=drop_updates)
                webhook_info = await temp_bot.get_webhook_info()
                if webhook_info.url:
                    logger.warning(f"‚ö†Ô∏è Webhook still present after delete: {webhook_info.url}")
                else:
                    logger.info("‚úÖ Webhook removed successfully")
        except Conflict as e:
            handle_conflict_gracefully(e, "polling")
            raise
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error removing webhook: {e}")
            # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ - –ø—Ä–æ–¥–æ–ª–∂–∏–º
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling
        logger.info("üöÄ Initializing application...")
        await application.initialize()
        await application.start()
        
        logger.info("üì° Starting polling...")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º polling —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π Conflict
        try:
            await application.updater.start_polling(drop_pending_updates=drop_updates)
            logger.info("‚úÖ Polling started successfully!")
        except Conflict as e:
            logger.error(f"‚ùå‚ùå‚ùå Conflict during polling start: {e}")
            logger.error("   Another bot instance is already polling")
            try:
                await application.stop()
                await application.shutdown()
            except:
                pass
            try:
                from app.locking.single_instance import release_single_instance_lock
                release_single_instance_lock()
            except:
                pass
            handle_conflict_gracefully(e, "polling")
            import os
            os._exit(0)  # Immediate exit
        except Exception as e:
            error_msg = str(e)
            if "Conflict" in error_msg or "terminated by other getUpdates" in error_msg or "409" in error_msg:
                logger.error(f"‚ùå‚ùå‚ùå Conflict detected during polling start: {error_msg}")
                try:
                    await application.stop()
                    await application.shutdown()
                except:
                    pass
                try:
                    from app.locking.single_instance import release_single_instance_lock
                    release_single_instance_lock()
                except:
                    pass
                from telegram.error import Conflict as TelegramConflict
                handle_conflict_gracefully(TelegramConflict(error_msg), "polling")
                import os
                os._exit(0)  # Immediate exit
            else:
                raise  # Re-raise non-Conflict errors
    
    # –í—ã–ø–æ–ª–Ω—è–µ–º preflight –ø—Ä–æ–≤–µ—Ä–∫—É
    logger.info("üöÄ Starting preflight check (webhook removal + conflict detection)...")
    try:
        await preflight_telegram()
        logger.info("‚úÖ Preflight check passed: ready to start bot")
    except RuntimeError as e:
        if "Another bot instance" in str(e) or "Conflict" in str(e):
            logger.error("‚ùå Cannot start: Another bot instance is running!")
            logger.error("Fix the conflict and restart the service.")
            return
        else:
            raise
    except Conflict as e:
        handle_conflict_gracefully(e, "polling")
        return
    except Exception as e:
        if "Conflict" in str(e) or "terminated by other getUpdates" in str(e):
            from telegram.error import Conflict as TelegramConflict
            handle_conflict_gracefully(TelegramConflict(str(e)), "polling")
            return
        else:
            logger.warning(f"‚ö†Ô∏è Preflight warning (continuing): {e}")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º polling —á–µ—Ä–µ–∑ –µ–¥–∏–Ω—É—é —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞
    await safe_start_polling(application, drop_updates=True)
    
    # –ñ–¥—ë–º –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ (polling —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ñ–æ–Ω–µ)
    # Advisory lock –±—É–¥–µ—Ç –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω —á–µ—Ä–µ–∑ atexit handler –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞
    try:
        await asyncio.Event().wait()  # –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ
    except KeyboardInterrupt:
        logger.info("üõë Shutting down bot (KeyboardInterrupt)...")
    finally:
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º application
        try:
            await application.stop()
            await application.shutdown()
        except Exception as e:
            logger.error(f"Error stopping application: {e}")
        
        # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º single instance lock –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∫ atexit)
        try:
            from app.locking.single_instance import release_single_instance_lock
            release_single_instance_lock()
            logger.info("‚úÖ Single instance lock released in finally block")
        except Exception as e:
            logger.error(f"Error releasing lock in finally: {e}")


# ==================== HEALTH HTTP SERVER FOR RENDER ====================
# –ü—Ä–æ—Å—Ç–æ–π HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è health check (—á—Ç–æ–±—ã Render –Ω–µ –∂–∞–ª–æ–≤–∞–ª—Å—è –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–æ—Ä—Ç–∞)
class HealthHandler(BaseHTTPRequestHandler):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è health check endpoints"""
    def do_GET(self):
        if self.path in ("/", "/health", "/healthz"):
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"ok")
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        # –û—Ç–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ (—á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å –ª–æ–≥–∏)
        return  # silence

def start_health_server():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Å—Ç–æ–π HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è health check"""
    try:
        port = int(os.getenv("PORT", "10000"))
        server = HTTPServer(("0.0.0.0", port), HealthHandler)
        logger.info(f"‚úÖ Health server started on 0.0.0.0:{port}")
        logger.info(f"   Health check endpoints: /, /health, /healthz")
        server.serve_forever()
    except OSError as e:
        if "Address already in use" in str(e):
            logger.warning(f"‚ö†Ô∏è Port {port} already in use, health server may already be running")
        else:
            logger.error(f"‚ùå Failed to start health server: {e}")
    except Exception as e:
        logger.error(f"‚ùå Failed to start health server: {e}")
        # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞

if __name__ == '__main__':
    # ENV-—É–ø—Ä–∞–≤–ª—è–µ–º—ã–π —Ä–µ–∂–∏–º: –≤–∫–ª—é—á–∞–µ–º health server —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ (–¥–ª—è Web Service)
    ENABLE_HEALTH_SERVER = os.getenv("ENABLE_HEALTH_SERVER", "1") == "1"
    
    if ENABLE_HEALTH_SERVER:
        # –ö–†–ò–¢–ò–ß–ù–û: –ó–∞–ø—É—Å–∫–∞–µ–º health —Å–µ—Ä–≤–µ—Ä –ü–ï–†–ï–î –±–æ—Ç–æ–º, —á—Ç–æ–±—ã Render –≤–∏–¥–µ–ª –æ—Ç–∫—Ä—ã—Ç—ã–π –ø–æ—Ä—Ç
        port = int(os.getenv("PORT", "10000"))
        logger.info(f"üöÄ Starting health server on port {port}...")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º health —Å–µ—Ä–≤–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ (daemon - —É–º—Ä—ë—Ç —Å –æ—Å–Ω–æ–≤–Ω—ã–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º)
        health_thread = threading.Thread(target=start_health_server, daemon=True)
        health_thread.start()
        
        # –î–∞—ë–º —Å–µ—Ä–≤–µ—Ä—É –≤—Ä–µ–º—è –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è (Render –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ—Ä—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞)
        time.sleep(1)
        logger.info(f"‚úÖ Health server listening on 0.0.0.0:{port}")
    else:
        logger.info("‚ÑπÔ∏è Health server disabled (ENABLE_HEALTH_SERVER=0) - running as Worker")
    
    # –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —á–µ—Ä–µ–∑ asyncio.run
    # –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–∞—Ö - —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–∑–æ–≤–µ
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üõë Bot stopped by user (KeyboardInterrupt)")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Fatal error in main(): {e}", exc_info=True)
        logger.error("‚ùå Bot failed to start. Check logs above for details.")
        sys.exit(1)


