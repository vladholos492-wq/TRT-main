# ИНСТРУКЦИЯ: Интеграция модулей оптимизации

## Модули для интеграции

### 1. `db_optimization.py`
**Назначение:** Оптимизация работы с базой данных

**Интеграция:**
- Заменить `get_user_balance()` на `get_user_balance_optimized()` в местах проверки баланса
- Использовать `invalidate_balance_cache()` после изменения баланса
- Использовать `get_user_generations_optimized()` для получения генераций пользователя

**Пример:**
```python
# Вместо get_user_balance(user_id) использовать:
from db_optimization import get_user_balance_optimized, invalidate_balance_cache

user_balance = get_user_balance_optimized(user_id)

# После изменения баланса:
invalidate_balance_cache(user_id)
```

---

### 2. `api_optimization.py`
**Назначение:** Оптимизация взаимодействия с API

**Интеграция:**
- Использовать `deduplicate_api_request()` для предотвращения дубликатов
- Использовать `cached_api_request()` для кеширования запросов
- Использовать `validate_api_params_before_request()` перед отправкой запроса

**Пример:**
```python
from api_optimization import deduplicate_api_request, create_request_key, validate_api_params_before_request

# Валидация перед запросом
is_valid, error_msg = validate_api_params_before_request(model_id, params)
if not is_valid:
    return error_msg

# Дедупликация запроса
request_key = create_request_key('create_task', model_id=model_id, params=params)
result = await deduplicate_api_request(
    request_key,
    lambda: kie_client.create_task(model_id, params)
)
```

---

### 3. `logging_optimization.py`
**Назначение:** Оптимизация логирования

**Интеграция:**
- Заменить `logger.info/error/warning()` на `log_optimized()` для предотвращения дубликатов
- Использовать `log_error_structured()` для структурированного логирования ошибок
- Использовать `log_api_call_optimized()` для логирования API вызовов

**Пример:**
```python
from logging_optimization import log_optimized, log_error_structured, log_api_call_optimized

# Вместо logger.info("message")
log_optimized('INFO', "message")

# Для ошибок
try:
    # код
except Exception as e:
    log_error_structured(e, {'context': 'data'}, user_id, 'operation')

# Для API вызовов
import time
start_time = time.time()
result = await api_call()
duration = time.time() - start_time
log_api_call_optimized('endpoint', 'POST', duration, success=True)
```

---

### 4. `generation_logic_optimization.py`
**Назначение:** Упрощение логики генерации

**Интеграция:**
- Использовать `prepare_generation_request()` для подготовки запроса
- Использовать `check_balance_with_bonuses()` для проверки баланса
- Использовать `deduct_balance_with_bonuses()` для списания баланса

**Пример:**
```python
from generation_logic_optimization import (
    prepare_generation_request,
    check_balance_with_bonuses,
    deduct_balance_with_bonuses
)

# Подготовка запроса
params, error_msg = prepare_generation_request(model_id, params, user_id)
if error_msg:
    return error_msg

# Проверка баланса
has_enough, main_balance, bonus_balance, needed = check_balance_with_bonuses(user_id, price)
if not has_enough:
    # Показать сообщение о недостаточном балансе
    return

# Списание баланса
success, deducted_main, deducted_bonus = deduct_balance_with_bonuses(user_id, price)
if not success:
    return "Ошибка списания баланса"
```

---

### 5. `validation_simplification.py`
**Назначение:** Упрощение валидации

**Интеграция:**
- Использовать `validate_input_unified()` для унифицированной валидации
- Использовать `validate_all_params_at_once()` для валидации всех параметров
- Использовать `get_parameter_hint_optimized()` для оптимизированных подсказок

**Пример:**
```python
from validation_simplification import validate_input_unified, validate_all_params_at_once

# Валидация одного параметра
is_valid, error_msg = validate_input_unified('prompt', prompt_value)

# Валидация всех параметров
is_valid, errors = validate_all_params_at_once(params, param_schemas)
if not is_valid:
    return "\n".join(errors)
```

---

### 6. `automatic_cleanup.py`
**Назначение:** Автоматическая очистка базы данных

**Интеграция:**
- Запустить `start_periodic_cleanup()` в фоновом режиме при старте бота
- Использовать `run_automatic_cleanup()` для ручной очистки

**Пример:**
```python
from automatic_cleanup import start_periodic_cleanup

# При старте бота
async def main():
    # Запускаем периодическую очистку в фоне
    cleanup_task = asyncio.create_task(
        start_periodic_cleanup(interval_hours=24, days_sessions=7, days_generations=90)
    )
    
    # Запускаем бота
    await application.start()
    await application.updater.start_polling()
    
    # Ожидаем завершения
    await application.updater.stop()
    await application.stop()
    cleanup_task.cancel()
```

---

## Порядок интеграции

1. **Интеграция db_optimization:**
   - Заменить `get_user_balance()` на `get_user_balance_optimized()`
   - Добавить `invalidate_balance_cache()` после изменения баланса

2. **Интеграция api_optimization:**
   - Добавить валидацию перед запросами
   - Добавить дедупликацию для API запросов

3. **Интеграция logging_optimization:**
   - Заменить логирование на оптимизированное
   - Добавить структурированное логирование ошибок

4. **Интеграция generation_logic_optimization:**
   - Использовать `prepare_generation_request()` для подготовки
   - Использовать `check_balance_with_bonuses()` и `deduct_balance_with_bonuses()`

5. **Интеграция validation_simplification:**
   - Использовать унифицированную валидацию
   - Использовать валидацию всех параметров за один проход

6. **Интеграция automatic_cleanup:**
   - Запустить периодическую очистку в фоне

---

## Тестирование

После интеграции проверить:
1. ✅ Баланс кешируется и обновляется корректно
2. ✅ API запросы не дублируются
3. ✅ Логи не содержат дубликатов
4. ✅ Баланс проверяется и списывается с бонусами
5. ✅ Валидация работает корректно
6. ✅ Автоматическая очистка запускается в фоне

